<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL 日志</title>
    <link href="/2021/10/14/MySQL-%E6%97%A5%E5%BF%97/"/>
    <url>/2021/10/14/MySQL-%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="一、错误日志"><a href="#一、错误日志" class="headerlink" title="一、错误日志"></a>一、错误日志</h3><p><code>MySQL</code>错误日志记录了mysql启动和停止时，以及服务器在运行过程中发生任何严重错误的相关信息，当数据库出现任何障碍导致无法正常使用时，可以首先查看此日志。</p><p>错误日志是默认开启的，默认存放的目录为MySQL的数据目录<code>(var/log)</code>，默认的日志文件名为<code>mysqld.log</code>。</p><p>查看日志位置指令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;log_error%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014130458.png" alt="日志文件位置"></p><p>查看日志内容：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">tail -f /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/mysqld.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014130735.png" alt="文件内容"></p><h3 id="二、二进制文件"><a href="#二、二进制文件" class="headerlink" title="二、二进制文件"></a>二、二进制文件</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>二进制日志（BinLog）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是<code>不包括数据查询语句</code>。</p><p>此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。</p><p>二进制日志<code>默认情况下是没有开启的</code>，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 </p><p>查看二进制日志文件是否开启</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%log_bin%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014131442.png" alt="二进制日志文件"></p><h4 id="2、日志格式"><a href="#2、日志格式" class="headerlink" title="2、日志格式"></a>2、日志格式</h4><p><strong>STATEMENT</strong></p><p>该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p><p><strong>ROW</strong></p><p>该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status&#x3D;’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p><p><strong>MIXED</strong></p><p>这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。</p><h4 id="3、开启日志"><a href="#3、开启日志" class="headerlink" title="3、开启日志"></a>3、开启日志</h4><ol><li><p>打开配置文件 默认<code>/etc/my.cnf</code></p></li><li><p>添加配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#由于bug,所以需要设置该参数.否则无法启动mysql实例</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">11</span>     <br><br><span class="hljs-comment"># 代表的是basename就是生成二进制日志文件的前缀部分,默认的位置在datadir目录下,也可以设置为其他的路径</span><br><span class="hljs-attr">log_bin</span>=mysqlbin  <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014132258.png" alt="日志信息"></p></li></ol><h4 id="5、日志使用"><a href="#5、日志使用" class="headerlink" title="5、日志使用"></a>5、日志使用</h4><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> use log_test; <br>Reading <span class="hljs-keyword">table</span> information <span class="hljs-keyword">for</span> completion <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">column</span> names<br>You can turn off this feature <span class="hljs-keyword">to</span> <span class="hljs-keyword">get</span> a quicker startup <span class="hljs-keyword">with</span> <span class="hljs-operator">-</span>A<br><br>Database changed<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test(id,name)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <br></code></pre></td></tr></table></figure><p>查看此时的日志格式：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014135647.png" alt="日志格式"></p><p>查看日志文件</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014133907.png" alt="日志文件"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014134014.png" alt="二进制日志"></p><p>可以看到乱码，因为这是二进制文件，所以无法直接查看</p><p>使用<code>mysqlbinlog</code>查看</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mysqlbinlog mysqlbing.<span class="hljs-number">000001</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014135813.png" alt="查看日志"></p><p>我们更改日志格式：ROW</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014140002.png" alt="更改日志格式"></p><p>插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>查看日志</p><p>如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqlbinlog</span> -vv mysqlbin.<span class="hljs-number">000002</span> <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014140214.png" alt="日志格式ROW"></p><h4 id="6、日志删除"><a href="#6、日志删除" class="headerlink" title="6、日志删除"></a>6、日志删除</h4><p>方法一：执行删除日志指令</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Reset</span> Master<br></code></pre></td></tr></table></figure><p>方法二：执行指令</p><p>该命令将删除  <code> ******</code> 编号之前的所有日志。 </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">purge  <span class="hljs-keyword">master</span> <span class="hljs-title">logs</span> to &#x27;mysqlbin.******&#x27;<br></code></pre></td></tr></table></figure><p>方法三：执行指令</p><p>该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志 。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">purge <span class="hljs-keyword">master</span> <span class="hljs-title">logs</span> before &#x27;yyyy-mm-dd hh24:mi:ss&#x27;<br></code></pre></td></tr></table></figure><h3 id="3、查询日志"><a href="#3、查询日志" class="headerlink" title="3、查询日志"></a>3、查询日志</h3><p>查询日志中记录了客户端的所有操作语句。</p><p>开启日志：</p><p>默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 </span><br><span class="hljs-attr">general_log</span>=<span class="hljs-number">1</span><br><br><span class="hljs-comment">#设置日志的文件名</span><br><span class="hljs-attr">general_log_file</span>=file_name<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014141237.png" alt="修改配置"></p><p>日志使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql">Database changed<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span>  <span class="hljs-operator">|</span> <span class="hljs-number">1</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">update</span> test<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span>  <span class="hljs-operator">|</span> <span class="hljs-number">1</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3</span>  <span class="hljs-operator">|</span> <span class="hljs-number">2</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>查看日志：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014141343.png" alt="查看日志"></p><h3 id="4、慢查询日志"><a href="#4、慢查询日志" class="headerlink" title="4、慢查询日志"></a>4、慢查询日志</h3><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。</p><p>开启日志</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭</span><br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-number">1</span> <br><br><span class="hljs-comment"># 该参数用来指定慢查询日志的文件名</span><br><span class="hljs-attr">slow_query_log_file</span>=slow_query.log<br><br><span class="hljs-comment"># 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10s</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>使用日志</p><p>执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, title,price,num ,status <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014141649.png" alt="查询"></p><p>由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%&#x27;</span> ;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014141729.png" alt="1554130532577"></p><p>该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。</p><p>查看慢查询日志文件</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20211014141808.png" alt="慢查询"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现-压缩列表</title>
    <link href="/2021/09/10/Redis%E5%AE%9E%E7%8E%B0-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <url>/2021/09/10/Redis%E5%AE%9E%E7%8E%B0-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Redis实现-压缩列表"><a href="#Redis实现-压缩列表" class="headerlink" title="Redis实现-压缩列表"></a>Redis实现-压缩列表</h2><h3 id="一、压缩列表在Redis中的使用"><a href="#一、压缩列表在Redis中的使用" class="headerlink" title="一、压缩列表在Redis中的使用"></a>一、压缩列表在Redis中的使用</h3><p>压缩列表<code>(ziplist)</code>是列表键和哈希键的底层实现之一。压缩列表是Redis为了节约内存而开发的。</p><p>当一个列表项，并且每个列表项要么就是小整数值，要么就是比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">127.0.0.1:6379&gt; rpush lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;<br>(integer) 6<br></code></pre></td></tr></table></figure><p>当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是比较短的字符串，那么Redis就会只用压缩列表作为哈希键的底层实现。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">127.0.0.1:6379&gt; hmset pro &quot;name&quot; &quot;jack&quot; &quot;age&quot; 18<br>OK<br></code></pre></td></tr></table></figure><h3 id="二、压缩列表的结构"><a href="#二、压缩列表的结构" class="headerlink" title="二、压缩列表的结构"></a>二、压缩列表的结构</h3><h3 id="1、压缩列表"><a href="#1、压缩列表" class="headerlink" title="1、压缩列表"></a>1、压缩列表</h3><p>压缩列表是<code>一系列特殊编码的连续内存块组成的顺序型</code>数据结构。</p><p>一个压缩列表可以包含任意多个结点，每个节点可以保存<code>一个字节数组或者一个整数值</code>。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910172656.png" alt="压缩列表"></p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">zlbytes</td><td align="center">uint32_t</td><td align="center">4字节</td></tr><tr><td align="center">zltail</td><td align="center">uint32_t</td><td align="center">4字节</td></tr><tr><td align="center">zllen</td><td align="center">uint16_t</td><td align="center">2字节</td></tr><tr><td align="center">entry</td><td align="center">列表节点</td><td align="center">不定</td></tr><tr><td align="center">zlend</td><td align="center">uint8_t</td><td align="center">1字节</td></tr></tbody></table><ul><li><p>zlbytes</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 用途</span><br>记录整个压缩列表占用的内存字节数<br>在对压缩列表进行内存重分配，或者计算zlend的位置时使用<br></code></pre></td></tr></table></figure></li><li><p>zltail</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 用途</span><br>记录压缩列表表尾节点距离起始地址有多少字节<br>通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址<br></code></pre></td></tr></table></figure></li><li><p>zllen</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 用途</span><br>记录了压缩列表包含的节点数量<br>当这个数量小于UINT16<span class="hljs-emphasis">_MAX(65535)时。这个属性的值就是压缩列表包含节点的数量</span><br><span class="hljs-emphasis">当这个数量等于UINT16_</span>MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出<br></code></pre></td></tr></table></figure></li><li><p>entry</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 用途</span><br>压缩列表包含的各个节点，节点的长度由节点保存的内存决定<br></code></pre></td></tr></table></figure></li><li><p>zlend</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 用途</span><br>特殊值(OXFF)，用于标记压缩列表的末端<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910175214.png" alt="压缩列表"></p><p><code>zlbytes</code>属性的值为0xd2(十进制210)，表示压缩列表总长是210字节。</p><p><code>zltail</code>属性的值为0xb3(十进制179)，这就可以计算出表尾节点entry3的地址。</p><p><code>zllen</code>属性的值为0x5(十进制5)，表示压缩列表包含5个节点</p><h3 id="2、压缩列表节点的构成"><a href="#2、压缩列表节点的构成" class="headerlink" title="2、压缩列表节点的构成"></a>2、压缩列表节点的构成</h3><h4 id="2-1、"><a href="#2-1、" class="headerlink" title="2.1、"></a>2.1、</h4><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p><p>字节数组可以是以下三种长度的其中一种：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 长度小于等于(2^6 - 1)字节的字节数组<br><span class="hljs-bullet">2.</span> 长度小于等于(2^14 - 1)字节的字节数组<br><span class="hljs-bullet">3.</span> 长度小于等于(2^32 - 1)字节的字节数组<br></code></pre></td></tr></table></figure><p>整数值是以下六种长度的其中一种：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 4位长，介于0-12之间的无符号整数<br><span class="hljs-bullet">2.</span> 1字节长的有符号整数<br><span class="hljs-bullet">3.</span> 3字节长的有符号整数<br><span class="hljs-bullet">4.</span> int16<span class="hljs-emphasis">_t类型整数</span><br><span class="hljs-emphasis">5. int32_</span>t类型整数<br><span class="hljs-bullet">6.</span> int64<span class="hljs-emphasis">_t类型整数</span><br></code></pre></td></tr></table></figure><p>节点的结构：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910180818.png" alt="节点结构"></p><ul><li><p>previous_entry_length</p><p>以节点为单位，记录了压缩列表中<strong>前一个结点的长度</strong>。</p><p><code>previous_entry_length</code>属性的长度可以是1字节或者5字节。</p><blockquote><p>如果前一个结点的长度小于254字节，那么<code>previous_entry_length</code>属性的长度为1字节，前一个节点的长度就保存在这一个字节里面。</p><p>如果前一个结点的长度大于等于254字节，那么<code>previous_entry_length</code>属性的长度为5字节，其中第一个字节会被设置为0xFE(十进制254)，四个字节保存前一个结点的长度</p></blockquote><p>用途：程序可以通过指针运算，根据当前节点的起始地址来计算出前一个结点的起始地址。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910182722.png" alt="结点"></p><p>在上图中P和C分别是entry2和entry3两个结点的起始值。如果已知了C地址。就可以都到P地址。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">P</span> <span class="hljs-operator">=</span> C - entry3.previous_entry_length<br></code></pre></td></tr></table></figure><p>压缩列表的从表尾向表头遍历就是使用这一原理实现的，只要我们拥有了一个指向某个结点起始地址的指针，通过这个属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头结点。</p></li><li><p>encoding</p><p>节点的<code>encoding</code>属性记录了节点的<code>content</code>属性所保存的类型以及长度。</p><ol><li>一字节、两字节或者五字节，值的最高位为00、01或者10的是字节数组编码<br>这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录</li></ol><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th align="center">content属性保存的值</th></tr></thead><tbody><tr><td align="center">00bbbbbb</td><td align="center">1字节</td><td align="center">长度小于等于<code>(2^6 - 1)</code>字节的字节数组</td></tr><tr><td align="center">01bbbbbb xxxxxxxx</td><td align="center">2字节</td><td align="center">长度小于等于<code>(2^14 - 1)</code>字节的字节数组</td></tr><tr><td align="center">10_ _ _ _ _ _ aaaaaaaa bbbbbbbb cccccccc dddddddd</td><td align="center">5字节</td><td align="center">长度小于等于<code>(2^32 - 1)</code>字节的字节数组</td></tr></tbody></table><ol start="2"><li><p>一字节长，值的最高位以11开头的是整数编码</p><p>这种编码表示节点的content属性保存整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。</p><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th align="center">content属性保存的值</th></tr></thead><tbody><tr><td align="center">11000000</td><td align="center">1字节</td><td align="center">int16_t类型</td></tr><tr><td align="center">11010000</td><td align="center">1字节</td><td align="center">int32_t类型</td></tr><tr><td align="center">11100000</td><td align="center">1字节</td><td align="center">int64_t类型</td></tr><tr><td align="center">11110000</td><td align="center">1字节</td><td align="center">24位有符号整数</td></tr><tr><td align="center">11111110</td><td align="center">1字节</td><td align="center">8位有符号整数</td></tr><tr><td align="center">1111xxxx</td><td align="center">1字节</td><td align="center">使用这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位保存了一个介于0-12之间的值，所以他无需content属性</td></tr></tbody></table></li></ol></li><li><p>content</p><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点encoding属性决定。</p><p>示例1</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910190743.png" alt="节点"></p><p>编码最高两位00表示节点保存的是一个字节数组</p><p>编码的后六位001011记录了字节数组的长度11。</p><p>content属性保存着节点的值”hello world”。</p></li></ul><p>​示例2</p><p>​<img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910191017.png" alt="节点"></p><p>编码11000000表示节点保存的是以恶搞int16_t类型的整数值。</p><p>content属性保存着节点的值10086</p><h3 id="三、连锁更新"><a href="#三、连锁更新" class="headerlink" title="三、连锁更新"></a>三、连锁更新</h3><p>每个节点的<code>previous_entry_length</code>属性都记录了前一个结点的长度。</p><blockquote><p><code>previous_entry_length</code>的长度由以下规则</p><p>如果前一个结点的长度小于254字节，<code>previous_entry_length</code>属性的长度为1字节</p><p>如果前一个结点的长度大于等于254字节，<code>previous_entry_length</code>属性的长度为5字节</p></blockquote><p>现在，有一种情况：在一个压缩列表中，有<strong>多个连续的、长度介于250-253字节之间的结点</strong>。因为所有的结点长度都小于254字节，所以这些结点的<code>previous_entry_length</code>只需一个字节来存储。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910191715.png" alt="连续结点"></p><p>这是，我们将一个长度大于等于254字节的新节点entry0设置为压缩列表的表头节点。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910192000.png" alt="节点列表"></p><p>因为entry1的<code>previous_entry_length</code>属性长度是1个字节。没办法保存新节点的长度。所以程序将对压缩列表执行空间重分配操作，需要将entry1的<code>previous_entry_length</code>属性长度扩展到5字节长。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910193640.png" alt="节点"></p><p>同样，entry1节点的长度增加，超过了254字节，entry2就无法保存entry1的节点长度。因此程序需要再次对压缩列表执行空间重分配操作。将entry2的<code>previous_entry_length</code>属性长度扩展到5字节长。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910193711.png" alt="节点列表"></p><p>因为添加了entry0节点，导致了需要扩展entry1，引发了对entry2、entry3、entry4的扩展。为了让每个节点的<code>previous_entry_length</code>属性都符合压缩列表对节点的要求，程序需要不断对压缩列表执行空间重分配操作，知道entry4为止。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910193825.png" alt="节点列表"></p><p><code>这种产生连续多次空间扩展操作称为&quot;连锁更新&quot;。</code></p><p>连锁更新在更坏情况下，需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)</p><p>但是，它真正造成性能问题的机率是很低的</p><ol><li>长度介于250字节至253字节之间的节点，连锁更才有可能被引发。实际上情况并不多见</li><li>只要更新的节点数量不多，就不会对性能造成影响。</li></ol><h3 id="四、压缩列表API"><a href="#四、压缩列表API" class="headerlink" title="四、压缩列表API"></a>四、压缩列表API</h3><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">ziplistNew</td><td align="center">创建一个新的压缩列表</td></tr><tr><td align="center">ziplistPush</td><td align="center">创建一个包含给定值的新节点，并将这个新节点添加到压缩列表到表头和表尾</td></tr><tr><td align="center">ziplistInsert</td><td align="center">将包含给定值的新节点插入到给定节点之后</td></tr><tr><td align="center">ziplistIndex</td><td align="center">返回压缩列表给定索引上的节点</td></tr><tr><td align="center">ziplistNext</td><td align="center">返回给定节点的下一个节点</td></tr><tr><td align="center">ziplistDelete</td><td align="center">从压缩列表中函数给定的节点</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现-整数集合</title>
    <link href="/2021/09/10/Redis%E5%AE%9E%E7%8E%B0-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <url>/2021/09/10/Redis%E5%AE%9E%E7%8E%B0-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Redis实现-整数集合"><a href="#Redis实现-整数集合" class="headerlink" title="Redis实现-整数集合"></a>Redis实现-整数集合</h2><h3 id="一、整数集合在Redis中的使用"><a href="#一、整数集合在Redis中的使用" class="headerlink" title="一、整数集合在Redis中的使用"></a>一、整数集合在Redis中的使用</h3><p>整数集合<code>(intset)</code>是集合键的底层实现之一。当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">127.0.0.1:6379&gt; sadd members 1 3 5 7 9<br>(integer) 5<br>127.0.0.1:6379&gt; smembers members<br>1) &quot;1&quot;<br>2) &quot;3&quot;<br>3) &quot;5&quot;<br>4) &quot;7&quot;<br>5) &quot;9&quot;<br></code></pre></td></tr></table></figure><h3 id="二、整数集合的实现"><a href="#二、整数集合的实现" class="headerlink" title="二、整数集合的实现"></a>二、整数集合的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-type">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><ul><li><p>contents</p><p><code>contents</code>数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小从小到大地排序，并且不包含任何重复项</p></li><li><p>length</p><p>记录整合集合中包含的元素数量，即contents数组的长度</p></li><li><p>encoding</p><p>虽然<code>intset</code>在声明是将<code>contents[]</code>中的数组项设置为<code>int8_t</code>类型。但在分配内存时，需要根据<code>encoding</code>的值来设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 不同encoding的不同范围</span><br>int16<span class="hljs-emphasis">_t   MIN:-32768    MAX:32767</span><br><span class="hljs-emphasis">int32_</span>t   MIN:-2147483648     MAX:2147483647<br>int64<span class="hljs-emphasis">_t   MIN:-9223372036854775808   MAX:9223372036854775807</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910045820.png" alt="整合集合结构"></p><p>我们在创建这个整数集合时，就确定了数组中数组项的大小。是int16_t、int32_t或者int64_t。</p><p>当我们向整数集合添加元素时，发现这个元素超过了这个数组能存储的最大值。</p><p>这时候需要对数组进行升级。将int16_t升级int32_t。</p><p>比如：在上图中，contents数组中数组项的大小时int16_t。此时如果添加一个整数6379，因此需要将数组项大小由int16_t升级为int32_t。</p><h3 id="三、升级"><a href="#三、升级" class="headerlink" title="三、升级"></a>三、升级</h3><p>当我们将一个新元素添加到整数集合里面，并且新元素的类型比整合集合现有所有元素类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。</p><h4 id="1、升级的步骤"><a href="#1、升级的步骤" class="headerlink" title="1、升级的步骤"></a>1、升级的步骤</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 升级的步骤</span><br><br><span class="hljs-bullet">1.</span> 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间<br><br><span class="hljs-bullet">2.</span> 将底层数组现有的所有元素都转换成与新元素相同的类型。<br><span class="hljs-code">将类型转换后的元素放置到正确位置上，并且保证有序</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">3.</span> 将新元素添加到底层数组里面<br></code></pre></td></tr></table></figure><blockquote><p> 升级之后新元素的摆放位置：</p><p> 要想数组升级，那么新添加的元素值的长度一定比现有所有元素的长度都大。</p><p> 所以这个元素的值要么大于所有的现有元素，要么小于所有的现有元素。</p><p> 当添加元素的值大于所有的现有元素：将元素放置在最末尾contents[0]</p><p> 当添加元素的值小于所有的现有元素：将元素放置在最开头contents[length - 1]</p></blockquote><h4 id="2、升级的好处"><a href="#2、升级的好处" class="headerlink" title="2、升级的好处"></a>2、升级的好处</h4><ul><li><p>提高灵活性</p><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一数据结构里面。</p><p>而整数集合可以自动升级底层数组来适应新元素，我们不必担心出现类型错误。</p></li><li><p>节约内存</p><p>如果所有的都以int64_t的类型来保存，太浪费内存了，将数值小的整数集合全部由int_16或者int32_t来表示，可以节约内存。</p></li></ul><h3 id="四、源码"><a href="#四、源码" class="headerlink" title="四、源码"></a>四、源码</h3><h4 id="创建并返回一个新的空整数集合"><a href="#创建并返回一个新的空整数集合" class="headerlink" title="创建并返回一个新的空整数集合"></a>创建并返回一个新的空整数集合</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create an empty intset. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 创建并返回一个新的空整数集合</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br>intset *<span class="hljs-title function_">intsetNew</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>    <span class="hljs-comment">// 为整数集合结构分配空间</span><br>    intset *is = zmalloc(<span class="hljs-keyword">sizeof</span>(intset));<br><br>    <span class="hljs-comment">// 设置初始编码</span><br>    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);<br><br>    <span class="hljs-comment">// 初始化元素数量</span><br>    is-&gt;length = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将元素-value-添加到整数集合中"><a href="#将元素-value-添加到整数集合中" class="headerlink" title="将元素 value 添加到整数集合中"></a>将元素 value 添加到整数集合中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Insert an integer in the intset </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 尝试将元素 value 添加到整数集合中。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * *success 的值指示添加是否成功：</span><br><span class="hljs-comment"> * - 如果添加成功，那么将 *success 的值设为 1 。</span><br><span class="hljs-comment"> * - 因为元素已存在而造成添加失败时，将 *success 的值设为 0 。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(N)</span><br><span class="hljs-comment"> */</span><br>intset *<span class="hljs-title function_">intsetAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint8_t</span> *success)</span> &#123;<br><br>    <span class="hljs-comment">// 计算编码 value 所需的长度</span><br>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);<br>    <span class="hljs-type">uint32_t</span> pos;<br><br>    <span class="hljs-comment">// 默认设置插入为成功</span><br>    <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 如果 value 的编码比整数集合现在的编码要大</span><br>    <span class="hljs-comment">// 那么表示 value 必然可以添加到整数集合中</span><br>    <span class="hljs-comment">// 并且整数集合需要对自身进行升级，才能满足 value 所需的编码</span><br>    <span class="hljs-keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;<br>        <span class="hljs-comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span><br>        <span class="hljs-comment">// T = O(N)</span><br>        <span class="hljs-keyword">return</span> intsetUpgradeAndAdd(is,value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 运行到这里，表示整数集合现有的编码方式适用于 value</span><br><br>        <span class="hljs-comment">// 在整数集合中查找 value ，看他是否存在：</span><br>        <span class="hljs-comment">// - 如果存在，那么将 *success 设置为 0 ，并返回未经改动的整数集合</span><br>        <span class="hljs-comment">// - 如果不存在，那么可以插入 value 的位置将被保存到 pos 指针中</span><br>        <span class="hljs-comment">//   等待后续程序使用</span><br>        <span class="hljs-keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;<br>            <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> is;<br>        &#125;<br><br>        <span class="hljs-comment">// 运行到这里，表示 value 不存在于集合中</span><br>        <span class="hljs-comment">// 程序需要将 value 添加到整数集合中</span><br>    <br>        <span class="hljs-comment">// 为 value 在集合中分配空间</span><br>        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 如果新元素不是被添加到底层数组的末尾</span><br>        <span class="hljs-comment">// 那么需要对现有元素的数据进行移动，空出 pos 上的位置，用于设置新值</span><br>        <span class="hljs-comment">// 举个例子</span><br>        <span class="hljs-comment">// 如果数组为：</span><br>        <span class="hljs-comment">// | x | y | z | ? |</span><br>        <span class="hljs-comment">//     |&lt;-----&gt;|</span><br>        <span class="hljs-comment">// 而新元素 n 的 pos 为 1 ，那么数组将移动 y 和 z 两个元素</span><br>        <span class="hljs-comment">// | x | y | y | z |</span><br>        <span class="hljs-comment">//         |&lt;-----&gt;|</span><br>        <span class="hljs-comment">// 这样就可以将新元素设置到 pos 上了：</span><br>        <span class="hljs-comment">// | x | n | y | z |</span><br>        <span class="hljs-comment">// T = O(N)</span><br>        <span class="hljs-keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 将新值设置到底层数组的指定位置中</span><br>    _intsetSet(is,pos,value);<br><br>    <span class="hljs-comment">// 增一集合元素数量的计数器</span><br>    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 返回添加新元素后的整数集合</span><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将底层数组在-pos-位置上的值设为-value"><a href="#将底层数组在-pos-位置上的值设为-value" class="headerlink" title="将底层数组在 pos 位置上的值设为 value"></a>将底层数组在 pos 位置上的值设为 value</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Set the value at pos, using the configured encoding. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 根据集合的编码方式，将底层数组在 pos 位置上的值设为 value 。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> _intsetSet(intset *is, <span class="hljs-type">int</span> pos, <span class="hljs-type">int64_t</span> value) &#123;<br><br>    <span class="hljs-comment">// 取出集合的编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);<br><br>    <span class="hljs-comment">// 根据编码 ((Enc_t*)is-&gt;contents) 将数组转换回正确的类型</span><br>    <span class="hljs-comment">// 然后 ((Enc_t*)is-&gt;contents)[pos] 定位到数组索引上</span><br>    <span class="hljs-comment">// 接着 ((Enc_t*)is-&gt;contents)[pos] = value 将值赋给数组</span><br>    <span class="hljs-comment">// 最后， ((Enc_t*)is-&gt;contents)+pos 定位到刚刚设置的新值上 </span><br>    <span class="hljs-comment">// 如果有需要的话， memrevEncifbe 将对值进行大小端转换</span><br>    <span class="hljs-keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;<br>        ((<span class="hljs-type">int64_t</span>*)is-&gt;contents)[pos] = value;<br>        memrev64ifbe(((<span class="hljs-type">int64_t</span>*)is-&gt;contents)+pos);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;<br>        ((<span class="hljs-type">int32_t</span>*)is-&gt;contents)[pos] = value;<br>        memrev32ifbe(((<span class="hljs-type">int32_t</span>*)is-&gt;contents)+pos);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ((<span class="hljs-type">int16_t</span>*)is-&gt;contents)[pos] = value;<br>        memrev16ifbe(((<span class="hljs-type">int16_t</span>*)is-&gt;contents)+pos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回集合的底层数组在-pos-索引上的元素"><a href="#返回集合的底层数组在-pos-索引上的元素" class="headerlink" title="返回集合的底层数组在 pos 索引上的元素"></a>返回集合的底层数组在 pos 索引上的元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Return the value at pos, given an encoding. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 根据给定的编码方式 enc ，返回集合的底层数组在 pos 索引上的元素。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int64_t</span> _intsetGetEncoded(intset *is, <span class="hljs-type">int</span> pos, <span class="hljs-type">uint8_t</span> enc) &#123;<br>    <span class="hljs-type">int64_t</span> v64;<br>    <span class="hljs-type">int32_t</span> v32;<br>    <span class="hljs-type">int16_t</span> v16;<br><br>    <span class="hljs-comment">// ((ENCODING*)is-&gt;contents) 首先将数组转换回被编码的类型</span><br>    <span class="hljs-comment">// 然后 ((ENCODING*)is-&gt;contents)+pos 计算出元素在数组中的正确位置</span><br>    <span class="hljs-comment">// 之后 member(&amp;vEnc, ..., sizeof(vEnc)) 再从数组中拷贝出正确数量的字节</span><br>    <span class="hljs-comment">// 如果有需要的话， memrevEncifbe(&amp;vEnc) 会对拷贝出的字节进行大小端转换</span><br>    <span class="hljs-comment">// 最后将值返回</span><br>    <span class="hljs-keyword">if</span> (enc == INTSET_ENC_INT64) &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;v64,((<span class="hljs-type">int64_t</span>*)is-&gt;contents)+pos,<span class="hljs-keyword">sizeof</span>(v64));<br>        memrev64ifbe(&amp;v64);<br>        <span class="hljs-keyword">return</span> v64;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enc == INTSET_ENC_INT32) &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;v32,((<span class="hljs-type">int32_t</span>*)is-&gt;contents)+pos,<span class="hljs-keyword">sizeof</span>(v32));<br>        memrev32ifbe(&amp;v32);<br>        <span class="hljs-keyword">return</span> v32;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;v16,((<span class="hljs-type">int16_t</span>*)is-&gt;contents)+pos,<span class="hljs-keyword">sizeof</span>(v16));<br>        memrev16ifbe(&amp;v16);<br>        <span class="hljs-keyword">return</span> v16;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在集合-is-的底层数组中查找值-value-所在的索引"><a href="#在集合-is-的底层数组中查找值-value-所在的索引" class="headerlink" title="在集合 is 的底层数组中查找值 value 所在的索引"></a>在集合 is 的底层数组中查找值 value 所在的索引</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在集合 is 的底层数组中查找值 value 所在的索引。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 成功找到 value 时，函数返回 1 ，并将 *pos 的值设为 value 所在的索引。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当在数组中没找到 value 时，返回 0 。</span><br><span class="hljs-comment"> * 并将 *pos 的值设为 value 可以插入到数组中的位置。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(log N)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">intsetSearch</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint32_t</span> *pos)</span> &#123;<br>    <span class="hljs-type">int</span> min = <span class="hljs-number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="hljs-number">-1</span>, mid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int64_t</span> cur = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">/* The value can never be found when the set is empty */</span><br>    <span class="hljs-comment">// 处理 is 为空时的情况</span><br>    <span class="hljs-keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 因为底层数组是有序的，如果 value 比数组中最后一个值都要大</span><br>        <span class="hljs-comment">// 那么 value 肯定不存在于集合中，</span><br>        <span class="hljs-comment">// 并且应该将 value 添加到底层数组的最末端</span><br>        <span class="hljs-keyword">if</span> (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)<span class="hljs-number">-1</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 因为底层数组是有序的，如果 value 比数组中最前一个值都要小</span><br>        <span class="hljs-comment">// 那么 value 肯定不存在于集合中，</span><br>        <span class="hljs-comment">// 并且应该将它添加到底层数组的最前端</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; _intsetGet(is,<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 在有序数组中进行二分查找</span><br>    <span class="hljs-comment">// T = O(log N)</span><br>    <span class="hljs-keyword">while</span>(max &gt;= min) &#123;<br>        mid = (min+max)/<span class="hljs-number">2</span>;<br>        cur = _intsetGet(is,mid);<br>        <span class="hljs-keyword">if</span> (value &gt; cur) &#123;<br>            min = mid+<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; cur) &#123;<br>            max = mid<span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否已经找到了 value</span><br>    <span class="hljs-keyword">if</span> (value == cur) &#123;<br>        <span class="hljs-keyword">if</span> (pos) *pos = mid;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (pos) *pos = min;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Upgrades the intset to a larger encoding and inserts the given integer. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 根据值 value 所使用的编码方式，对整数集合的编码进行升级，</span><br><span class="hljs-comment"> * 并将值 value 添加到升级后的整数集合中。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 返回值：添加新元素之后的整数集合</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(N)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> intset *<span class="hljs-title function_">intsetUpgradeAndAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value)</span> &#123;<br>    <br>    <span class="hljs-comment">// 当前的编码方式</span><br>    <span class="hljs-type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);<br><br>    <span class="hljs-comment">// 新值所需的编码方式</span><br>    <span class="hljs-type">uint8_t</span> newenc = _intsetValueEncoding(value);<br><br>    <span class="hljs-comment">// 当前集合的元素数量</span><br>    <span class="hljs-type">int</span> length = intrev32ifbe(is-&gt;length);<br><br>    <span class="hljs-comment">// 根据 value 的值，决定是将它添加到底层数组的最前端还是最后端</span><br>    <span class="hljs-comment">// 注意，因为 value 的编码比集合原有的其他元素的编码都要大</span><br>    <span class="hljs-comment">// 所以 value 要么大于集合中的所有元素，要么小于集合中的所有元素</span><br>    <span class="hljs-comment">// 因此，value 只能添加到底层数组的最前端或最后端</span><br>    <span class="hljs-type">int</span> prepend = value &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* First set new encoding and resize */</span><br>    <span class="hljs-comment">// 更新集合的编码方式</span><br>    is-&gt;encoding = intrev32ifbe(newenc);<br>    <span class="hljs-comment">// 根据新编码对集合（的底层数组）进行空间调整</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 根据集合原来的编码方式，从底层数组中取出集合元素</span><br>    <span class="hljs-comment">// 然后再将元素以新编码的方式添加到集合中</span><br>    <span class="hljs-comment">// 当完成了这个步骤之后，集合中所有原有的元素就完成了从旧编码到新编码的转换</span><br>    <span class="hljs-comment">// 因为新分配的空间都放在数组的后端，所以程序先从后端向前端移动元素</span><br>    <span class="hljs-comment">// 举个例子，假设原来有 curenc 编码的三个元素，它们在数组中排列如下：</span><br>    <span class="hljs-comment">// | x | y | z | </span><br>    <span class="hljs-comment">// 当程序对数组进行重分配之后，数组就被扩容了（符号 ？ 表示未使用的内存）：</span><br>    <span class="hljs-comment">// | x | y | z | ? |   ?   |   ?   |</span><br>    <span class="hljs-comment">// 这时程序从数组后端开始，重新插入元素：</span><br>    <span class="hljs-comment">// | x | y | z | ? |   z   |   ?   |</span><br>    <span class="hljs-comment">// | x | y |   y   |   z   |   ?   |</span><br>    <span class="hljs-comment">// |   x   |   y   |   z   |   ?   |</span><br>    <span class="hljs-comment">// 最后，程序可以将新元素添加到最后 ？ 号标示的位置中：</span><br>    <span class="hljs-comment">// |   x   |   y   |   z   |  new  |</span><br>    <span class="hljs-comment">// 上面演示的是新元素比原来的所有元素都大的情况，也即是 prepend == 0</span><br>    <span class="hljs-comment">// 当新元素比原来的所有元素都小时（prepend == 1），调整的过程如下：</span><br>    <span class="hljs-comment">// | x | y | z | ? |   ?   |   ?   |</span><br>    <span class="hljs-comment">// | x | y | z | ? |   ?   |   z   |</span><br>    <span class="hljs-comment">// | x | y | z | ? |   y   |   z   |</span><br>    <span class="hljs-comment">// | x | y |   x   |   y   |   z   |</span><br>    <span class="hljs-comment">// 当添加新值时，原本的 | x | y | 的数据将被新值代替</span><br>    <span class="hljs-comment">// |  new  |   x   |   y   |   z   |</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    <span class="hljs-keyword">while</span>(length--)<br>        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));<br><br>    <span class="hljs-comment">/* Set the value at the beginning or the end. */</span><br>    <span class="hljs-comment">// 设置新值，根据 prepend 的值来决定是添加到数组头还是数组尾</span><br>    <span class="hljs-keyword">if</span> (prepend)<br>        _intsetSet(is,<span class="hljs-number">0</span>,value);<br>    <span class="hljs-keyword">else</span><br>        _intsetSet(is,intrev32ifbe(is-&gt;length),value);<br><br>    <span class="hljs-comment">// 更新整数集合的元素数量</span><br>    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现-跳跃表</title>
    <link href="/2021/09/10/Redis%E5%AE%9E%E7%8E%B0-%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <url>/2021/09/10/Redis%E5%AE%9E%E7%8E%B0-%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Redis实现-跳跃表"><a href="#Redis实现-跳跃表" class="headerlink" title="Redis实现-跳跃表"></a>Redis实现-跳跃表</h2><h3 id="一、什么是跳跃表"><a href="#一、什么是跳跃表" class="headerlink" title="一、什么是跳跃表"></a>一、什么是跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持<code>平均O(logN)、最坏O(N)复杂度</code>。</p><p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要更简单。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910001855.png" alt="跳跃表实例"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 一个跳跃表应该有若干个层（Level）链表组成<br><span class="hljs-bullet">2.</span> 跳跃表中最底层的链表包含所有数据； 每一层链表中的数据都是有序的<br><span class="hljs-bullet">3.</span> 如果一个元素 X 出现在第i层，那么编号比 i 小的层都包含元素 X<br><span class="hljs-bullet">4.</span> 第 i 层的元素通过一个指针指向下一层拥有相同值的元素<br><span class="hljs-bullet">5.</span> 头指针（head）指向最高一层的第一个元素<br></code></pre></td></tr></table></figure><h3 id="二、跳跃表在Redis中的使用"><a href="#二、跳跃表在Redis中的使用" class="headerlink" title="二、跳跃表在Redis中的使用"></a>二、跳跃表在Redis中的使用</h3><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，或者有序集合中的元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">127.0.0.1:6379&gt; ZADD runoobket 1 redis<br>(integer) 1<br>127.0.0.1:6379&gt; ZADD runoobket 2 mongodb<br>(integer) 1<br>127.0.0.1:6379&gt; ZADD runoobket 3 mysql<br>(integer) 1<br>127.0.0.1:6379&gt; ZADD runoobket 4 mysql<br>(integer) 0<br></code></pre></td></tr></table></figure><h3 id="三、跳跃表的实现"><a href="#三、跳跃表的实现" class="headerlink" title="三、跳跃表的实现"></a>三、跳跃表的实现</h3><p>在Redis中，跳跃表有两个结构来实现。<code>zskiplistNode和zskiplist</code>。</p><p><code>zskiplist</code>结构用于保存跳跃表节点的相关信息。</p><p><code>zskiplistNode</code>用于表示跳跃表的节点。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910023219.png" alt="跳跃表节点"></p><h4 id="1、跳跃表节点"><a href="#1、跳跃表节点" class="headerlink" title="1、跳跃表节点"></a>1、跳跃表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br><br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-type">double</span> score;<br><br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br>    &#125; level[];<br><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910024002.png" alt="节点"></p><ul><li><p>层</p><p>节点中的层是一个level[]数组。包含一个指向其他节点的指针。</p><p>上图中展示了节点分别为1层和3层。</p></li><li><p>前进指针</p><p>每一层都有一个指向表尾的前进指针<code>(level[n].forward属性)</code>，用于从表头向表尾方法访问节点，<strong>实际就是这个前进指针就是遍历跳跃表的所有节点的路径。</strong></p></li><li><p>跨度</p><p>层的跨度<code>(level[n].span属性)</code>用于记录两个节点之间的距离。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 两个节点之间的跨度越大，它们相距就越远<br><span class="hljs-bullet">2.</span> 前进指针是NULL时，跨度为0，因为它们没有连向任何节点<br></code></pre></td></tr></table></figure><p>跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表的排位。</p></li><li><p>后退指针</p><p>节点中的后退指针<code>(backword属性)</code>用于从表尾向表头方向访问节点。</p><p>每个节点有多层，就有多个前进指针。但一个节点只有后退指针，而且每次只能后退到当前节点的前一个结点。</p></li><li><p>分值</p><p>节点的分值<code>(score属性)</code>是一个<strong>double</strong>类型的浮点数，跳跃表中的所有结点都按分值来排序。</p></li><li><p>成员</p><p>节点的成员<code>(obj属性)</code>是一个指针，指向一个字符串对象，这个字符串对象保存一个SDS值。</p><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的。但是节点的分值可以是相同的。</p><p>如果分值相同，那么节点将按照成员对象在字典序中的大小来进行排序。</p></li></ul><h4 id="2、跳跃表"><a href="#2、跳跃表" class="headerlink" title="2、跳跃表"></a>2、跳跃表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 跳跃表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br><br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br><br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br><br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> level;<br><br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p>多个跳跃表节点通过前进指针和后退指针进行连接。</p><p>我们通过<code>zskiplist</code>结构来持有这些节点。</p><p>header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个节点，程序可以快速定位表头节点和表尾节点，时间复杂度为<code>o(1)</code>。</p><p>length属性来记录节点的数量，表头结点不计算在内。</p><p>level属性，记录最大的层数。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210910140959.png" alt="redis中的跳跃表"></p><h3 id="四、源码"><a href="#四、源码" class="headerlink" title="四、源码"></a>四、源码</h3><h4 id="创建一个层数为-level-的跳跃表节点"><a href="#创建一个层数为-level-的跳跃表节点" class="headerlink" title="创建一个层数为 level 的跳跃表节点"></a>创建一个层数为 level 的跳跃表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建一个层数为 level 的跳跃表节点，</span><br><span class="hljs-comment"> * 并将节点的成员对象设置为 obj ，分值设置为 score 。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 返回值为新创建的跳跃表节点</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br>zskiplistNode *<span class="hljs-title function_">zslCreateNode</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">double</span> score, robj *obj)</span> &#123;<br>    <br>    <span class="hljs-comment">// 分配空间</span><br>    zskiplistNode *zn = zmalloc(<span class="hljs-keyword">sizeof</span>(*zn)+level*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> zskiplistLevel));<br><br>    <span class="hljs-comment">// 设置属性</span><br>    zn-&gt;score = score;<br>    zn-&gt;obj = obj;<br><br>    <span class="hljs-keyword">return</span> zn;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建并返回一个新的跳跃表"><a href="#创建并返回一个新的跳跃表" class="headerlink" title="创建并返回一个新的跳跃表"></a>创建并返回一个新的跳跃表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建并返回一个新的跳跃表</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br>zskiplist *<span class="hljs-title function_">zslCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> j;<br>    zskiplist *zsl;<br><br>    <span class="hljs-comment">// 分配空间</span><br>    zsl = zmalloc(<span class="hljs-keyword">sizeof</span>(*zsl));<br><br>    <span class="hljs-comment">// 设置高度和起始层数</span><br>    zsl-&gt;level = <span class="hljs-number">1</span>;<br>    zsl-&gt;length = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始化表头节点</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;<br>        zsl-&gt;header-&gt;level[j].forward = <span class="hljs-literal">NULL</span>;<br>        zsl-&gt;header-&gt;level[j].span = <span class="hljs-number">0</span>;<br>    &#125;<br>    zsl-&gt;header-&gt;backward = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 设置表尾</span><br>    zsl-&gt;tail = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> zsl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将新节点插入到跳跃表"><a href="#将新节点插入到跳跃表" class="headerlink" title="将新节点插入到跳跃表"></a>将新节点插入到跳跃表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建一个成员为 obj ，分值为 score 的新节点，</span><br><span class="hljs-comment"> * 并将这个新节点插入到跳跃表 zsl 中。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 函数的返回值为新节点。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T_wrost = O(N^2), T_avg = O(N log N)</span><br><span class="hljs-comment"> */</span><br>zskiplistNode *<span class="hljs-title function_">zslInsert</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, robj *obj)</span> &#123;<br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rank[ZSKIPLIST_MAXLEVEL];<br>    <span class="hljs-type">int</span> i, level;<br><br>    redisAssert(!isnan(score));<br><br>    <span class="hljs-comment">// 在各个层查找节点的插入位置</span><br>    <span class="hljs-comment">// T_wrost = O(N^2), T_avg = O(N log N)</span><br>    x = zsl-&gt;header;<br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><br>        <span class="hljs-comment">/* store rank that is crossed to reach the insert position */</span><br>        <span class="hljs-comment">// 如果 i 不是 zsl-&gt;level-1 层</span><br>        <span class="hljs-comment">// 那么 i 层的起始 rank 值为 i+1 层的 rank 值</span><br>        <span class="hljs-comment">// 各个层的 rank 值一层层累积</span><br>        <span class="hljs-comment">// 最终 rank[0] 的值加一就是新节点的前置节点的排位</span><br>        <span class="hljs-comment">// rank[0] 会在后面成为计算 span 值和 rank 值的基础</span><br>        rank[i] = i == (zsl-&gt;level<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : rank[i+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 沿着前进指针遍历跳跃表</span><br>        <span class="hljs-comment">// T_wrost = O(N^2), T_avg = O(N log N)</span><br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;<br>            (x-&gt;level[i].forward-&gt;score &lt; score ||<br>                <span class="hljs-comment">// 比对分值</span><br>                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;<br>                <span class="hljs-comment">// 比对成员， T = O(N)</span><br>                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="hljs-number">0</span>))) &#123;<br><br>            <span class="hljs-comment">// 记录沿途跨越了多少个节点</span><br>            rank[i] += x-&gt;level[i].span;<br><br>            <span class="hljs-comment">// 移动至下一指针</span><br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        <span class="hljs-comment">// 记录将要和新节点相连接的节点</span><br>        update[i] = x;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</span><br><span class="hljs-comment">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// 获取一个随机值作为新节点的层数</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    level = zslRandomLevel();<br><br>    <span class="hljs-comment">// 如果新节点的层数比表中其他节点的层数都要大</span><br>    <span class="hljs-comment">// 那么初始化表头节点中未使用的层，并将它们记录到 update 数组中</span><br>    <span class="hljs-comment">// 将来也指向新节点</span><br>    <span class="hljs-keyword">if</span> (level &gt; zsl-&gt;level) &#123;<br><br>        <span class="hljs-comment">// 初始化未使用层</span><br>        <span class="hljs-comment">// T = O(1)</span><br>        <span class="hljs-keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;<br>            rank[i] = <span class="hljs-number">0</span>;<br>            update[i] = zsl-&gt;header;<br>            update[i]-&gt;level[i].span = zsl-&gt;length;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新表中节点最大层数</span><br>        zsl-&gt;level = level;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建新节点</span><br>    x = zslCreateNode(level,score,obj);<br><br>    <span class="hljs-comment">// 将前面记录的指针指向新节点，并做相应的设置</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>        <br>        <span class="hljs-comment">// 设置新节点的 forward 指针</span><br>        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;<br>        <br>        <span class="hljs-comment">// 将沿途记录的各个节点的 forward 指针指向新节点</span><br>        update[i]-&gt;level[i].forward = x;<br><br>        <span class="hljs-comment">/* update span covered by update[i] as x is inserted here */</span><br>        <span class="hljs-comment">// 计算新节点跨越的节点数量</span><br>        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="hljs-number">0</span>] - rank[i]);<br><br>        <span class="hljs-comment">// 更新新节点插入之后，沿途节点的 span 值</span><br>        <span class="hljs-comment">// 其中的 +1 计算的是新节点</span><br>        update[i]-&gt;level[i].span = (rank[<span class="hljs-number">0</span>] - rank[i]) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* increment span for untouched levels */</span><br>    <span class="hljs-comment">// 未接触的节点的 span 值也需要增一，这些节点直接从表头指向新节点</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;<br>        update[i]-&gt;level[i].span++;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置新节点的后退指针</span><br>    x-&gt;backward = (update[<span class="hljs-number">0</span>] == zsl-&gt;header) ? <span class="hljs-literal">NULL</span> : update[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward)<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x;<br>    <span class="hljs-keyword">else</span><br>        zsl-&gt;tail = x;<br><br>    <span class="hljs-comment">// 跳跃表的节点计数增一</span><br>    zsl-&gt;length++;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从跳跃表删除给定节点"><a href="#从跳跃表删除给定节点" class="headerlink" title="从跳跃表删除给定节点"></a>从跳跃表删除给定节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 从跳跃表 zsl 中删除包含给定节点 score 并且带有指定对象 obj 的节点。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T_wrost = O(N^2), T_avg = O(N log N)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">zslDelete</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, robj *obj)</span> &#123;<br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// 遍历跳跃表，查找目标节点，并记录所有沿途节点</span><br>    <span class="hljs-comment">// T_wrost = O(N^2), T_avg = O(N log N)</span><br>    x = zsl-&gt;header;<br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><br>        <span class="hljs-comment">// 遍历跳跃表的复杂度为 T_wrost = O(N), T_avg = O(log N)</span><br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;<br>            (x-&gt;level[i].forward-&gt;score &lt; score ||<br>                <span class="hljs-comment">// 比对分值</span><br>                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;<br>                <span class="hljs-comment">// 比对对象，T = O(N)</span><br>                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="hljs-number">0</span>)))<br><br>            <span class="hljs-comment">// 沿着前进指针移动</span><br>            x = x-&gt;level[i].forward;<br><br>        <span class="hljs-comment">// 记录沿途节点</span><br>        update[i] = x;<br>    &#125;<br><br>    <span class="hljs-comment">/* We may have multiple elements with the same score, what we need</span><br><span class="hljs-comment">     * is to find the element with both the right score and object. </span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 检查找到的元素 x ，只有在它的分值和对象都相同时，才将它删除。</span><br><span class="hljs-comment">     */</span><br>    x = x-&gt;level[<span class="hljs-number">0</span>].forward;<br>    <span class="hljs-keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;<br>        <span class="hljs-comment">// T = O(1)</span><br>        zslDeleteNode(zsl, x, update);<br>        <span class="hljs-comment">// T = O(1)</span><br>        zslFreeNode(x);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not found */</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not found */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="释放给定跳跃表，以及表中的所有节点"><a href="#释放给定跳跃表，以及表中的所有节点" class="headerlink" title="释放给定跳跃表，以及表中的所有节点"></a>释放给定跳跃表，以及表中的所有节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 释放给定跳跃表，以及表中的所有节点</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(N)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">zslFree</span><span class="hljs-params">(zskiplist *zsl)</span> &#123;<br>    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="hljs-number">0</span>].forward, *next;<br>    <span class="hljs-comment">// 释放表头</span><br>    zfree(zsl-&gt;header);<br>    <span class="hljs-comment">// 释放表中所有节点</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    <span class="hljs-keyword">while</span>(node) &#123;<br>        next = node-&gt;level[<span class="hljs-number">0</span>].forward;<br>        zslFreeNode(node);<br>        node = next;<br>    &#125;<br>    <span class="hljs-comment">// 释放跳跃表结构</span><br>    zfree(zsl);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现-字典</title>
    <link href="/2021/09/09/Redis%E5%AE%9E%E7%8E%B0-%E5%AD%97%E5%85%B8/"/>
    <url>/2021/09/09/Redis%E5%AE%9E%E7%8E%B0-%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Redis实现-字典"><a href="#Redis实现-字典" class="headerlink" title="Redis实现 - 字典"></a>Redis实现 - 字典</h2><h3 id="一、字典在Redis的使用"><a href="#一、字典在Redis的使用" class="headerlink" title="一、字典在Redis的使用"></a>一、字典在Redis的使用</h3><h4 id="1-字典简述"><a href="#1-字典简述" class="headerlink" title="1.字典简述"></a>1.字典简述</h4><p>字典又称为映射 – map，是一种用于保存键值对<code>（K - V）</code>的抽象数据结构。</p><p>在map中，一个键(K)对应一个值(V)，这对关联的键和值称为键值对。</p><p>字典中的键都是唯一的。因此，我们可以通过键来改变值，或者删除整个键值对。</p><h4 id="2-在Redis中的使用"><a href="#2-在Redis中的使用" class="headerlink" title="2.在Redis中的使用"></a>2.在Redis中的使用</h4><p>字典在Redis中的应用非常广泛，比如，Redis的数据库就是使用字典来作为底层实现的。</p><p>数据库的增删改查操作也是构建在对字典之上的。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set name jiang<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; get name<br><span class="hljs-string">&quot;jiang&quot;</span><br></code></pre></td></tr></table></figure><p>字典也是哈希键的底层实现。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hset person name jiang<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hset person age <span class="hljs-number">20</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; keys person<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;person&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hget person age<br><span class="hljs-string">&quot;20&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; hdel person age<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; type person<br>hash<br></code></pre></td></tr></table></figure><h3 id="二、字典的实现"><a href="#二、字典的实现" class="headerlink" title="二、字典的实现"></a>二、字典的实现</h3><p>Redis的字典使用哈希表作为底层实现，一个哈希表有多个哈希表节点，一个节点对应一个键值对。</p><h4 id="1、字典"><a href="#1、字典" class="headerlink" title="1、字典"></a>1、字典</h4><p>字典的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 字典</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br><br>    <span class="hljs-comment">// 类型特定函数</span><br>    dictType *type;<br><br>    <span class="hljs-comment">// 私有数据</span><br>    <span class="hljs-type">void</span> *privdata;<br><br>    <span class="hljs-comment">// 哈希表</span><br>    dictht ht[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// rehash 索引</span><br>    <span class="hljs-comment">// 当 rehash 不在进行时，值为 -1</span><br>    <span class="hljs-type">int</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>Type和private是针对不同类型的键值对，为创建<code>多态字典</code>而设置的。ht是一个哈希表数组，字典只使用ht[0]，ht[1]哈希表只会在rehash时使用。rehashidx记录了rehash的进度，如果目前没有在进行rehash，那么它的值为-1。</p><ul><li><p>Type</p><p>这是一个指向<code>dictType</code>结构的指针，每个<code>dictType</code>结构保存了一簇用于操作特定类型键值对的函数。</p><p>Redis会为用途不同的字典设置不同的类型特定函数。</p></li><li><p>private</p><p>保存了需要传给那些类型特定函数的可选函数。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 字典类型特定函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span><br><br>    <span class="hljs-comment">// 计算哈希值的函数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*hashFunction)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span>;<br><br>    <span class="hljs-comment">// 复制键的函数</span><br>    <span class="hljs-type">void</span> *(*keyDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);<br><br>    <span class="hljs-comment">// 复制值的函数</span><br>    <span class="hljs-type">void</span> *(*valDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *obj);<br><br>    <span class="hljs-comment">// 对比键的函数</span><br>    <span class="hljs-type">int</span> (*keyCompare)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);<br><br>    <span class="hljs-comment">// 销毁键的函数</span><br>    <span class="hljs-type">void</span> (*keyDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *key);<br>    <br>    <span class="hljs-comment">// 销毁值的函数</span><br>    <span class="hljs-type">void</span> (*valDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *obj);<br><br>&#125; dictType;<br></code></pre></td></tr></table></figure><h4 id="2、哈希表节点"><a href="#2、哈希表节点" class="headerlink" title="2、哈希表节点"></a>2、哈希表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 哈希表节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <br>    <span class="hljs-comment">// 键</span><br>    <span class="hljs-type">void</span> *key;<br><br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>    &#125; v;<br><br>    <span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>每个<code>dictEntry</code>结构都保存着一个键值对。</p><p>Key和V属性分别是一个键值对的键和值。键是一个指针，而值既可以是一个指针，也可以是<code>uint64_t</code>或<code>int64_t</code>的整数。</p><p>next是指向另一个哈希表节点的指针，解决键冲突的问题。</p><h4 id="3、哈希表"><a href="#3、哈希表" class="headerlink" title="3、哈希表"></a>3、哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br><br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <br>    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-comment">// 总是等于 size - 1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br><br>    <span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br><br>&#125; dictht;<br></code></pre></td></tr></table></figure><p><code>table</code>是一个数组，数组中的每个元素都是一个指向dictEntry的指针。</p><p><code>size</code>记录了哈希表的大小，即table数组的大小</p><p><code>used</code>属性则记录了哈希表目前已有的节点的数量</p><p><code>sizemask</code>属性的值总是等于<code>size - 1</code>，这个属性和哈希值一起决定一个键应该被放到table数组的具体位置上。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210909155825.png" alt="字典结构"></p><h3 id="三、哈希算法"><a href="#三、哈希算法" class="headerlink" title="三、哈希算法"></a>三、哈希算法</h3><p>哈希算法是根据键值对的键计算出哈希数组索引值。</p><p>将一个键值对添加到字典中，先根据键计算出哈希值和索引值，然后将键值对放到指定的索引中。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Redis计算哈希值和索引值的方法：</span><br><br><span class="hljs-bullet">1.</span> 使用字典设置的哈希函数，计算key的哈希值<br>hash = dict-&gt;type-&gt;hashFunction(key)<br><br><span class="hljs-bullet">2.</span> 使用哈希表的sizemask属性和哈希值，计算出索引值<br>根据情况不同，ht[x]可以是ht[0]或者ht[1]<br>index = hash &amp; dict-&gt;ht[x].sizemask;<br></code></pre></td></tr></table></figure><h3 id="四、解决键冲突"><a href="#四、解决键冲突" class="headerlink" title="四、解决键冲突"></a>四、解决键冲突</h3><p>键冲突：当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面。</p><p>解决：使用链地址法，使用next指针将冲突的键连接起来。</p><p>具体细节：<code>头插法</code>，将新的节点添加到链表的表头位置。</p><h3 id="五、rehash"><a href="#五、rehash" class="headerlink" title="五、rehash"></a>五、rehash</h3><h4 id="1、rehash"><a href="#1、rehash" class="headerlink" title="1、rehash"></a>1、rehash</h4><p>随着添加节点的操作不断执行，存储的键值对不断增加。</p><p>我们知道，从链表中查询一个节点的时间复杂度时<code>o(1)</code>，键值对不断增加，那么一个链表中的节点就越多，时间消耗就越多。</p><p>因此，我们会将哈希表的长度扩大，将一个链表的结点重新散列在各个数组结点中。</p><p>扩展和收缩哈希表数组的工作可以通过执行<code>rehash(重新散列)</code>操作来完成。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># rehash的步骤</span><br><span class="hljs-bullet">1.</span> 为ht[1]哈希表分配空间<br><span class="hljs-code">    如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].usedX2 的2的n次幂</span><br><span class="hljs-code">    比如：此时h[0].used=4,4X2=8,而8正好是2的3次幂。因此ht[1]的大小设置为8</span><br><span class="hljs-code">    如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次幂</span><br><span class="hljs-code">    比如：此时h[0].used=3,那么ht[1]=4</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">2.</span> 将保存在ht[0]中的所有键值对rehash到ht[1]上面<br><span class="hljs-code">rehash指的就是重新计算键的哈希值和索引值。</span><br><span class="hljs-code">3. 当ht[0]中的所有键值对都迁移到ht[1]之后</span><br><span class="hljs-code">ht[0]会变成空表，此时将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表</span><br></code></pre></td></tr></table></figure><h4 id="2、哈希表的扩展和收缩："><a href="#2、哈希表的扩展和收缩：" class="headerlink" title="2、哈希表的扩展和收缩："></a>2、哈希表的扩展和收缩：</h4><p>扩展和收缩都需要一个指标：负载因子。</p><p>哈希表的负载因此的计算方式：</p><p><code>load_factor(负载因子) = ht[0].used / ht[0].size</code></p><ul><li><p>扩展时机</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 以下条件满足任意一个即可扩展：</span><br><span class="hljs-bullet">1.</span> redis服务器目前没有执行BGSAVE或者BGREWRITEAOF命令,且负载因子大于等于1<br><span class="hljs-bullet">2.</span> redis服务器正在执行BGSAVE或者BGREWRITEAOF命令，且负载因子大于等于5<br></code></pre></td></tr></table></figure><p>根据<code>BGSAVE和BGREWRITEAOF命令</code>是否执行，负载因子并不相同。</p><blockquote><p>这是因为在执行这个命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制(copy-on-write)技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，尽可能避免在子进程存在期间进行哈希扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p></blockquote></li><li><p>收缩</p><p>负载因子小于<strong>0.1</strong>时，程序自动开始对哈希表执行收缩操作。</p></li></ul><h4 id="3、渐进式rehash"><a href="#3、渐进式rehash" class="headerlink" title="3、渐进式rehash"></a>3、渐进式rehash</h4><p>rehash的操作并不是一次性、集中式的完成的，而是多次、渐进式地完成的。</p><p>因为如果redis中的键值对太多，一次性的完成rehash可能会造成长时间系统的停滞。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># rehash的详细步骤</span><br><span class="hljs-bullet">1.</span> 为ht[1]分配空间<br><span class="hljs-bullet">2.</span> 字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作开始<br><span class="hljs-bullet">3.</span> 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时程序除了执行这些操作，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]<br><span class="hljs-bullet">4.</span> ht[0]中的键值对全部rehash至ht[1]之后，将rehashidx属性设为-1<br></code></pre></td></tr></table></figure><p>渐进式rehash的好处：</p><p>将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上。</p><p>避免了集中式rehash而带来的庞大计算量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行 N 步渐进式 rehash</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">*  返回 1 表示仍有键需要从 0 号哈希表移动到 1 号哈希表，</span><br><span class="hljs-comment">*  返回 0 则表示所有键都已经迁移完毕。</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*  注意，每步 rehash 都是以一个哈希表索引（桶）作为单位的，</span><br><span class="hljs-comment">*  一个桶里可能会有多个节点，</span><br><span class="hljs-comment">*  被 rehash 的桶里的所有节点都会被移动到新哈希表。</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dictRehash</span><span class="hljs-params">(dict *d, <span class="hljs-type">int</span> n)</span> &#123;<br><br>    <span class="hljs-comment">// 只可以在 rehash 进行中时执行</span><br>    <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 进行 N 步迁移</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        dictEntry *de, *nextde;<br><br>        <span class="hljs-comment">/* Check if we already rehashed the whole table... */</span><br>        <span class="hljs-comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span><br>        <span class="hljs-comment">// T = O(1)</span><br>        <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 释放 0 号哈希表</span><br>            zfree(d-&gt;ht[<span class="hljs-number">0</span>].table);<br>            <span class="hljs-comment">// 将原来的 1 号哈希表设置为新的 0 号哈希表</span><br>            d-&gt;ht[<span class="hljs-number">0</span>] = d-&gt;ht[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 重置旧的 1 号哈希表</span><br>            _dictReset(&amp;d-&gt;ht[<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// 关闭 rehash 标识</span><br>            d-&gt;rehashidx = <span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">// 返回 0 ，向调用者表示 rehash 已经完成</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span><br><span class="hljs-comment">         * elements because ht[0].used != 0 */</span><br>        <span class="hljs-comment">// 确保 rehashidx 没有越界</span><br>        assert(d-&gt;ht[<span class="hljs-number">0</span>].size &gt; (<span class="hljs-type">unsigned</span>)d-&gt;rehashidx);<br><br>        <span class="hljs-comment">// 略过数组中为空的索引，找到下一个非空索引</span><br>        <span class="hljs-keyword">while</span>(d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] == <span class="hljs-literal">NULL</span>) d-&gt;rehashidx++;<br><br>        <span class="hljs-comment">// 指向该索引的链表表头节点</span><br>        de = d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx];<br>        <span class="hljs-comment">/* Move all the keys in this bucket from the old to the new hash HT */</span><br>        <span class="hljs-comment">// 将链表中的所有节点迁移到新哈希表</span><br>        <span class="hljs-comment">// T = O(1)</span><br>        <span class="hljs-keyword">while</span>(de) &#123;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h;<br><br>            <span class="hljs-comment">// 保存下个节点的指针</span><br>            nextde = de-&gt;next;<br><br>            <span class="hljs-comment">/* Get the index in the new hash table */</span><br>            <span class="hljs-comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span><br>            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="hljs-number">1</span>].sizemask;<br><br>            <span class="hljs-comment">// 插入节点到新哈希表</span><br>            de-&gt;next = d-&gt;ht[<span class="hljs-number">1</span>].table[h];<br>            d-&gt;ht[<span class="hljs-number">1</span>].table[h] = de;<br><br>            <span class="hljs-comment">// 更新计数器</span><br>            d-&gt;ht[<span class="hljs-number">0</span>].used--;<br>            d-&gt;ht[<span class="hljs-number">1</span>].used++;<br><br>            <span class="hljs-comment">// 继续处理下个节点</span><br>            de = nextde;<br>        &#125;<br>        <span class="hljs-comment">// 将刚迁移完的哈希表索引的指针设为空</span><br>        d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 更新 rehash 索引</span><br>        d-&gt;rehashidx++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、rehash执行期间的哈希表操作"><a href="#4、rehash执行期间的哈希表操作" class="headerlink" title="4、rehash执行期间的哈希表操作"></a>4、rehash执行期间的哈希表操作</h4><p>在rehash执行期间，字典会同时使用ht[0]和ht[1]两个哈希表。</p><p>因此，在rehash执行期间，字典的删除、查找、更新等操作会在两个哈希表上进行。</p><p>比如：如果执行查找操作，会先在ht[0]中查找，然后在ht[1]中查找。保存操作在ht[1]中执行。</p><h3 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h3><p><code>dict.c和dict.h</code></p><h4 id="rehash相关的属性"><a href="#rehash相关的属性" class="headerlink" title="rehash相关的属性"></a>rehash相关的属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 指示字典是否启用 rehash 的标识</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> dict_can_resize = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 强制 rehash 的比率</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dict_force_resize_ratio = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h4 id="重置（或初始化）给定哈希表的各项属性值"><a href="#重置（或初始化）给定哈希表的各项属性值" class="headerlink" title="重置（或初始化）给定哈希表的各项属性值"></a>重置（或初始化）给定哈希表的各项属性值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> _dictReset(dictht *ht)<br>&#123;<br>    ht-&gt;table = <span class="hljs-literal">NULL</span>;<br>    ht-&gt;size = <span class="hljs-number">0</span>;<br>    ht-&gt;sizemask = <span class="hljs-number">0</span>;<br>    ht-&gt;used = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化哈希表"><a href="#初始化哈希表" class="headerlink" title="初始化哈希表"></a>初始化哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> _dictInit(dict *d, dictType *type,<span class="hljs-type">void</span> *privDataPtr)<br>&#123;<br>    <span class="hljs-comment">// 初始化两个哈希表的各项属性值</span><br>    <span class="hljs-comment">// 但暂时还不分配内存给哈希表数组</span><br>    _dictReset(&amp;d-&gt;ht[<span class="hljs-number">0</span>]);<br>    _dictReset(&amp;d-&gt;ht[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 设置类型特定函数</span><br>    d-&gt;type = type;<br>    <span class="hljs-comment">// 设置私有数据</span><br>    d-&gt;privdata = privDataPtr;<br>    <span class="hljs-comment">// 设置哈希表 rehash 状态</span><br>    d-&gt;rehashidx = <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 设置字典的安全迭代器数量</span><br>    d-&gt;iterators = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> DICT_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建一个新的字典"><a href="#创建一个新的字典" class="headerlink" title="创建一个新的字典"></a>创建一个新的字典</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">dict *<span class="hljs-title function_">dictCreate</span><span class="hljs-params">(dictType *type,<span class="hljs-type">void</span> *privDataPtr)</span><br>&#123;<br>    dict *d = zmalloc(<span class="hljs-keyword">sizeof</span>(*d));<br>    _dictInit(d,type,privDataPtr);<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将键插入到字典"><a href="#将键插入到字典" class="headerlink" title="将键插入到字典"></a>将键插入到字典</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 尝试将键插入到字典中</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 如果键已经在字典存在，那么返回 NULL</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 如果键不存在，那么程序创建新的哈希节点，</span><br><span class="hljs-comment">* 将节点和键关联，并插入到字典，然后返回节点本身。</span><br><span class="hljs-comment">*/</span><br>dictEntry *<span class="hljs-title function_">dictAddRaw</span><span class="hljs-params">(dict *d, <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    <span class="hljs-type">int</span> index;<br>    dictEntry *entry;<br>    dictht *ht;<br><br>    <span class="hljs-comment">// 如果条件允许的话，进行单步 rehash</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);<br><br>    <span class="hljs-comment">/* Get the index of the new element, or -1 if</span><br><span class="hljs-comment">     * the element already exists. */</span><br>    <span class="hljs-comment">// 计算键在哈希表中的索引值</span><br>    <span class="hljs-comment">// 如果值为 -1 ，那么表示键已经存在</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    <span class="hljs-keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-comment">/* Allocate the memory and store the new entry */</span><br>    <span class="hljs-comment">// 如果字典正在 rehash ，那么将新键添加到 1 号哈希表</span><br>    <span class="hljs-comment">// 否则，将新键添加到 0 号哈希表</span><br>    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="hljs-number">1</span>] : &amp;d-&gt;ht[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 为新节点分配空间</span><br>    entry = zmalloc(<span class="hljs-keyword">sizeof</span>(*entry));<br>    <span class="hljs-comment">// 将新节点插入到链表表头</span><br>    entry-&gt;next = ht-&gt;table[index];<br>    ht-&gt;table[index] = entry;<br>    <span class="hljs-comment">// 更新哈希表已使用节点数量</span><br>    ht-&gt;used++;<br><br>    <span class="hljs-comment">/* Set the hash entry fields. */</span><br>    <span class="hljs-comment">// 设置新节点的键</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    dictSetKey(d, entry, key);<br><br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回字典中包含键-key-的节点"><a href="#返回字典中包含键-key-的节点" class="headerlink" title="返回字典中包含键 key 的节点"></a>返回字典中包含键 key 的节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 返回字典中包含键 key 的节点</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 找到返回节点，找不到返回 NULL</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br>dictEntry *<span class="hljs-title function_">dictFind</span><span class="hljs-params">(dict *d, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    dictEntry *he;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h, idx, table;<br><br>    <span class="hljs-comment">// 字典（的哈希表）为空</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* We don&#x27;t have a table at all */</span><br><br>    <span class="hljs-comment">// 如果条件允许的话，进行单步 rehash</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);<br><br>    <span class="hljs-comment">// 计算键的哈希值</span><br>    h = dictHashKey(d, key);<br>    <span class="hljs-comment">// 在字典的哈希表中查找这个键</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-keyword">for</span> (table = <span class="hljs-number">0</span>; table &lt;= <span class="hljs-number">1</span>; table++) &#123;<br><br>        <span class="hljs-comment">// 计算索引值</span><br>        idx = h &amp; d-&gt;ht[table].sizemask;<br><br>        <span class="hljs-comment">// 遍历给定索引上的链表的所有节点，查找 key</span><br>        he = d-&gt;ht[table].table[idx];<br>        <span class="hljs-comment">// T = O(1)</span><br>        <span class="hljs-keyword">while</span>(he) &#123;<br><br>            <span class="hljs-keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))<br>                <span class="hljs-keyword">return</span> he;<br><br>            he = he-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果程序遍历完 0 号哈希表，仍然没找到指定的键的节点</span><br>        <span class="hljs-comment">// 那么程序会检查字典是否在进行 rehash ，</span><br>        <span class="hljs-comment">// 然后才决定是直接返回 NULL ，还是继续查找 1 号哈希表</span><br>        <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 进行到这里时，说明两个哈希表都没找到</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="随机返回字典中任意一个节点"><a href="#随机返回字典中任意一个节点" class="headerlink" title="随机返回字典中任意一个节点"></a>随机返回字典中任意一个节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 随机返回字典中任意一个节点。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 可用于实现随机化算法。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果字典为空，返回 NULL 。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(N)</span><br><span class="hljs-comment">*/</span><br>dictEntry *<span class="hljs-title function_">dictGetRandomKey</span><span class="hljs-params">(dict *d)</span><br>&#123;<br>    dictEntry *he, *orighe;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h;<br>    <span class="hljs-type">int</span> listlen, listele;<br><br>    <span class="hljs-comment">// 字典为空</span><br>    <span class="hljs-keyword">if</span> (dictSize(d) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 进行单步 rehash</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);<br><br>    <span class="hljs-comment">// 如果正在 rehash ，那么将 1 号哈希表也作为随机查找的目标</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) &#123;<br>        <span class="hljs-comment">// T = O(N)</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            h = random() % (d-&gt;ht[<span class="hljs-number">0</span>].size+d-&gt;ht[<span class="hljs-number">1</span>].size);<br>            he = (h &gt;= d-&gt;ht[<span class="hljs-number">0</span>].size) ? d-&gt;ht[<span class="hljs-number">1</span>].table[h - d-&gt;ht[<span class="hljs-number">0</span>].size] :<br>                                      d-&gt;ht[<span class="hljs-number">0</span>].table[h];<br>        &#125; <span class="hljs-keyword">while</span>(he == <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 否则，只从 0 号哈希表中查找节点</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// T = O(N)</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            h = random() &amp; d-&gt;ht[<span class="hljs-number">0</span>].sizemask;<br>            he = d-&gt;ht[<span class="hljs-number">0</span>].table[h];<br>        &#125; <span class="hljs-keyword">while</span>(he == <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Now we found a non empty bucket, but it is a linked</span><br><span class="hljs-comment">     * list and we need to get a random element from the list.</span><br><span class="hljs-comment">     * The only sane way to do so is counting the elements and</span><br><span class="hljs-comment">     * select a random index. */</span><br>    <span class="hljs-comment">// 目前 he 已经指向一个非空的节点链表</span><br>    <span class="hljs-comment">// 程序将从这个链表随机返回一个节点</span><br>    listlen = <span class="hljs-number">0</span>;<br>    orighe = he;<br>    <span class="hljs-comment">// 计算节点数量, T = O(1)</span><br>    <span class="hljs-keyword">while</span>(he) &#123;<br>        he = he-&gt;next;<br>        listlen++;<br>    &#125;<br>    <span class="hljs-comment">// 取模，得出随机节点的索引</span><br>    listele = random() % listlen;<br>    he = orighe;<br>    <span class="hljs-comment">// 按索引查找节点</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-keyword">while</span>(listele--) he = he-&gt;next;<br><br>    <span class="hljs-comment">// 返回随机节点</span><br>    <span class="hljs-keyword">return</span> he;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="查找并删除包含给定键的节点"><a href="#查找并删除包含给定键的节点" class="headerlink" title="查找并删除包含给定键的节点"></a>查找并删除包含给定键的节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Search and remove an element */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 查找并删除包含给定键的节点</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 参数 nofree 决定是否调用键和值的释放函数</span><br><span class="hljs-comment"> * 0 表示调用，1 表示不调用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 找到并成功删除返回 DICT_OK ，没找到则返回 DICT_ERR</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dictGenericDelete</span><span class="hljs-params">(dict *d, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">int</span> nofree)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h, idx;<br>    dictEntry *he, *prevHe;<br>    <span class="hljs-type">int</span> table;<br><br>    <span class="hljs-comment">// 字典（的哈希表）为空</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> DICT_ERR; <span class="hljs-comment">/* d-&gt;ht[0].table is NULL */</span><br><br>    <span class="hljs-comment">// 进行单步 rehash ，T = O(1)</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);<br><br>    <span class="hljs-comment">// 计算哈希值</span><br>    h = dictHashKey(d, key);<br><br>    <span class="hljs-comment">// 遍历哈希表</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-keyword">for</span> (table = <span class="hljs-number">0</span>; table &lt;= <span class="hljs-number">1</span>; table++) &#123;<br><br>        <span class="hljs-comment">// 计算索引值 </span><br>        idx = h &amp; d-&gt;ht[table].sizemask;<br>        <span class="hljs-comment">// 指向该索引上的链表</span><br>        he = d-&gt;ht[table].table[idx];<br>        prevHe = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 遍历链表上的所有节点</span><br>        <span class="hljs-comment">// T = O(1)</span><br>        <span class="hljs-keyword">while</span>(he) &#123;<br>        <br>            <span class="hljs-keyword">if</span> (dictCompareKeys(d, key, he-&gt;key)) &#123;<br>                <span class="hljs-comment">// 超找目标节点</span><br><br>                <span class="hljs-comment">/* Unlink the element from the list */</span><br>                <span class="hljs-comment">// 从链表中删除</span><br>                <span class="hljs-keyword">if</span> (prevHe)<br>                    prevHe-&gt;next = he-&gt;next;<br>                <span class="hljs-keyword">else</span><br>                    d-&gt;ht[table].table[idx] = he-&gt;next;<br><br>                <span class="hljs-comment">// 释放调用键和值的释放函数？</span><br>                <span class="hljs-keyword">if</span> (!nofree) &#123;<br>                    dictFreeKey(d, he);<br>                    dictFreeVal(d, he);<br>                &#125;<br>                <br>                <span class="hljs-comment">// 释放节点本身</span><br>                zfree(he);<br><br>                <span class="hljs-comment">// 更新已使用节点数量</span><br>                d-&gt;ht[table].used--;<br><br>                <span class="hljs-comment">// 返回已找到信号</span><br>                <span class="hljs-keyword">return</span> DICT_OK;<br>            &#125;<br><br>            prevHe = he;<br>            he = he-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果执行到这里，说明在 0 号哈希表中找不到给定键</span><br>        <span class="hljs-comment">// 那么根据字典是否正在进行 rehash ，决定要不要查找 1 号哈希表</span><br>        <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 没找到</span><br>    <span class="hljs-keyword">return</span> DICT_ERR; <span class="hljs-comment">/* not found */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对字典进行扩展"><a href="#对字典进行扩展" class="headerlink" title="对字典进行扩展"></a>对字典进行扩展</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> _dictExpandIfNeeded(dict *d)<br>&#123;<br>    <span class="hljs-comment">/* Incremental rehashing already in progress. Return. */</span><br>    <span class="hljs-comment">// 渐进式 rehash 已经在进行了，直接返回</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) <span class="hljs-keyword">return</span> DICT_OK;<br><br>    <span class="hljs-comment">/* If the hash table is empty expand it to the initial size. */</span><br>    <span class="hljs-comment">// 如果字典（的 0 号哈希表）为空，那么创建并返回初始化大小的 0 号哈希表</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);<br><br>    <span class="hljs-comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span><br><span class="hljs-comment">     * table (global setting) or we should avoid it but the ratio between</span><br><span class="hljs-comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span><br><span class="hljs-comment">     * the number of buckets. */</span><br>    <span class="hljs-comment">// 一下两个条件之一为真时，对字典进行扩展</span><br>    <span class="hljs-comment">// 1）字典已使用节点数和字典大小之间的比率接近 1：1</span><br>    <span class="hljs-comment">//    并且 dict_can_resize 为真</span><br>    <span class="hljs-comment">// 2）已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used &gt;= d-&gt;ht[<span class="hljs-number">0</span>].size &amp;&amp;<br>        (dict_can_resize ||<br>         d-&gt;ht[<span class="hljs-number">0</span>].used/d-&gt;ht[<span class="hljs-number">0</span>].size &gt; dict_force_resize_ratio))<br>    &#123;<br>        <span class="hljs-comment">// 新哈希表的大小至少是目前已使用节点数的两倍</span><br>        <span class="hljs-comment">// T = O(N)</span><br>        <span class="hljs-keyword">return</span> dictExpand(d, d-&gt;ht[<span class="hljs-number">0</span>].used*<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> DICT_OK;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建一个新的哈希表，并根据字典的情况，选择以下其中一个动作来进行：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1) 如果字典的 0 号哈希表为空，那么将新哈希表设置为 0 号哈希表</span><br><span class="hljs-comment"> * 2) 如果字典的 0 号哈希表非空，那么将新哈希表设置为 1 号哈希表，</span><br><span class="hljs-comment"> *    并打开字典的 rehash 标识，使得程序可以开始对字典进行 rehash</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * size 参数不够大，或者 rehash 已经在进行时，返回 DICT_ERR 。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 成功创建 0 号哈希表，或者 1 号哈希表时，返回 DICT_OK 。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(N)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dictExpand</span><span class="hljs-params">(dict *d, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br>&#123;<br>    <span class="hljs-comment">// 新哈希表</span><br>    dictht n; <span class="hljs-comment">/* the new hash table */</span><br><br>    <span class="hljs-comment">// 根据 size 参数，计算哈希表的大小</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> realsize = _dictNextPower(size);<br><br>    <span class="hljs-comment">/* the size is invalid if it is smaller than the number of</span><br><span class="hljs-comment">     * elements already inside the hash table */</span><br>    <span class="hljs-comment">// 不能在字典正在 rehash 时进行</span><br>    <span class="hljs-comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span><br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="hljs-number">0</span>].used &gt; size)<br>        <span class="hljs-keyword">return</span> DICT_ERR;<br><br>    <span class="hljs-comment">/* Allocate the new hash table and initialize all pointers to NULL */</span><br>    <span class="hljs-comment">// 为哈希表分配空间，并将所有指针指向 NULL</span><br>    n.size = realsize;<br>    n.sizemask = realsize<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// T = O(N)</span><br>    n.table = zcalloc(realsize*<span class="hljs-keyword">sizeof</span>(dictEntry*));<br>    n.used = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* Is this the first initialization? If so it&#x27;s not really a rehashing</span><br><span class="hljs-comment">     * we just set the first hash table so that it can accept keys. */</span><br>    <span class="hljs-comment">// 如果 0 号哈希表为空，那么这是一次初始化：</span><br>    <span class="hljs-comment">// 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].table == <span class="hljs-literal">NULL</span>) &#123;<br>        d-&gt;ht[<span class="hljs-number">0</span>] = n;<br>        <span class="hljs-keyword">return</span> DICT_OK;<br>    &#125;<br><br>    <span class="hljs-comment">/* Prepare a second hash table for incremental rehashing */</span><br>    <span class="hljs-comment">// 如果 0 号哈希表非空，那么这是一次 rehash ：</span><br>    <span class="hljs-comment">// 程序将新哈希表设置为 1 号哈希表，</span><br>    <span class="hljs-comment">// 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehash</span><br>    d-&gt;ht[<span class="hljs-number">1</span>] = n;<br>    d-&gt;rehashidx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> DICT_OK;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务组件-Alibaba工具集</title>
    <link href="/2021/09/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-Alibaba%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <url>/2021/09/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-Alibaba%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Spring-Cloud-Alibaba-工具集"><a href="#Spring-Cloud-Alibaba-工具集" class="headerlink" title="Spring  Cloud Alibaba 工具集"></a>Spring  Cloud Alibaba 工具集</h2><h3 id="一、Alibaba-工具集概述"><a href="#一、Alibaba-工具集概述" class="headerlink" title="一、Alibaba 工具集概述"></a>一、Alibaba 工具集概述</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">https://spring.io/projects/spring-cloud-alibaba<br></code></pre></td></tr></table></figure><p>阿里云为分布式应用开发提供了一站式解决方案。它包含了开发分布式应用程序所需的所有组件，使您可以轻松地使用<code>SpringCloud</code>开发应用程序。</p><p>有了阿里云，你只需要添加一些注解和少量的配置，就可以将Spring云应用连接到阿里的分布式解决方案上，用阿里中间件搭建一个分布式应用系统。</p><p>Alibaba工具集环境搭建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.cloud.alibaba.version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.cloud.alibaba.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-comment">&lt;!--全局引入springcloudalibaba下载依赖地址,并不会引入依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="二、Nacos"><a href="#二、Nacos" class="headerlink" title="二、Nacos"></a>二、Nacos</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>nacos.io<span class="hljs-regexp">/zh-cn/i</span>ndex.html<br></code></pre></td></tr></table></figure><blockquote><p><code>Nacos</code> 致力于帮助您发现、配置和管理微服务。<code>Nacos</code> 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p></blockquote><p><code>Nacos</code>就是微服务架构中服务注册中心以及统一配置中心,用来替换原来的(eureka,consul)以及config组件</p><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><ul><li><p>下载：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a> </p></li><li><p>解压：解压缩安装包到指定位置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> bin  启动nacos服务的脚本目录<br><span class="hljs-bullet">-</span> conf nacos的配置文件目录<br><span class="hljs-bullet">-</span> target nacos的启动依赖存放目录<br><span class="hljs-bullet">-</span> data  nacos启动成功后保存数据的目录<br></code></pre></td></tr></table></figure></li><li><p>启动：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> linux/unix/mac启动<br><span class="hljs-code">./startup.sh -m standalone</span><br><span class="hljs-code">- windows启动</span><br><span class="hljs-code">    执行 startup.cmd -m standalone 或者双击startup.cmd运行文件。</span><br></code></pre></td></tr></table></figure></li><li><p>web页面</p><p><a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p></li></ul><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908104425.png" alt="web页面"></p><h4 id="2、服务注册"><a href="#2、服务注册" class="headerlink" title="2、服务注册"></a>2、服务注册</h4><h5 id="2-1、添加依赖"><a href="#2-1、添加依赖" class="headerlink" title="2.1、添加依赖"></a>2.1、添加依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入nacos client的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-2、配置文件"><a href="#2-2、配置文件" class="headerlink" title="2.2、配置文件"></a>2.2、配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">9988</span><br><span class="hljs-comment"># 应用名称</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">user</span><br><span class="hljs-comment"># nacos 服务端地址</span><br><span class="hljs-attr">spring.cloud.nacos.server-addr</span>=<span class="hljs-string">localhost:8848</span><br><span class="hljs-comment"># 指定注册中心地址</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-string">$&#123;spring.cloud.nacos.server-addr&#125;</span><br><span class="hljs-comment"># 暴露所有web端点</span><br><span class="hljs-attr">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><br></code></pre></td></tr></table></figure><h5 id="2-3、添加注解"><a href="#2-3、添加注解" class="headerlink" title="2.3、添加注解"></a>2.3、添加注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User9988Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(User9988Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4、查看web页面"><a href="#2-4、查看web页面" class="headerlink" title="2.4、查看web页面"></a>2.4、查看web页面</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908105345.png" alt="web管理页面"></p><h4 id="3、配置中心"><a href="#3、配置中心" class="headerlink" title="3、配置中心"></a>3、配置中心</h4><h5 id="3-1、配置中心概念"><a href="#3-1、配置中心概念" class="headerlink" title="3.1、配置中心概念"></a>3.1、配置中心概念</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908110159.png" alt="配置中心"></p><p>配置中心中一个具体的配置文件有三个概念组成。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">namespace</span>    命名空间<br><span class="hljs-symbol">Group</span>        组<br><span class="hljs-symbol">Data</span> <span class="hljs-symbol">ID</span>      名称<br></code></pre></td></tr></table></figure><p>通过这个概念找到一个具体的配置文件。</p><ul><li><p>命名空间：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">namespace</span>命名空间是<span class="hljs-symbol">nacos</span>针对于企业级开发设计用来针对于不同环境的区分<br>比如正在企业开发时有测试环境,生产环境,等其他环境<br>因此为了保证不同环境配置实现隔离,提出了<span class="hljs-symbol">namespace</span>的概念<br></code></pre></td></tr></table></figure></li><li><p>Group：配置分组</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">配置分组是对配置集进行分组，通过一个有意义的字符串来表示，<br>不同的配置分组下可以有相同的<span class="hljs-meta">Data</span> ID。<br>如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。<br></code></pre></td></tr></table></figure></li><li><p>DataId：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">用来读取远程配置中心的中具体配置文件其完整格式如下:<br><span class="hljs-symbol">$</span>&#123;prefix&#125;-<span class="hljs-symbol">$</span>&#123;spring.profile.active&#125;.<span class="hljs-symbol">$</span>&#123;<span class="hljs-keyword">file</span>-extension&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> prefix <br><span class="hljs-code">    默认为 spring.application.name 的值，</span><br><span class="hljs-code">    也可以通过配置项 spring.cloud.nacos.config.prefix来配置。</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> spring.profile.active <br><span class="hljs-code">    即为当前环境对应的 profile</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> file-exetension 为配置内容的数据格式，<br><span class="hljs-code">    可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。</span><br><span class="hljs-code">    目前只支持 properties 和 yaml 类型。</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="3-2、引入依赖"><a href="#3-2、引入依赖" class="headerlink" title="3.2、引入依赖"></a>3.2、引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入nacos config 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="3-3、配置文件"><a href="#3-3、配置文件" class="headerlink" title="3.3、配置文件"></a>3.3、配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">config</span><br><span class="hljs-comment"># 远程配置中心的地址</span><br><span class="hljs-attr">spring.cloud.nacos.server-addr</span>=<span class="hljs-string">localhost:8848</span><br><span class="hljs-comment"># 读取配置的分组</span><br><span class="hljs-attr">spring.cloud.nacos.config.group</span>=<span class="hljs-string">DEFAULT_GROUP</span><br><span class="hljs-comment"># 指定读取文件后缀</span><br><span class="hljs-attr">spring.cloud.nacos.config.file-extension</span>=<span class="hljs-string">properties</span><br><span class="hljs-comment"># 指定读取文件的具体环境</span><br><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">prod</span><br></code></pre></td></tr></table></figure><h5 id="3-4、在Nacos中新建配置文件"><a href="#3-4、在Nacos中新建配置文件" class="headerlink" title="3.4、在Nacos中新建配置文件"></a>3.4、在Nacos中新建配置文件</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908113227.png" alt="Nacos配置文件"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">9988</span><br><span class="hljs-attr">spring.cloud.nacos.discovey.server-addr</span>=<span class="hljs-string">$&#123;spring.cloud.server.addr&#125;</span><br><span class="hljs-attr">spring.cloud.nacos.server-addr</span>=<span class="hljs-string">localhost:8848</span><br><span class="hljs-attr">user.name</span>=<span class="hljs-string">jiang</span><br></code></pre></td></tr></table></figure><h5 id="3-5、读取配置文件"><a href="#3-5、读取配置文件" class="headerlink" title="3.5、读取配置文件"></a>3.5、读取配置文件</h5><p>启动并查看日志：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908113444.png" alt="启动日志"></p><h5 id="3-5、编写控制器测试读取结果"><a href="#3-5、编写控制器测试读取结果" class="headerlink" title="3.5、编写控制器测试读取结果"></a>3.5、编写控制器测试读取结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name = &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908113517.png" alt="测试结果"></p><h5 id="3-6、实现自动刷新"><a href="#3-6、实现自动刷新" class="headerlink" title="3.6、实现自动刷新"></a>3.6、实现自动刷新</h5><p>默认情况下nacos已经实现了自动配置刷新功能。</p><p>如果需要刷新配置直接在控制器中加入@RefreshScope注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name = &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、sentinel"><a href="#三、sentinel" class="headerlink" title="三、sentinel"></a>三、sentinel</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/alibaba/</span>Sentinel/wiki<br></code></pre></td></tr></table></figure><p>Sentinel以”流量”为突破口，在流量控制、断路、负载保护等多个领域进行工作，保障服务可靠性。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。<br><br><span class="hljs-bullet">-</span> 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。<br><br><span class="hljs-bullet">-</span> 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。<br></code></pre></td></tr></table></figure><p>sentinel提供了两个服务组件：</p><ul><li>sentinel 用来实现微服务系统中服务熔断、降级等功能。</li><li>sentinel dashboard 用来监控微服务系统中流量调用等情况。</li></ul><h4 id="2、sentinel-dashboard的安装"><a href="#2、sentinel-dashboard的安装" class="headerlink" title="2、sentinel dashboard的安装"></a>2、sentinel dashboard的安装</h4><h5 id="2-1、下载jar包"><a href="#2-1、下载jar包" class="headerlink" title="2.1、下载jar包"></a>2.1、下载jar包</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/alibaba/</span>Sentinel/releases<br></code></pre></td></tr></table></figure><h5 id="2-2、启动"><a href="#2-2、启动" class="headerlink" title="2.2、启动"></a>2.2、启动</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -Dserver.port=<span class="hljs-number">9898</span> -jar  sentinel-dashboard-<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.jar<br></code></pre></td></tr></table></figure><h5 id="2-3、web管理界面"><a href="#2-3、web管理界面" class="headerlink" title="2.3、web管理界面"></a>2.3、web管理界面</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908114556.png" alt="管理界面"></p><p>用户&#x2F;密码：<code>sentinel</code></p><h4 id="3、快速开始"><a href="#3、快速开始" class="headerlink" title="3、快速开始"></a>3、快速开始</h4><h5 id="3-1、引入依赖"><a href="#3-1、引入依赖" class="headerlink" title="3.1、引入依赖"></a>3.1、引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入sentinel依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="3-2、配置文件"><a href="#3-2、配置文件" class="headerlink" title="3.2、配置文件"></a>3.2、配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">user</span><br><span class="hljs-comment"># 远程配置中心的地址</span><br><span class="hljs-attr">spring.cloud.nacos.server-addr</span>=<span class="hljs-string">localhost:8848</span><br><span class="hljs-comment"># 读取配置的分组</span><br><span class="hljs-attr">spring.cloud.nacos.config.group</span>=<span class="hljs-string">DEFAULT_GROUP</span><br><span class="hljs-comment"># 指定读取文件后缀</span><br><span class="hljs-attr">spring.cloud.nacos.config.file-extension</span>=<span class="hljs-string">properties</span><br><span class="hljs-comment"># 指定读取文件的具体环境</span><br><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">prod</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Sentinel配置</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启sentinel 默认开启</span><br><span class="hljs-attr">spring.cloud.sentinel.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 连接dashboard  web页面</span><br><span class="hljs-attr">spring.cloud.sentinel.transport.dashboard</span>=<span class="hljs-string">localhost:9989</span><br><span class="hljs-comment"># 与dashboard通信的端口 用于传输日志的端口</span><br><span class="hljs-attr">spring.cloud.sentinel.transport.port</span>=<span class="hljs-string">8719</span><br></code></pre></td></tr></table></figure><h5 id="3-3、启动"><a href="#3-3、启动" class="headerlink" title="3.3、启动"></a>3.3、启动</h5><p>访问页面：<a href="http://localhost:9989/#/dashboard">http://localhost:9989/#/dashboard</a></p><p>但是界面并没有出现变化。</p><p>原因：</p><p><code>默认情况下sentiel为延迟加载,不会在启动之后立即创建服务监控,需要对服务进行调用时才会初始化</code></p><p>调用：<a href="http://localhost:9988/user/test">http://localhost:9988/user/test</a></p><p>访问页面：<a href="http://localhost:9989/#/dashboard">http://localhost:9989/#/dashboard</a></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908131957.png" alt="管理页面"></p><h4 id="4、实时监控"><a href="#4、实时监控" class="headerlink" title="4、实时监控"></a>4、实时监控</h4><p>实时监控界面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">什么是QPS：<br>QPS意思是每秒查询率，是计算机中服务器每秒能够相应的查询次数<br>QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908132245.png" alt="image-20210908132242690"></p><h4 id="5、流量控制"><a href="#5、流量控制" class="headerlink" title="5、流量控制"></a>5、流量控制</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。<br><br><span class="hljs-bullet">-</span> 同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。<br><br><span class="hljs-bullet">-</span> 一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：<br><span class="hljs-code">resource：资源名，即限流规则的作用对象</span><br><span class="hljs-code">count: 限流阈值</span><br><span class="hljs-code">grade: 限流阈值类型（QPS 或并发线程数）</span><br><span class="hljs-code">limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</span><br><span class="hljs-code">strategy: 调用关系限流策略</span><br><span class="hljs-code">controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> 流量控制主要有两种统计类型，一种是统计并发线程数，另外一种则是统计 QPS<br><span class="hljs-bullet">-</span> 更多细节参见官网:https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6<br></code></pre></td></tr></table></figure><h5 id="5-1、QPS限流"><a href="#5-1、QPS限流" class="headerlink" title="5.1、QPS限流"></a>5.1、QPS限流</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908132653.png" alt="QPS限流"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">资源名：访问的资源路径<br>阈值类型：QPS<br>单机阈值：每秒最大请求为1<br></code></pre></td></tr></table></figure><p>测试：反复刷新出现错误</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908132832.png" alt="测试"></p><h5 id="5-2、线程数限流"><a href="#5-2、线程数限流" class="headerlink" title="5.2、线程数限流"></a>5.2、线程数限流</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908133747.png" alt="线程数限流"></p><p>测试：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908135119.png" alt="测试"></p><h5 id="5-3、流控模式"><a href="#5-3、流控模式" class="headerlink" title="5.3、流控模式"></a>5.3、流控模式</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><br><span class="hljs-bullet">-</span> 直接:标识流量控制规则到达阈值直接触发流量控制<br><span class="hljs-bullet">-</span> 关联: 当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，read<span class="hljs-emphasis">_db 和 write_</span>db 这两个资源分别代表数据库读写，我们可以给 read<span class="hljs-emphasis">_db 设置限流规则来达到写优先的目的：设置 strategy 为 RuleConstant.STRATEGY_</span>RELATE 同时设置 refResource 为 write<span class="hljs-emphasis">_db。这样当写库操作过于频繁时，读数据的请求会被限流。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- 链路限流: https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908135228.png" alt="流控模式"></p><h5 id="5-4、流控效果"><a href="#5-4、流控效果" class="headerlink" title="5.4、流控效果"></a>5.4、流控效果</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 直接拒绝:（RuleConstant.CONTROL<span class="hljs-emphasis">_BEHAVIOR_</span>DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。<br><br><span class="hljs-bullet">-</span> Warm Up:（RuleConstant.CONTROL<span class="hljs-emphasis">_BEHAVIOR_</span>WARM<span class="hljs-emphasis">_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- 匀速排队:(RuleConstant.CONTROL_</span>BEHAVIOR<span class="hljs-emphasis">_RATE_</span>LIMITER）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。 只能对请求进行排队等待<br></code></pre></td></tr></table></figure><h4 id="6、熔断降级"><a href="#6、熔断降级" class="headerlink" title="6、熔断降级"></a>6、熔断降级</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。<br>由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。<br><br>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高）<br>对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。<br>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断<br>（默认行为是抛出 <span class="hljs-code">`DegradeException`</span>）。<br></code></pre></td></tr></table></figure><h5 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h5><ul><li>平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 N 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</li></ul><p><img src="D:/Document/Code/资料/springcloud资料/springcloud资料/笔记(含alibaba笔记" alt="image-20200802142932522">&#x2F;Spring Cloud Alibaba.assets&#x2F;image-20200802142932522.png)</p><ul><li>异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;&#x3D; N（可配置），并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</li></ul><p><img src="D:/Document/Code/资料/springcloud资料/springcloud资料/笔记(含alibaba笔记" alt="image-20200802143052470">&#x2F;Spring Cloud Alibaba.assets&#x2F;image-20200802143052470.png)</p><ul><li>异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li></ul><p><img src="D:/Document/Code/资料/springcloud资料/springcloud资料/笔记(含alibaba笔记" alt="image-20200802143314524">&#x2F;Spring Cloud Alibaba.assets&#x2F;image-20200802143314524.png)</p><h4 id="7、SentinelResource注解"><a href="#7、SentinelResource注解" class="headerlink" title="7、SentinelResource注解"></a>7、SentinelResource注解</h4><h4 id="5-SentinelResource注解"><a href="#5-SentinelResource注解" class="headerlink" title="5.SentinelResource注解"></a>5.SentinelResource注解</h4><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81">https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81</a></p><p><img src="D:/Document/Code/资料/springcloud资料/springcloud资料/笔记(含alibaba笔记" alt="image-20200802150527319">&#x2F;Spring Cloud Alibaba.assets&#x2F;image-20200802150527319.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/sentinel/test1&quot;)</span><br>   <span class="hljs-meta">@SentinelResource(value = &quot;aa&quot;,blockHandler = &quot;fallBack&quot;,fallback = &quot;fall&quot;)</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>       log.info(<span class="hljs-string">&quot;sentinel test1&quot;</span>);<br>       <span class="hljs-keyword">if</span>(id&lt;<span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;非法参数!!!&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sentinel test1 :&quot;</span>+id;<br>   &#125;<br><span class="hljs-comment">//降级异常处理</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fallBack</span><span class="hljs-params">(<span class="hljs-type">int</span> id,BlockException e)</span>&#123;<br>           <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> FlowException)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;当前服务已被流控! &quot;</span>+e.getClass().getCanonicalName();<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;当前服务已被降级处理! &quot;</span>+e.getClass().getCanonicalName();<br>   &#125;<br><span class="hljs-comment">//异常处理</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fall</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;当前服务已不可用!&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务组件-配置中心</title>
    <link href="/2021/09/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2021/09/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="微服务组件-配置中心"><a href="#微服务组件-配置中心" class="headerlink" title="微服务组件 - 配置中心"></a>微服务组件 - 配置中心</h2><h3 id="一、什么是配置中心-Config"><a href="#一、什么是配置中心-Config" class="headerlink" title="一、什么是配置中心(Config)"></a>一、什么是配置中心(Config)</h3><h4 id="1、配置中心简述"><a href="#1、配置中心简述" class="headerlink" title="1、配置中心简述"></a>1、配置中心简述</h4><p>对于传统的单体应用而言， 我们使用的配置文件可以管理整个系统。比如，SpringBoot中的application.yml文件可以管理整个SpringBoot项目。</p><p>但是在微服务架构中，我们将整个应用分成多个微小的服务，每一个服务可以看成一个单体应用，就可以通过配置文件来管理。这样如果系统拥有几十个服务，那么配置文件太多了，甚至为了使系统变的高可用，会大规模集群部署服务应用，如果要手动修改是非常麻烦，而且还不易维护。</p><h4 id="2、配置中心的好处"><a href="#2、配置中心的好处" class="headerlink" title="2、配置中心的好处"></a>2、配置中心的好处</h4><ol><li><p>集中配置管理，一个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的。</p></li><li><p>不同环境不同配置，比如数据源配置在不同环境（开发，生产，测试）中是不同的。</p></li><li><p>运行期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小等</p></li><li><p>配置修改后可自动更新。如配置内容发生变化，微服务可以自动更新配置</p></li></ol><h4 id="3、简述配置中心开发"><a href="#3、简述配置中心开发" class="headerlink" title="3、简述配置中心开发"></a>3、简述配置中心开发</h4><p>配置中心分成服务端和客户端两个部分。</p><ul><li><p>服务端</p><p>服务端是一个独立的微服务应用。用来连接配置仓库并为客户端提供获取配置信息等访问接口</p></li><li><p>客户端</p><p>客户端是微服务架构中的各个微服务应用，它们通过服务端来管理应用资源与业务相关的配置内容</p><p>并在启动时从服务端获取和加载配置信息。</p></li></ul><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210907112842.png" alt="开发模型"></p><h3 id="二、配置中心开发"><a href="#二、配置中心开发" class="headerlink" title="二、配置中心开发"></a>二、配置中心开发</h3><h4 id="1、Config-服务端开发"><a href="#1、Config-服务端开发" class="headerlink" title="1、Config 服务端开发"></a>1、Config 服务端开发</h4><h5 id="1-1、引入依赖"><a href="#1-1、引入依赖" class="headerlink" title="1.1、引入依赖"></a>1.1、引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入统一配置中心--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-2、创建仓库"><a href="#1-2、创建仓库" class="headerlink" title="1.2、创建仓库"></a>1.2、创建仓库</h5><p>在Gitee上创建一个仓库–configserver。</p><p>新建文件</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210907105337.png" alt="配置文件"></p><h5 id="1-3、拉取远端配置"><a href="#1-3、拉取远端配置" class="headerlink" title="1.3、拉取远端配置"></a>1.3、拉取远端配置</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">7878</span><span class="hljs-regexp">/master/u</span>sers-xxx.properties<br></code></pre></td></tr></table></figure><p>规则：<code>label/name-profiles.properties</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> label:     仓库的分支，如果不写，则是默认是master分支。<br><span class="hljs-bullet">2.</span> name:      代表读取那个具体的配置文件的文件名称<br><span class="hljs-bullet">3.</span> profiles:  读取配置文件环境，比如dev<br></code></pre></td></tr></table></figure><h5 id="1-4、通过配置文件指定分支和本地仓库"><a href="#1-4、通过配置文件指定分支和本地仓库" class="headerlink" title="1.4、通过配置文件指定分支和本地仓库"></a>1.4、通过配置文件指定分支和本地仓库</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 本地仓库</span><br><span class="hljs-attr">spring.cloud.config.server.git.basedir</span>=<span class="hljs-string">/localresp #一定要是一个空目录,在首次会将该目录清空</span><br><span class="hljs-comment"># 分支</span><br><span class="hljs-attr">spring.cloud.config.server.git.default-label</span>=<span class="hljs-string">master   #指定使用远程仓库中那个分支中内容</span><br></code></pre></td></tr></table></figure><h4 id="2、Config-客户端开发"><a href="#2、Config-客户端开发" class="headerlink" title="2、Config 客户端开发"></a>2、Config 客户端开发</h4><h5 id="2-1、引入依赖"><a href="#2-1、引入依赖" class="headerlink" title="2.1、引入依赖"></a>2.1、引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入config client--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-2、编写配置文件"><a href="#2-2、编写配置文件" class="headerlink" title="2.2、编写配置文件"></a>2.2、编写配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">configclient</span><br><span class="hljs-comment"># config 配置文件</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启统一配置中心服务</span><br><span class="hljs-attr">spring.cloud.config.discovery.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 指定统一配置服务中心的服务唯一标识</span><br><span class="hljs-attr">spring.cloud.config.discovery.service-id</span>=<span class="hljs-string">configserver</span><br><span class="hljs-comment"># 指定从仓库的那个分支拉取配置</span><br><span class="hljs-attr">spring.cloud.config.label</span>=<span class="hljs-string">master</span><br><span class="hljs-comment"># 指定拉取配置文件的名称</span><br><span class="hljs-attr">spring.cloud.config.name</span>=<span class="hljs-string">users</span><br><span class="hljs-comment"># 指定拉取配置文件的环境</span><br><span class="hljs-attr">spring.cloud.config.profile</span>=<span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>在远端仓库中：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210907110943.png" alt="远端仓库文件"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># users.properties</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">configclient</span><br><span class="hljs-attr">spring.cloud.consul.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.cloud.consul.port</span>=<span class="hljs-string">8500</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># users-dev.properties</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">9099</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># user-prod.properties</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">9098</span><br></code></pre></td></tr></table></figure><h5 id="2-3、启动出现问题"><a href="#2-3、启动出现问题" class="headerlink" title="2.3、启动出现问题"></a>2.3、启动出现问题</h5><ol><li>需要指定服务名称</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Consul service ids must not <span class="hljs-keyword">be </span>empty, must start with a letter, end with a letter <span class="hljs-keyword">or </span><span class="hljs-keyword">digit, </span><span class="hljs-keyword">and </span>have as interior characters only letters, <span class="hljs-keyword">digits, </span><span class="hljs-keyword">and </span>hyphen: <span class="hljs-number">8988</span><br></code></pre></td></tr></table></figure><p>解决方法：我们需要在配置文件中指定服务名称</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">configclient</span><br></code></pre></td></tr></table></figure><ol start="2"><li>修改配置文件名称</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210907115021.png" alt="修改配置文件名称"></p><p>项目中目前使用的是<code>application.properties</code>启动项目,使用这个配置文件在SpringBoot项目启动过程中不会等待远程配置拉取,直接根据配置文件中内容启动,因此当需要注册中心,服务端口等信息时,远程配置还没有拉取到,所以直接报错。</p><p>解决方法：修改配置文件名称</p><p>使用统一配置中心时应该将微服务的配置文件名修改为bootstrap.(properties|yml)</p><h5 id="2-4、测试"><a href="#2-4、测试" class="headerlink" title="2.4、测试"></a>2.4、测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.cloud.config.profile&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String prod;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/port&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;此时的环境是&quot;</span> + prod + <span class="hljs-string">&quot;,端口号为&quot;</span> + port;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 指定拉取配置文件的环境</span><br><span class="hljs-attr">spring.cloud.config.profile</span>=<span class="hljs-string">prod</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210907120321.png" alt="成功拉取"></p><p>证明此时拉取的是<code>users-prod.properties</code>。</p><h3 id="三、手动刷新配置信息"><a href="#三、手动刷新配置信息" class="headerlink" title="三、手动刷新配置信息"></a>三、手动刷新配置信息</h3><p>在生产环境中,微服务可能非常多,每次修改完远端配置之后,不可能对所有服务进行重新启动。</p><p>这个时候需要让修改配置的服务能够刷新远端修改之后的配置,从而不要每次重启服务才能生效,进一步提高微服务系统的维护效率。</p><p>在springcloud中也为我们提供了手动刷新配置和自动刷新配置两种策略,这里我们先试用手动配置文件刷新。自动配置需要和BUS一起使用。</p><h4 id="1、添加配置"><a href="#1、添加配置" class="headerlink" title="1、添加配置"></a>1、添加配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><br></code></pre></td></tr></table></figure><h4 id="2、添加注解"><a href="#2、添加注解" class="headerlink" title="2、添加注解"></a>2、添加注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/port&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name&quot;</span> + name + <span class="hljs-string">&quot;,port&quot;</span> + port;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 修改之前</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">9098</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">jzw</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210907115016.png" alt="修改之前"></p><p>修改配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 修改之后</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">9098</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">jzw1</span><br></code></pre></td></tr></table></figure><p>发送post请求：<code>curl -X POST http://localhost:9098/actuator/refresh</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">C:\Users\JiangZW&gt;curl -X POST http://localhost:9098/actuator/refresh<br>[&quot;config.client.version&quot;,&quot;server.port&quot;]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210907115013.png" alt="修改之后"></p><p>弊端：</p><p>需要手动发送POST请求才能刷新，并且一次只更新一个配置。</p><h3 id="四、自动刷新"><a href="#四、自动刷新" class="headerlink" title="四、自动刷新"></a>四、自动刷新</h3><p>使用<code>Spring Cloud Bus</code>实现配置的自动刷新。</p><p> Bus称之为<code>Spring Cloud Bus</code>中消息总线,主要用来在微服务系统中实现远端配置更新时通过广播形式通知所有客户端刷新配置信息,避免手动重启服务的工作</p><p><code>Spring Cloud Bus</code>使用轻量级消息代理将分布式系统的节点连接起来。然后，可以使用它来广播状态更改（例如配置更改）或其他管理指令。<code>AMQP</code>和<code>Kafka broker</code>实现包含在项目中。或者，在类路径上找到的任何<code>SpringCloudStream</code>绑定器都可以作为传输使用。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908140202.png" alt="消息队列拉取配置信息"></p><h4 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入bus依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、安装RabbitMQ"><a href="#2、安装RabbitMQ" class="headerlink" title="2、安装RabbitMQ"></a>2、安装RabbitMQ</h4><h4 id="3、-服务端配置-–-配置统一配置中心连接到MQ"><a href="#3、-服务端配置-–-配置统一配置中心连接到MQ" class="headerlink" title="3、 服务端配置 – 配置统一配置中心连接到MQ"></a>3、 服务端配置 – 配置统一配置中心连接到MQ</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.111.128</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest#连接mq密码</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210908140226.png" alt="消息队列"></p><h4 id="4、客户端配置"><a href="#4、客户端配置" class="headerlink" title="4、客户端配置"></a>4、客户端配置</h4><p>添加配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># bus消息总线时必须开启连接远程服务失败报错</span><br><span class="hljs-attr">spring.cloud.config.fail-fast</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h4 id="5、刷新"><a href="#5、刷新" class="headerlink" title="5、刷新"></a>5、刷新</h4><p>配置统一刷新:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">curl -X POST http://localhost:7878/actuator/bus-refresh<br></code></pre></td></tr></table></figure><p>我们还可以指定服务进行刷新配置：</p><p>指定一个服务集群刷新：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">curl -X POST http://localhost:7878/actuator/bus-refresh/configclient<br></code></pre></td></tr></table></figure><p>指定一个具体服务节点刷新：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">curl -X POST http://localhost:7878/actuator/bus-refresh/configclient:9090<br></code></pre></td></tr></table></figure><p>此时，我们可以实现统一刷新，但依然需要发送POST请求才能刷新配置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ThreadLocal</title>
    <link href="/2021/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/"/>
    <url>/2021/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h3 id="多线程产生的线程安全性问题"><a href="#多线程产生的线程安全性问题" class="headerlink" title="多线程产生的线程安全性问题"></a>多线程产生的线程安全性问题</h3><p>数据一致性问题：发生在多个主体对同一份数据无法达成共识。</p><p>解决方法：</p><ol><li>排队：锁、互斥量、管程、屏障</li><li>投票：Paxos算法、Raft算法</li></ol><p>这两种方法都会消耗额外的性能。</p><p><code>ThreadLocal</code>是能够避免数据不一致性的。</p><h3 id="ThreadLocal使用"><a href="#ThreadLocal使用" class="headerlink" title="ThreadLocal使用"></a>ThreadLocal使用</h3><p>定义：</p><blockquote><p>提供线程局部变量</p><p>一个线程局部变量在多个线程中，分别有多个独立的值。</p></blockquote><p>特点：</p><blockquote><p>简单(开箱即用)、快速(无额外开销)、安全(线程安全)</p></blockquote><h4 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h4><p>初始化值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Long&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Long <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getId();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>得到值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">local.get();<br></code></pre></td></tr></table></figure><p>设置值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">local.set(<span class="hljs-number">0L</span>);<br></code></pre></td></tr></table></figure><p>移除值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">local.remove();<br></code></pre></td></tr></table></figure><p>综合案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br><br>    <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Long&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Long <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Thread.currentThread().getId();<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName()  + <span class="hljs-string">&quot;的值为&quot;</span> + local.get());<br>        local.remove();<br>        System.out.println(<span class="hljs-string">&quot;将主线程的local移除&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;中的Local值为&quot;</span> + local.get());<br>                System.out.println(<span class="hljs-string">&quot;重新设置线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;中的Local值为111L&quot;</span>);<br>                local.set(<span class="hljs-number">111L</span>);<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;中的Local值为&quot;</span> + local.get());<br>                System.out.println(<span class="hljs-string">&quot;将线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;中的Local值移除&quot;</span>);<br>                local.remove();<br><br>                System.out.println(<span class="hljs-string">&quot;移除之后在打印线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;的值&quot;</span> + local.get());<br>            &#125;<br>        &#125;<br>        ).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">线程main的值为1<br>将主线程的local移除<br>线程Thread-0中的Local值为12<br>重新设置线程Thread-0中的Local值为111L<br>线程Thread-0中的Local值为111<br>将线程Thread-0中的Local值移除<br>移除之后在打印线程Thread-0的值12<br></code></pre></td></tr></table></figure><h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><h4 id="数据库连接-–-线程一致"><a href="#数据库连接-–-线程一致" class="headerlink" title="数据库连接 – 线程一致"></a>数据库连接 – 线程一致</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateTest</span><span class="hljs-params">(Test updateVO)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> testMapper.selectByPrimaryKey(updateVO.getId());<br><br>    testMapper.updateByPrimaryKey(updateVO);<br>    testMapper.deleteByPrimaryKey(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们有一个线程来执行这个方法，这个方法开启的事务，事务是基于<code>数据库Connection</code>连接的，这个事务中有三个操作数据库的DAO方法。如果想用一个事务来管三个操作dao的方法，那么这三个dao方法必须基于<code>同一个Connection连接</code>。</p><h5 id="转账案例"><a href="#转账案例" class="headerlink" title="转账案例"></a>转账案例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 使用数据库</span><br>use demo;<br><span class="hljs-comment">-- 创建一张账户表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>money <span class="hljs-keyword">double</span><br>);<br><span class="hljs-comment">-- 初始化数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">10000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>引入maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>C3P0配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">c3p0-config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">default-config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  连接参数 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/demo<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 连接池参数 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">default-config</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">c3p0-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JDBC工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;<br>    <span class="hljs-comment">// c3p0 数据库连接池对象属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br>    <span class="hljs-comment">// 获取连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> ds.getConnection();<br>    &#125;<br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(AutoCloseable... ios)</span>&#123;<br>        <span class="hljs-keyword">for</span> (AutoCloseable io : ios) &#123;<br>            <span class="hljs-keyword">if</span>(io != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    io.close();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitAndClose</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(conn != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//提交事务</span><br>                conn.commit();<br>                <span class="hljs-comment">//释放连接</span><br>                conn.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollbackAndClose</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(conn != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//回滚事务</span><br>                conn.rollback();<br>                <span class="hljs-comment">//释放连接</span><br>                conn.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DAO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountDao</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">(Connection conn, String outUser, <span class="hljs-type">int</span> money)</span> <span class="hljs-keyword">throws</span> SQLException&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money - ? where name = ?&quot;</span>;<br>        <span class="hljs-comment">//注释从连接池获取连接的代码,使用从service中传递过来的connection</span><br><span class="hljs-comment">//        Connection conn = JdbcUtils.getConnection();</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstm</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        pstm.setInt(<span class="hljs-number">1</span>,money);<br>        pstm.setString(<span class="hljs-number">2</span>,outUser);<br>        pstm.executeUpdate();<br>        <span class="hljs-comment">//连接不能在这里释放,service层中还需要使用</span><br><span class="hljs-comment">//        JdbcUtils.release(pstm,conn);</span><br>        JdbcUtils.release(pstm);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">(Connection conn, String inUser, <span class="hljs-type">int</span> money)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money + ? where name = ?&quot;</span>;<br><span class="hljs-comment">//        Connection conn = JdbcUtils.getConnection();</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstm</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        pstm.setInt(<span class="hljs-number">1</span>,money);<br>        pstm.setString(<span class="hljs-number">2</span>,inUser);<br>        pstm.executeUpdate();<br><span class="hljs-comment">//        JdbcUtils.release(pstm,conn);</span><br>        JdbcUtils.release(pstm);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String outUser, String inUser, <span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-type">AccountDao</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDao</span>();<br>        <span class="hljs-comment">//线程并发情况下,为了保证每个线程使用各自的connection,故加锁</span><br>        <span class="hljs-keyword">synchronized</span> (AccountService.class) &#123;<br><br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn = JdbcUtils.getConnection();<br>                <span class="hljs-comment">//开启事务</span><br>                conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 转出</span><br>                ad.out(conn, outUser, money);<br>                <span class="hljs-comment">// 模拟转账过程中的异常</span><br><span class="hljs-comment">//            int i = 1/0;</span><br>                <span class="hljs-comment">// 转入</span><br>                ad.in(conn, inUser, money);<br>                <span class="hljs-comment">//事务提交</span><br>                JdbcUtils.commitAndClose(conn);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-comment">//事务回滚</span><br>                JdbcUtils.rollbackAndClose(conn);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 模拟数据 : Jack 给 Rose 转账 100</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">outUser</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Jack&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">inUser</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Rose&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>        <span class="hljs-type">AccountService</span> <span class="hljs-variable">as</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountService</span>();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> as.transfer(outUser, inUser, money);<br><br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">false</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;转账失败!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;转账成功!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">web-app</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta"> <span class="hljs-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta"> <span class="hljs-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.jiang.ServletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/transfer<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用apache ab 压力测试</p><blockquote><p>ab -n 100 -c 8 <a href="http://localhost:8080/transfer">http://localhost:8080/transfer</a></p></blockquote><p>最后结果没有问题。</p><p>这种方法可以解决在一个事务中的多个DAO操作均使用一个相同的<code>Connection</code>。</p><p>简单来看，其实就是一个service方法中有一个事务，那么在这个方法中获取一个<code>Connection</code>，然后将这个连接传递到这个事务下面的DAO操作中。DAO操作使用相同的连接，这样就保证了事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//从连接池中获取connection</span><br>    conn = JdbcUtils.getConnection();<br><span class="hljs-comment">//将conn传递给DAO 操作</span><br>    ad.out(conn, outUser, money);<br><span class="hljs-comment">//将conn传递给DAO 操作</span><br>    ad.in(conn, inUser, money);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法的弊端：</p><p><code>耦合度太高了，这里的conn需要从Service层传递给DAO层</code></p><h5 id="解决方法：ThreadLocal"><a href="#解决方法：ThreadLocal" class="headerlink" title="解决方法：ThreadLocal"></a>解决方法：ThreadLocal</h5><p>将Connection连接存储在ThreadLocal，保证同一线程使用同一Conn</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal对象 : 将connection绑定在当前线程中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-comment">// c3p0 数据库连接池对象属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br><br>    <span class="hljs-comment">// 获取连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">//取出当前线程绑定的connection对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> tl.get();<br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果没有，则从连接池中取出</span><br>            conn = ds.getConnection();<br>            <span class="hljs-comment">//再将connection对象绑定到当前线程中</span><br>            tl.set(conn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> conn;<br>    &#125;<br><br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(AutoCloseable... ios)</span> &#123;<br>        <span class="hljs-keyword">for</span> (AutoCloseable io : ios) &#123;<br>            <span class="hljs-keyword">if</span> (io != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    io.close();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitAndClose</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection();<br>            <span class="hljs-comment">//提交事务</span><br>            conn.commit();<br>            <span class="hljs-comment">//解除绑定</span><br>            tl.remove();<br>            <span class="hljs-comment">//释放连接</span><br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollbackAndClose</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection();<br>            <span class="hljs-comment">//回滚事务</span><br>            conn.rollback();<br>            <span class="hljs-comment">//解除绑定</span><br>            tl.remove();<br>            <span class="hljs-comment">//释放连接</span><br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在在Service层和DAO层不需要传递Conn，依然可以保证在一个事务中的多个DAO操作使用的同一个连接。</p><h3 id="简易版ThreadLocal"><a href="#简易版ThreadLocal" class="headerlink" title="简易版ThreadLocal"></a>简易版ThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">//我们这里的设计是</span><br>    <span class="hljs-comment">//通过map来存储线程的值，因此第一个map的K是线程</span><br>    <span class="hljs-comment">//而在源码中，我们不需要这样通过map来存储线程</span><br>    <span class="hljs-comment">//因为我们在Thread中定义了一个Map (ThreadLocalMap)</span><br>    <span class="hljs-keyword">static</span> HashMap&lt;Thread,HashMap&lt;MyThreadLocal&lt;?&gt;,Object&gt;&gt; threadLocalMap<br>            = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> HashMap&lt;MyThreadLocal&lt;?&gt;,Object&gt; getMap()&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-keyword">if</span>(!threadLocalMap.containsKey(thread))&#123;<br>            threadLocalMap.put(thread,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;MyThreadLocal&lt;?&gt;,Object&gt;());<br>        &#125;<br>        <span class="hljs-keyword">return</span> threadLocalMap.get(thread);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap();<br>        <span class="hljs-keyword">if</span>(!map.containsKey(<span class="hljs-built_in">this</span>))&#123;<br>            map.put(<span class="hljs-built_in">this</span>,initialValue());<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) map.get(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T v)</span>&#123;<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap();<br>        map.put(<span class="hljs-built_in">this</span>,v);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap();<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)&#123;<br>            map.remove(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> MyThreadLocal&lt;Long&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadLocal</span>&lt;Long&gt;()&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Long <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Thread.currentThread().getId();<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + local.get());<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocal源码设计"><a href="#ThreadLocal源码设计" class="headerlink" title="ThreadLocal源码设计"></a>ThreadLocal源码设计</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 每个Thread维护着一个ThreadLocalMap的引用<br><span class="hljs-bullet">2.</span> ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储<br><span class="hljs-bullet">3.</span> ThreadLocal创建的副本是存储在自己的threadLocals中的，也就是自己的ThreadLocalMap。<br><span class="hljs-bullet">4.</span> ThreadLocalMap的键值为ThreadLocal对象，而且可以有多个threadLocal变量，因此保存在map中<br><span class="hljs-bullet">5.</span> 在进行get之前，必须先set，否则会报空指针异常，当然也可以初始化一个，但是必须重写initialValue()方法。<br><span class="hljs-bullet">6.</span> ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210905202721.png" alt="ThreadLocal设计"></p><h5 id="1-自定义的ThreadLocalMap"><a href="#1-自定义的ThreadLocalMap" class="headerlink" title="1.自定义的ThreadLocalMap"></a>1.自定义的ThreadLocalMap</h5><p>ThreadLocalMap 是一个定制的哈希映射，仅适用于维护线程本地值。不会在 ThreadLocal 类之外导出任何操作。该类是包私有的允许在类 Thread 中声明字段。为了帮助处理非常大且长期存在的用法，哈希表条目使用 WeakReferences 作为键。但是，由于不使用引用队列，所以只有在表开始耗尽空间时才能保证删除陈旧条目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要重新定义Map、和HashMap有什么区别：</p><p>ThreadLocalMap使用<code>线性探测法</code>来解决哈希冲突的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>     e != <span class="hljs-literal">null</span>;<br>     e = tab[i = nextIndex(i, len)]) &#123;<br>    ThreadLocal&lt;?&gt; k = e.get();<br><br>    <span class="hljs-keyword">if</span> (k == key) &#123;<br>        e.value = value;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>        replaceStaleEntry(key, value, i);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br>tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br></code></pre></td></tr></table></figure><h5 id="2-弱引用和内存泄漏"><a href="#2-弱引用和内存泄漏" class="headerlink" title="2.弱引用和内存泄漏"></a>2.弱引用和内存泄漏</h5><p>此哈希映射中的条目扩展了 WeakReference，使用其主要 ref 字段作为键（始终是ThreadLocal 对象）。请注意，空键（即 entry.get() &#x3D;&#x3D; null）意味着不再引用该键，因此可以从表中删除条目。此类条目在后面的代码中被称为 “陈旧条目”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>强引用和弱引用都会引起内存泄漏。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210905205415.png" alt="弱引用造成内存泄漏"></p><p>无论是强引用还是弱引用，都是因为在<code>ThreadLocalMap</code>的生命周期中没有调用<code>remove()</code>方法将<code>K-V</code>删除掉。</p><p>在强引用中，无法删除<code>ThreadLocal和K-V</code>。在弱引用中，无法删除<code>K-V</code>。</p><p>这就是为什么要使用弱引用。</p><p>如何避免内存泄漏：</p><p>最主要的方法就是调用<code>remove()方法</code>。特别是在线程池中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回表和覆盖索引</title>
    <link href="/2021/09/04/%E5%9B%9E%E8%A1%A8%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/09/04/%E5%9B%9E%E8%A1%A8%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>在理解回表之前，需要了解<a href="https://johnjoy.top/2021/09/04/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/">聚簇索引和非聚簇索引</a>。</p><p>在<code>InnoDB</code>，由聚簇索引和辅助键索引。</p><p>聚簇索引就是将主键值和数据放在一起存储。</p><p>辅助键索引就是将索引值和主键值放在一起存储。</p><p>表数据</p><p>表中有4列，其中ID是主键，设置age为普通索引。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210904190237.png" alt="表数据"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210904192136.png" alt="索引"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210904192950.png" alt="索引的底层"></p><p>执行SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ID,age <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>此时我们只需要通过普通索引就可以找到查询结果。因为在普通索引中有存储<code>age和ID值</code>。</p><p>我们可以看这句SQL语句的执行计划</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210904193607.png" alt="执行计划"></p><p>使用到了索引<code>age_index</code>。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210904193248.png" alt="查询路径"></p><p>执行SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ID,age,`enable` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>此时就需要回表了。</p><p>因为我们需要查询了不仅仅是ID和age，还需要<code>enable</code>，无法在普通索引中查询到全部字段。因此需要在主键索引创建的索引树中查找。</p><p>查看这条SQL语句的执行计划</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210904194435.png" alt="image-20210904194433634"></p><p>这条SQL我们依旧使用到了<code>age_index索引</code>，但是注意，在Extra中没有了<code>Useing index</code>。</p><p>查询路径</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210904194315.png" alt="查询路径"></p><p>总结：</p><p>回表就是先通过普通索引找到主键值，然后再根据主键来查询其他的字段。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>在查询时，出现回表会降低性能。那么，如何避免回表查询？</p><p>如果辅助索引上已经存在我们需要的数据,那么引擎就不会去主键上去搜索数据了，这就是覆盖索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> age <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><p>这条语句就符合覆盖索引的概念。在age的索引树中，我们可以获得我们需要查询的所有字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ID,age,enable <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><p>这条就不符合覆盖索引的概念，需要回表。</p><p>这就是为什么在这条SQL语句中的Extra中没有<code>Using index</code>。</p><p>总结：</p><p>辅助索引上已经存在我们需要的数据，不需要回表</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聚簇索引和非聚簇索引</title>
    <link href="/2021/09/04/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/09/04/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>简单来说：</p><p><strong>聚簇索引就是将数据和索引存储在一块，索引结构的叶子结点保存了数据。</strong></p><p><strong>非聚簇索引就是将数据和索引存储在一块，索引结构的叶子结点指向了数据对应的数据。</strong></p><p>在InnoDB中主键使用的时聚簇索引。MyISAM不管是主键索引还是二级索引都是使用的非聚簇索引。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p><code>The InnoDB term for a primary key index. InnoDB table storage is organized based on the values of the primary key columns, to speed up queries and sorts involving the primary key columns. For best performance, choose the primary key columns carefully based on the most performance-critical queries. Because modifying the columns of the clustered index is an expensive operation, choose primary columns that are rarely or never updated</code></p><p>**The InnoDB term for a primary key index(InnoDB术语，表示主键索引). **</p><p>因为索引和数据是一起存储的，因此我们找到了索引就找到了数据。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210624223821.png" alt="InnoDB(图取自https://my.oschina.net/xiaoyoung/blog/3046779)"></p><p>在InnoDB中，表中一定会有主键，如果没有自定义主键，那么InnoDB会选择一个<strong>唯一且非空</strong>的索引来代替。如果没有索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</p><p>主键使用聚簇索引，因此通过主键构造一棵B+树，叶子结点全是数据。我们通过主键索引，可以快速的查找到我们需要的数据。</p><p>在InooDB 中，我们定义除主键索引之外的索引，称为辅助索引（唯一索引，多列索引等）。<strong>辅助索引叶子结点存储的不再是行的物理位置，而是主键值，通过这个主键值，可以从主键所用构建的B+树快速查找数据。</strong></p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>MyISAM使用的是非聚簇索引，索引的存储和数据的存储是分离的，也就是说找到了所以但没找到数据，需要根据<strong>索引上的值（主键）再次回表查询</strong>，非聚簇索引也叫做辅助索引。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210624223722.png" alt="MyISAM图取自https://my.oschina.net/xiaoyoung/blog/304677"></p><p>在MyISAM中，主键索引构建的B+树中，叶子结点存储了主键，辅助索引构建的B+树中，叶子结点存储了辅助索引。</p><p>索引的叶子节点都指向对应的数据。</p><h3 id="聚簇索引和非聚簇索引对比"><a href="#聚簇索引和非聚簇索引对比" class="headerlink" title="聚簇索引和非聚簇索引对比"></a>聚簇索引和非聚簇索引对比</h3><p>对于InnoDB来说：每次使用辅助索引都要经过两次B+树查询。对于MyISAM来说，使用辅助索引只需一次B+树查询。</p><p>看上去非聚簇的索引效率更高，InnoDB为何会使用非聚簇索引。</p><ol><li><p>行数据和聚簇索引的叶子结点存储在一起，同一页中会有多条数据，访问同一数据页不同的行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中访问，不必访问磁盘。</p></li><li><p>在InnoDB中，辅助索引的叶子结点存储的是主键值，而不是地址值。</p></li><li><p>因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I&#x2F;O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I&#x2F;O。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务组件 -- 网关</title>
    <link href="/2021/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E7%BD%91%E5%85%B3/"/>
    <url>/2021/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="微服务组件：网关服务"><a href="#微服务组件：网关服务" class="headerlink" title="微服务组件：网关服务"></a>微服务组件：网关服务</h2><h3 id="一、网关"><a href="#一、网关" class="headerlink" title="一、网关"></a>一、网关</h3><h3 id="1、为什么需要网关"><a href="#1、为什么需要网关" class="headerlink" title="1、为什么需要网关"></a>1、为什么需要网关</h3><p>我们已经了解了微服务的各个基础组件，这些组件已经可以构建一个简单的微服务模型：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715101407.png" alt="微服务架构模型"></p><p>注册中心：<code>Eureka</code>和<code>consul</code>，用于将各个微服务的信息注册，为了让其他的微服务知道这些信息。方便调用</p><p>服务调用：声明式调用组件<code>OpenFeign</code>，为了解决服务的集群调用，需要引入负载均衡组件<code>Ribbon</code>。</p><p>容错保护：在服务运行时，可能会出现雪崩，服务器宕机等。为了使服务系统更加健壮，需要引入容错保护组件<code>Hxstrix</code>，实现线程隔离和熔断机制。</p><p>上面的系统架构设计并没有问题，但是在开发和维护时难度会更大。</p><ol><li><p>客户端发出请求，前端会根据这些请求发送给后端。因此前端需要维护大量的服务请求地址。</p></li><li><p>为了保证服务的对外安全性，我们都会添加权限校验机制，大规模的微服务会使校验逻辑变得复杂。</p></li></ol><p>为了解决这些常见的架构问题，API网关的概念应运而生。</p><h3 id="2、网关的概念"><a href="#2、网关的概念" class="headerlink" title="2、网关的概念"></a>2、网关的概念</h3><p>网关统一服务入口，可方便实现对平台众多服务接口进行管控。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 网关 =  路由转发 + 过滤器</span><br><span class="hljs-code">路由转发：接收一切外界请求，转发到后端的微服务上去；</span><br><span class="hljs-code">在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成</span><br></code></pre></td></tr></table></figure><p>网关的定义类似于面向对象设计模式中的<strong>门面模式</strong>，它就像是整个微服务系统对客户端的门面。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 门面模式(Facade)</span><br>也叫外观模式，通过定义一个一致的接口，用于屏蔽内部子系统的细节。<br>使得调用方只需跟这个接口发生调用，而无需关心内部细节。<br></code></pre></td></tr></table></figure><h3 id="二、GateWay实例"><a href="#二、GateWay实例" class="headerlink" title="二、GateWay实例"></a>二、GateWay实例</h3><h3 id="1、路由转发的实现"><a href="#1、路由转发的实现" class="headerlink" title="1、路由转发的实现"></a>1、路由转发的实现</h3><p>两个服务，商品服务和用户服务。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">user</span>       <span class="hljs-title">端口号  8881</span><br>product    端口号  <span class="hljs-number">8882</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入gateway网关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">consul:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user_route</span>                     <span class="hljs-comment"># 指定路由唯一标识</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8881/</span>        <span class="hljs-comment"># 指定路由服务的地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span>                  <span class="hljs-comment"># 指定路由规则</span><br><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8882/</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8880</span><br></code></pre></td></tr></table></figure><p>访问<code>http://localhost:8880/user/findOne?id=8</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715121056.png" alt="实现路由转发"></p><p>这就是服务的路由转发。</p><h3 id="2、集群服务的负载均衡"><a href="#2、集群服务的负载均衡" class="headerlink" title="2、集群服务的负载均衡"></a>2、集群服务的负载均衡</h3><p>将用户服务复制一份</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">user</span> <span class="hljs-title">端口号 7999</span> <span class="hljs-number">8881</span>   用户服务<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/user/findAllByFeign&quot;)</span><br><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.info(<span class="hljs-string">&quot;通过使用OpenFeign组件调用服务&quot;</span>);<br>    <span class="hljs-comment">//Map&lt;String,Object&gt; map = productClient.findAll();</span><br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;当前服务的端口号&quot;</span>,port);<br>    log.info(<span class="hljs-string">&quot;当前端口号是：&quot;</span> + port);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">getway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">consul:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user_route</span>                     <span class="hljs-comment"># 指定路由唯一标识</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user</span>         <span class="hljs-comment"># 指定路由服务的地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span>               <span class="hljs-comment"># 指定路由规则</span><br><br><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://product</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8880</span><br></code></pre></td></tr></table></figure><p>访问<code>http://localhost:8880/user/findAllByFeign</code>，会按照负载均衡算法来分配请求到哪个服务，默认的负载均衡算法是轮询。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715184437.png" alt="端口号-7999"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715185819.png" alt="端口号-8881"></p><h3 id="三、过滤器"><a href="#三、过滤器" class="headerlink" title="三、过滤器"></a>三、过滤器</h3><p>前面说过，网关有两个作用，路由转发和过滤器。</p><p>网关中的过滤器有什么用：权限校验、限流以及监控</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/</a></p><h4 id="1、使用predicate"><a href="#1、使用predicate" class="headerlink" title="1、使用predicate"></a>1、使用predicate</h4><h5 id="1-1、服务上线时间"><a href="#1-1、服务上线时间" class="headerlink" title="1.1、服务上线时间"></a>1.1、服务上线时间</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">getway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">consul:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user_route</span><span class="hljs-comment"># 指定路由唯一标识</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user</span>         <span class="hljs-comment"># 指定路由服务的地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span>  <span class="hljs-comment"># 指定路由规则</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">After=2021-07-15T11:33:33.993+08:00[Asia/Shanghai]</span>  <span class="hljs-comment"># 在这个时间之后服务上线</span><br><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://product</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product/**</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8880</span><br></code></pre></td></tr></table></figure><p>同样，也有服务下线的时间</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-string">Before=2020-07-21T11:33:33.993+08:00[Asia/Shanghai]</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="hljs-number">2017-01-21T17:42:47.789-07:00</span>[<span class="hljs-string">America/Denver</span>]<br></code></pre></td></tr></table></figure><h5 id="1-2、请求头"><a href="#1-2、请求头" class="headerlink" title="1.2、请求头"></a>1.2、请求头</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 设置请求头  只有请求带有这个请求头，才能访问</span><br><span class="hljs-attr">predicates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span>  <span class="hljs-comment"># 指定路由规则</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Header=head_Id,666</span><br></code></pre></td></tr></table></figure><p>我们通过Postman来做试验，没有加请求头：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715184515.png" alt="没有添加请求头"></p><p>我们添加一个请求头：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715184637.png" alt="添加请求头"></p><h5 id="1-3、添加cookie"><a href="#1-3、添加cookie" class="headerlink" title="1.3、添加cookie"></a>1.3、添加cookie</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">predicates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span>             <span class="hljs-comment"># 指定路由规则</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Header=head_Id,666</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=username,jiang</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715184708.png" alt="添加cookie"></p><h5 id="1-5、设置请求方法"><a href="#1-5、设置请求方法" class="headerlink" title="1.5、设置请求方法"></a>1.5、设置请求方法</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">predicates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span>                <span class="hljs-comment"># 指定路由规则</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Header=head_Id,666</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=username,jiang</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Method=POST</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715184746.png" alt="设置请求方法"></p><h4 id="2、自定义过滤器"><a href="#2、自定义过滤器" class="headerlink" title="2、自定义过滤器"></a>2、自定义过滤器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br><br>        log.info(<span class="hljs-string">&quot;进入过滤器&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;查看请求是否带有id参数&quot;</span>);<br>        List&lt;String&gt; list = exchange.getRequest().getQueryParams().get(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-keyword">if</span>(list != <span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;带有参数，可以访问&quot;</span>);<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;请求参数中 没有 id 拒绝访问&quot;</span>);<br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//filter 数字越小filter越先执行</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;              <span class="hljs-comment">//-1  最先执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求中添加参数</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715184923.png" alt="添加参数"></p><p>可以访问</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210715184931.png" alt="image-20210715184338184"></p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务组件 -- 服务容错保护</title>
    <link href="/2021/07/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/"/>
    <url>/2021/07/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="微服务组件：-Hystrix"><a href="#微服务组件：-Hystrix" class="headerlink" title="微服务组件： Hystrix"></a>微服务组件： Hystrix</h2><h3 id="一、Hystrix-简介"><a href="#一、Hystrix-简介" class="headerlink" title="一、Hystrix 简介"></a>一、Hystrix 简介</h3><h4 id="1、为什么需要容错保护"><a href="#1、为什么需要容错保护" class="headerlink" title="1、为什么需要容错保护"></a>1、为什么需要容错保护</h4><p>在微服务架构中，我们将系统的按功能拆分了很多服务单元，各个服务单元都被注册在注册中心中。通过从注册中心获取的其他服务地址，来调用其他服务。实现服务之间的调用。</p><p>比如：在一个电商网站中，我们可能将系统拆分为用户、订单、积分等服务单元。当用户创建一个订单的时候，</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210713014739.png" alt="微服务架构简单模型"></p><p>各个服务单元相互调用，相互依赖。由于每个服务单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为各种原因导致出现延迟，出现调用故障等。而这些问题直接导致调用方的对外服务出现延迟或故障。</p><p>比如：在电商网站中，用户服务和订单服务相互调用，当用户创建一个订单时，客户端将调用订单服务的创建订单接口，如果此时创建订单时由于自身的逻辑等原因造成响应缓慢，会导致创建订单服务的线程被挂起，只能等待创建订单的响应，甚至可能导致调用失败。在高并发的情况下，这些挂起的线程没有响应，并且后续有大量的请求被阻塞，最终导致订单服务也不可能用。</p><p>在微服务架构中，有这么多的服务单元，且服务之间需要相互调用，如果一个单元出现故障，就可能因依赖关系引发故障的蔓延，最终道中整个系统的瘫痪。</p><p>因此，我们需要引入服务容错保护组件 — <code>Hystrix</code>。</p><h4 id="2、什么是-Hystrix"><a href="#2、什么是-Hystrix" class="headerlink" title="2、什么是 Hystrix"></a>2、什么是 Hystrix</h4><p><code>Spring Cloud Hystrix </code>实现了断路器、线程隔离等一系列服务保护功能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 什么是 断路器</span><br><br>断路器是一种 “开关” 装置。<br>用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时切断故障电路。<br>防止发生过载、发热甚至起火等严重后果。<br><br></code></pre></td></tr></table></figure><p>在分布式架构中，断路器模式的作用也类似的，当某个服务单元发生故障（类似于电器发生短路）之后，通过断路器的故障监控（类似于熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程一直被挂起。避免的之后的调用被阻塞。</p><p><code>Hystrix</code>组件的目的在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</p><p><code>Hystrix</code>组件具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等功能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 服务熔断</span><br><br>服务熔断的作用类似于保险丝，当某个服务出现不可用时或响应超时时<br>为了防止 “服务雪崩” 暂停对该服务的调用<br><br><br><span class="hljs-section"># 服务降级：</span><br>为了预防某些服务出现负荷过载或者响应慢的情况，我们舍弃一些边缘服务（非核心业务或功能）。<br>直接返回一个提前准备号的fallback错误信息。<br><br><br><span class="hljs-section"># 相同点</span><br>防止系统的整体缓慢甚至崩溃，采用的技术手段；<br>最终让用户体验到的是某些功能暂时不可达或不可用；<br><br><span class="hljs-section"># 不同点</span><br>服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑<br><br><span class="hljs-section"># 注意</span><br>熔断必会触发降级,所以熔断也是降级一种。<br>区别在于熔断是对调用链路的保护,而降级是对系统过载的一种保护处理<br></code></pre></td></tr></table></figure><h3 id="二、Hystrix-实例-–-服务熔断"><a href="#二、Hystrix-实例-–-服务熔断" class="headerlink" title="二、Hystrix 实例 – 服务熔断"></a>二、Hystrix 实例 – 服务熔断</h3><p>注册中心为<code>Consul</code>，使用声明式调用组件<code>OpenFeign</code>。</p><p>两个服务，具体的服务实例查看另一篇博客。<a href="https://johnjoy.top/2021/07/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/">服务调用组件。</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">商品服务 <span class="hljs-comment">-- 端口号8882      product</span><br>用户服务 <span class="hljs-comment">-- 端口号8881 user</span><br><br>用户服务调用商品服务<br></code></pre></td></tr></table></figure><p>添加<code>Hystrix</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入hystrix--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@EnableCircuitBreaker</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Products8882Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Products8882Application.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductsController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/product/break&quot;)</span><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;testBreakFall&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testBreak</span><span class="hljs-params">(Integer id)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;接受商品的id&quot;</span> + id);<br><br>        <span class="hljs-keyword">if</span>(id &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数据不合法&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;当前接受商品id:&quot;</span> + id;<br>    &#125;<br><br>    <span class="hljs-comment">//设置 返回响应</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testBreakFall</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;对不起，当前数据不合法: &quot;</span> + id + <span class="hljs-string">&quot;请重新输入&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户服务通过<code>OpenFeign</code>来调用商品服务。</p><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;PRODUCT&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/product/break&quot;)</span><br>    String <span class="hljs-title function_">testBreak</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><span class="hljs-meta">@GetMapping(&quot;/user/break&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">breakTest</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> productClient.testBreak(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们输入正确的数值：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210714105933.png" alt="image-20210713154013962"></p><p>当我们输入错误的数值：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210714105928.png" alt="image-20210713153959709"></p><p>我们可以看到，当我们使用异常来模拟，出现异常时，断路器打开，此时出现服务熔断。那么就会调用设置的响应内容。</p><h3 id="三、Hystrix实例-–-服务降级"><a href="#三、Hystrix实例-–-服务降级" class="headerlink" title="三、Hystrix实例 – 服务降级"></a>三、Hystrix实例 – 服务降级</h3><p>服务熔断的实现是在被调用方，是服务端。而服务降级是在调用方，属于客户端。</p><p>可以通过<code>OpenFeign</code>和<code>Hystrix</code>实现服务降级。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入hystrix--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>加入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@EnableHystrix</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User8881Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(User8881Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开启<code>OpenFeign</code>支持服务降级</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">feign.hystrix.enabled</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>开发<code>fallback</code>处理类，并继承接口，不要忘记加入<code>@Component</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductFallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductClient</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testBreak</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fallback 处理方法&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接口上加入被调用方的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;PRODUCT&quot;,fallback = .class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/product/break&quot;)</span><br>    String <span class="hljs-title function_">testBreak</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们正常访问<code>localhost:8881/user/break?id=1</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210714105918.png" alt="image-20210713230644894"></p><p>我们商品服务<strong>关闭</strong>，再次访问<code>localhost:8881/user/break?id=1</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210714105914.png" alt="image-20210713230833652"></p><p>此时，服务端商品服务已经宕机了，但是我们进行了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。</p><h3 id="四、使用细节"><a href="#四、使用细节" class="headerlink" title="四、使用细节"></a>四、使用细节</h3><p>断路器打开的条件：</p><p><a href="https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 原文翻译之后,总结打开关闭的条件:</span><br><span class="hljs-bullet">-</span> 1、  当满足一定的阀值的时候（默认10秒内超过20个请求次数）<br><span class="hljs-bullet">-</span> 2、  当失败率达到一定的时候（默认10秒内超过50%的请求失败）<br><span class="hljs-bullet">-</span> 3、  到达以上阀值，断路器将会开启<br><span class="hljs-bullet">-</span> 4、  当开启的时候，所有请求都不会进行转发<br><span class="hljs-bullet">-</span> 5、  一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。<br><span class="hljs-code">如果成功，断路器会关闭，若失败，继续开启。重复4和5。</span><br></code></pre></td></tr></table></figure><p>我们做一个服务熔断中断路器的打开与关闭的实例：</p><p>我们访问<code>http://localhost:8881/user/break?id=-2</code>。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210714105905.png" alt="image-20210713231928800"></p><p>然后，疯狂刷新，10秒内刷新20个请求。</p><p>访问地址<code>http://localhost:8881/user/break?id=9</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210714105850.png" alt="image-20210713232035675"></p><p>可以看到，数据合法，但断路器依旧打开了。5 s之后再次访问，恢复正常。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210714105843.png" alt="image-20210713232153354"></p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务组件 -- 服务调用</title>
    <link href="/2021/07/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    <url>/2021/07/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>在 <code>SpringCloud</code> 中服务间调用方式主要是使用 <code>http restful</code>方式进行服务间调用。</p><p>所谓的服务键调用，简单来说，就是我可以调用其他模块的接口。</p><p>比如：</p><p>在服务A中有一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> AController&#123;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/msga&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetAMeg</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AController&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务B想要直接调用这个接口。需要通过什么方式或什么组件可以调用这个功能。</p><h3 id="一、负载均衡"><a href="#一、负载均衡" class="headerlink" title="一、负载均衡"></a>一、负载均衡</h3><p>服务间调用还需要考虑一个问题：<strong>负载均衡</strong>。</p><p>负载均衡在系统架构中是非常重要的。因为负载均衡对系统的高可用，网络压力的缓解和处理能力扩容的重要手段之一。</p><h4 id="1、客户端负载均衡"><a href="#1、客户端负载均衡" class="headerlink" title="1、客户端负载均衡"></a>1、客户端负载均衡</h4><p>在客户端负载均衡中，客户端知道所有服务端的详细信息，当需要调用服务端上的接口时，客户端从服务端列表中，根据<strong>负载均衡策略</strong>，自己挑选一个服务端来调用，此时客户端知道自己调用的是哪一个服务端。</p><h4 id="2、负载均衡策略"><a href="#2、负载均衡策略" class="headerlink" title="2、负载均衡策略"></a>2、负载均衡策略</h4><ul><li><p>轮询：就是将客户端的请求轮流分配给服务器，是最常用的负载均衡策略。</p></li><li><p>随机：随机挑选一个服务端来调用。保证请求的分散性达到了均衡。</p></li><li><p>加权：根据服务端的权重来分配客户端的请求。</p></li></ul><h3 id="二、基于-RestTemplate-服务调用"><a href="#二、基于-RestTemplate-服务调用" class="headerlink" title="二、基于 RestTemplate 服务调用"></a>二、基于 RestTemplate 服务调用</h3><p>​spring框架提供的<code>RestTemplate</code>类可用于在应用中调用rest服务，我们只需要传入url及返回值类型即可。</p><h4 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h4><h5 id="新建两个client实例，注册到consul中。"><a href="#新建两个client实例，注册到consul中。" class="headerlink" title="新建两个client实例，注册到consul中。"></a>新建两个client实例，注册到consul中。</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">服务<span class="hljs-selector-tag">A</span> Client-<span class="hljs-selector-tag">A</span>  端口号 <span class="hljs-number">8801</span><br>服务<span class="hljs-selector-tag">B</span> Client-<span class="hljs-selector-tag">B</span>  端口号 <span class="hljs-number">8802</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707205023.png" alt="consul 注册中心"></p><h5 id="为服务A添加一个接口"><a href="#为服务A添加一个接口" class="headerlink" title="为服务A添加一个接口"></a>为服务A添加一个接口</h5><p>我们希望在服务B中调用服务A的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/getmsg&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是服务A中的接口&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>localhost:8801/getmsg</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707210504.png" alt="服务A的接口"></p><h4 id="2、RestTemplate调用"><a href="#2、RestTemplate调用" class="headerlink" title="2、RestTemplate调用"></a>2、RestTemplate调用</h4><p>在服务B中编写Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientBController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/getmsg&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8801/getmsg&quot;</span>,String.class);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707210524.png" alt="服务B的接口"></p><h4 id="3、基于RestTemplate调用存在的问题"><a href="#3、基于RestTemplate调用存在的问题" class="headerlink" title="3、基于RestTemplate调用存在的问题"></a>3、基于RestTemplate调用存在的问题</h4><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8801/getmsg&quot;</span>,String.class);<br></code></pre></td></tr></table></figure><ol><li><p>没有经过注册中心。</p><p>从这行代码可以看出，是直接使用的url，没有从注册中心中获取服务A地址。</p></li><li><p>没有实现负载均衡</p><p>因此直接写上服务A的url，如果这个服务A宕机，那么程序会出现错误。</p></li><li><p>不利于维护</p><p>直接将服务A地址写死，无法高效修改或服务剔除。</p></li></ol><h3 id="三、基于Ribbon的服务调用"><a href="#三、基于Ribbon的服务调用" class="headerlink" title="三、基于Ribbon的服务调用"></a>三、基于Ribbon的服务调用</h3><h4 id="1、什么是Ribbon"><a href="#1、什么是Ribbon" class="headerlink" title="1、什么是Ribbon"></a>1、什么是Ribbon</h4><p>Ribbon是<code>Netflixfa</code>发布的一个负载均衡器，有助于控制HTTP和TCP客户端行为。</p><p>Ribbon提供<strong>客户端负载均衡</strong>的功能，Ribbon利用从<strong>注册中心</strong>读取的服务信息，在调用服务结点提供的服务时，会合理的进行负载。</p><h4 id="2、开发环境配置"><a href="#2、开发环境配置" class="headerlink" title="2、开发环境配置"></a>2、开发环境配置</h4><p>重新配置开发环境</p><p>创建两个服务并注册到Consul注册中心中，并希望用户服务去调用产品服务中的接口：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">user</span>服务      端口号   <span class="hljs-number">8881</span>    用户服务<br><span class="hljs-attribute">products</span>服务  端口号   <span class="hljs-number">8882</span>    产品服务<br></code></pre></td></tr></table></figure><p>并且引入Ribbon依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入ribbon依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>两个服务</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210711131532.png" alt="服务"></p><p>在商品服务中实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductsController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/product/findAll&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;服务调用成功，服务提供的端口号是：&quot;</span> + port);<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210711140903.png" alt="服务调用成功"></p><h4 id="3、基于Ribbon服务调用"><a href="#3、基于Ribbon服务调用" class="headerlink" title="3、基于Ribbon服务调用"></a>3、基于Ribbon服务调用</h4><p>方法简述</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 使用discovery client    进行调用<br><span class="hljs-bullet">2.</span> 使用loadBalanceClient   进行调用<br><span class="hljs-bullet">3.</span> 使用@loadBalanced       进行调用<br></code></pre></td></tr></table></figure><h5 id="3-1、使用-discovery-client"><a href="#3-1、使用-discovery-client" class="headerlink" title="3.1、使用 discovery client"></a>3.1、使用 discovery client</h5><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">discoveryClient.getInstances(<span class="hljs-string">&quot;服务提供者&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br>    <span class="hljs-comment">//选择一个服务器</span><br>    <span class="hljs-keyword">private</span> ServiceInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(<span class="hljs-string">&quot;product&quot;</span>);<br><span class="hljs-comment">//选择第一个服务器</span><br>        <span class="hljs-keyword">return</span> serviceInstances.get(<span class="hljs-number">0</span>);<br><br>    &#125;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/user/findAll&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br><br>        HashMap&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://&quot;</span> + getInstance().getHost() + <span class="hljs-string">&quot;:&quot;</span> + getInstance().getPort() + <span class="hljs-string">&quot;/product/findAll&quot;</span>;<br>        map = restTemplate.getForObject(url, HashMap.class);<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210711141223.png" alt="在用户服务中调用生产服务"></p><h5 id="3-2、Load-Balance-Client"><a href="#3-2、Load-Balance-Client" class="headerlink" title="3.2、Load Balance Client"></a>3.2、Load Balance Client</h5><p>通过<code>DiscoveryClient</code>可以从注册中心中将所有的<strong>服务提供者</strong>列举出来。</p><p>我们从中选择一个服务提供者，为服务的消费者提供服务。</p><p>在<code>DiscoveryClient</code>中，我们并没有添加负载均衡。只是简单的从提供者中选择了一项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/findAll&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br><br>        HashMap&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> loadBalancerClient.choose(<span class="hljs-string">&quot;product&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://&quot;</span> + product.getHost() + <span class="hljs-string">&quot;:&quot;</span> + product.getPort() + <span class="hljs-string">&quot;/product/findAll&quot;</span>;<br>        log.info(<span class="hljs-string">&quot;==============&quot;</span> + url);<br>        map = restTemplate.getForObject(url, HashMap.class);<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210711142433.png" alt="调用成功"></p><h5 id="3-3、-LoadBalance"><a href="#3-3、-LoadBalance" class="headerlink" title="3.3、@LoadBalance"></a>3.3、@LoadBalance</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserConfig</span> &#123;<br><br>    <span class="hljs-comment">//整合restTemplate + ribbon</span><br><br>    <span class="hljs-comment">//在工厂中创建一个restTemplate</span><br>    <span class="hljs-comment">//添加loadBalanced注解  代表ribbon负载均衡的restTemplate客户端对象</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">getRestTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-comment">//服务名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">serverName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;product&quot;</span>;<br><br>    <span class="hljs-comment">//2.调用服务位置注入RestTemplate</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/findAll&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>&#123;<br>        HashMap&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//3.调用</span><br>        map = restTemplate.getForObject(<span class="hljs-string">&quot;http://&quot;</span>+ serverName +<span class="hljs-string">&quot;/product/findAll&quot;</span>, HashMap.class);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、基于OpenFeign的服务调用"><a href="#四、基于OpenFeign的服务调用" class="headerlink" title="四、基于OpenFeign的服务调用"></a>四、基于OpenFeign的服务调用</h3><h4 id="1、OpenFeign简介"><a href="#1、OpenFeign简介" class="headerlink" title="1、OpenFeign简介"></a>1、OpenFeign简介</h4><p>前面的 RestTemplate + Ribbon 去进行服务间的调用，核心代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">restTemplate.getForObject(url,Class);<br></code></pre></td></tr></table></figure><p>可以看到，我们使用的是拼接字符串的方式构造URL的。</p><p>这样直接在代码中写出你要调用的服务和资源路径，这样系统的耦合度太高了。如果资源路径修改，就必须在代码上修改。</p><p>OpenFeign是<code>Netflflix</code>开发的声明式，模板化的HTTP客户端。</p><p>Feign可帮助我们更加便捷，优雅的调用HTTP API。 </p><h4 id="2、OpenFeign实例"><a href="#2、OpenFeign实例" class="headerlink" title="2、OpenFeign实例"></a>2、OpenFeign实例</h4><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--   引入OpenFegin依赖     --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、入口类加入注解，开启支持OpenFeign</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@FeignClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User8881Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(User8881Application.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>3、创建客户端调用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过注解指定服务名称</span><br><span class="hljs-meta">@FeignClient(&quot;PRODUCT&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/product/findAll&quot;)</span><br>    String <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、使用<code>feignClient</code>客户端对象调用服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductClient productClient;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/user/findAllByFeign&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;通过使用OpenFeign组件调用服务&quot;</span>);<br>        Map&lt;String,Object&gt; map = productClient.findAll();<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\JiangZW\AppData\Roaming\Typora\typora-user-images\image-20210711171230463.png" alt="调用成功"></p><h4 id="3、使用OpenFeign的细节问题"><a href="#3、使用OpenFeign的细节问题" class="headerlink" title="3、使用OpenFeign的细节问题"></a>3、使用OpenFeign的细节问题</h4><h5 id="1、传参"><a href="#1、传参" class="headerlink" title="1、传参"></a>1、传参</h5><p>服务提供者添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductsController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/product/findOne&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">findOne</span><span class="hljs-params">(String id)</span>&#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;port&quot;</span>,<span class="hljs-string">&quot;服务提供者的port:&quot;</span> + port);<br>        map.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;参数id&quot;</span> + id);<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;PRODUCT&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/product/findOne&quot;)</span><br>    Map&lt;String,Object&gt; <span class="hljs-title function_">findOne</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> String id)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductClient productClient;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/findOne&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">findOne</span><span class="hljs-params">(String id)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;通过使用OpenFeign组件调用服务&quot;</span>);<br>        Map&lt;String,Object&gt; map = productClient.findOne(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210711182439.png" alt="调用成功"></p><p>如果传递的是对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>Product Post请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PostController</span> &#123;<br><br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/product/save&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Student student)</span>&#123;<br><br><span class="hljs-comment">//log.info(&quot;============&quot; + request.getMethod());</span><br>        log.info(<span class="hljs-string">&quot;=====================&quot;</span>);<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        map.put(<span class="hljs-string">&quot;stu&quot;</span>,student);<br>        map.put(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">200</span>);<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;PRODUCT&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductClient</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/product/save&quot;)</span><br>Map&lt;String,Object&gt; <span class="hljs-title function_">save</span><span class="hljs-params">( <span class="hljs-meta">@RequestBody</span> Student student)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;   <br><span class="hljs-meta">@PostMapping(&quot;/user/save&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">save</span><span class="hljs-params">(Student student)</span>&#123;<br><br>        log.info(<span class="hljs-string">&quot;==========&quot;</span> + student);<br><br>        Map&lt;String,Object&gt; map = productClient.save(student);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210712123337.png" alt="调用成功"></p><h5 id="2、超时设置"><a href="#2、超时设置" class="headerlink" title="2、超时设置"></a>2、超时设置</h5><p>默认情况下,OpenFeign在进行服务调用时,要求服务提供方处理业务逻辑时间必须在1 S内返回,如果超过1 S没有返回则OpenFeign会直接报错,不会等待服务执行。</p><p>但是由于复杂的业务逻辑，可能会超过1 S，因此需要修改OpenFeign的默认服务调用超时事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/product/findAll&quot;)</span><br><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//设置 暂停2s</span><br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    <br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;服务调用成功，生产服务提供的端口号是：&quot;</span> + port);<br><br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210712125224.png" alt="超时"></p><p>修改默认超时时间</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">feign.client.config.product.connectTimeout</span>=<span class="hljs-string">5000  #配置指定服务连接超时</span><br><span class="hljs-attr">feign.client.config.product.readTimeout</span>=<span class="hljs-string">5000  #配置指定服务等待超时</span><br></code></pre></td></tr></table></figure><p>可能服务的调用者会同时调用多个服务，写单个服务超时时间麻烦，可以简写默认的超时时间：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">feign.client.config.default.connectTimeout</span>=<span class="hljs-string">5000         #配置所有服务连接超时</span><br><span class="hljs-attr">feign.client.config.default.readTimeout</span>=<span class="hljs-string">5000#配置所有服务等待超时</span><br></code></pre></td></tr></table></figure><h5 id="3、日志设置"><a href="#3、日志设置" class="headerlink" title="3、日志设置"></a>3、日志设置</h5><p>默认OpenFeign在调用是并不是最详细日志输出，因此在调试程序时应该开启feign的详细日志展示。</p><p>feign对日志的处理非常灵活可为每个feign客户端指定日志记录策略，每个客户端都会创建一个logger。</p><p>我们可以为feign客户端配置各自的<code>logger.level</code>对象，告诉feign记录那些日志<code>logger.lever</code>有以下的几种值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">NONE</span>  不记录任何日志<br>BASIC 仅仅记录请求方法，url，响应状态代码及执行时间<br>HEADERS 记录Basic级别的基础上，记录请求和响应的<span class="hljs-selector-tag">header</span><br>FULL 记录请求和响应的<span class="hljs-selector-tag">header</span>，<span class="hljs-selector-tag">body</span>和元数据<br></code></pre></td></tr></table></figure><p>开始日志配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">feign.client.config.product.loggerLevel</span>=<span class="hljs-string">full   #开启指定服务日志展示</span><br><span class="hljs-comment">#feign.client.config.default.loggerLevel=full  #全局开启服务日志展示</span><br><br><span class="hljs-attr">logging.level.com.jiang.feignclients</span>=<span class="hljs-string">debug    #指定feign调用客户端对象所在包,必须是debug级别</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务组件 -- 服务治理</title>
    <link href="/2021/07/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <url>/2021/07/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="微服务组件-–-服务治理"><a href="#微服务组件-–-服务治理" class="headerlink" title="微服务组件 – 服务治理"></a>微服务组件 – 服务治理</h2><h3 id="一、服务治理"><a href="#一、服务治理" class="headerlink" title="一、服务治理"></a>一、服务治理</h3><p>服务治理是微服务架构中最为核心和基础的模块，它是用于实现各个微服务实例的<strong>自动化注册与发现</strong>。</p><h4 id="1、为什么需要服务治理"><a href="#1、为什么需要服务治理" class="headerlink" title="1、为什么需要服务治理"></a>1、为什么需要服务治理</h4><p>我们可以通过做一些静态配置来完成服务的调用。比如，有两个服务A和B，其中服务A需要调用服务B来完成一个业务操作时，我们需要手工维护服务B的具体实例清单。</p><p>但是随着业务的发展，系统功能越来越复杂，相应的微服务应用也不断增加。我们的静态配置就会变得越来越难以维护。同时，我们集群规模、服务的位置、服务的命名等都有可能发生变化。</p><p>如果我们依旧使用静态配置的方式，会消耗大量的人力，甚至可能会出现错误。</p><h4 id="2、服务治理管理什么"><a href="#2、服务治理管理什么" class="headerlink" title="2、服务治理管理什么"></a>2、服务治理管理什么</h4><p>服务治理的这些框架和产品的实现都围绕着<strong>服务注册</strong>和<strong>服务发现</strong>机制来完成对微服务应用实例的自动化管理。</p><ul><li><p>服务注册</p><p>在服务治理框架中，通常会构建一个<strong>注册中心</strong>，每个微服务向注册中心登记自己提供的服务，将主机与端口号、版本号、通信协议等一些附加信息告诉注册中心。</p><p>注册中心还需要以心跳的方式去监测清单中的服务是否可用，若不可用需要从清单中剔除，达到排除故障服务的效果。</p></li><li><p>服务发现</p><p>通过服务治理的框架，服务间的调用不在通过指定具体的实例地址来实现，而是通过向服务名发起请求调用实现。调用方需要向服务注册中心咨询某一个服务， 并获取该服务的所有实例清单。</p><p>比如，服务C调用服务A，服务C就需要向注册中心发起咨询请求，服务C获得了服务A的可用位置。</p></li></ul><h3 id="二、Eureka"><a href="#二、Eureka" class="headerlink" title="二、Eureka"></a>二、Eureka</h3><h4 id="1、Eureka介绍"><a href="#1、Eureka介绍" class="headerlink" title="1、Eureka介绍"></a>1、Eureka介绍</h4><p><code>Spring Cloud Eureka</code> 是<code>Spring Cloud Netflix</code> 微服务套件中的一部分。</p><p><code>Spring Cloud Eureka</code>，使用<code>Netflix Eureka</code>来实现注册与发现，它既包含了服务端组件，也包含客户端组件。</p><ul><li><p>服务端</p><p>服务注册中心。管理所有的服务。</p><ol><li>可以对所有的微服务的信息进行存储，如微服务的名称，IP，端口等</li><li>可以在进行服务调用时通过服务发现查询可用的微服务列表及网络地址进行服务调用</li><li>可以对所有的微服务进行心跳检测。</li></ol></li><li><p>客户端</p><p>处理服务的注册与发现。</p><p>在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务。</p></li></ul><p>在Eureka服务治理体系中，有三个核心角色：注册中心，服务提供者，服务消费者。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707123041.png" alt="服务治理机制"></p><h4 id="2、Eureka实例"><a href="#2、Eureka实例" class="headerlink" title="2、Eureka实例"></a>2、Eureka实例</h4><h5 id="2-1、Eureka服务端"><a href="#2-1、Eureka服务端" class="headerlink" title="2.1、Eureka服务端"></a>2.1、Eureka服务端</h5><h6 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入 eureka server依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--全局管理springcloud版本,并不会引入具体依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Brixton.SR5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="properties文件"><a href="#properties文件" class="headerlink" title="properties文件"></a>properties文件</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">1111</span><br><span class="hljs-attr">eureka.instance.hostname</span>=<span class="hljs-string">localhost</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 关闭Eureka自己注册自己</span><br><span class="hljs-attr">eureka.client.register-with-eureka</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">eureka.client.fetch-registry</span>=<span class="hljs-string">false</span><br><br><span class="hljs-attr">eureka.client.service-url.defaultZone</span>=<span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><h6 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaServerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h6><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210706184602.png" alt="Eureka"></p><h5 id="2-2、Eureka客户端"><a href="#2-2、Eureka客户端" class="headerlink" title="2.2、Eureka客户端"></a>2.2、Eureka客户端</h5><h6 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入eureka client--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="properties文件-1"><a href="#properties文件-1" class="headerlink" title="properties文件"></a>properties文件</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8888</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">eurekaclient</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 注册中心</span><br><span class="hljs-attr">eureka.client.service-url.defaultZone</span>=<span class="hljs-string">http://localhost:1111/eureka</span><br></code></pre></td></tr></table></figure><h6 id="添加注解-1"><a href="#添加注解-1" class="headerlink" title="添加注解"></a>添加注解</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaClientApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaClientApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h6><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210706185234.png" alt="成功注册服务"></p><h4 id="3、高可用注册中心"><a href="#3、高可用注册中心" class="headerlink" title="3、高可用注册中心"></a>3、高可用注册中心</h4><p>​在微服务架构这样的分布式环境中，我们需要充分考虑发生故障的情况，所以在生产环境中必须对各个组件进行<strong>高可用部署</strong>。</p><p>​Eureka Server 的设计一开始就考虑了高可用问题。在Eureka的服务治理设计中，所有节点即是服务提供方，也是服务消费方，服务注册中心也不例外。</p><p>​是否还记得在单节点的配置中，我们设置过下面的两个参数，让服务注册中心不注册自己。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">eureka.client.register-with-eureka</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">eureka.client.fetch-registry</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><p>​ Eureka Server的高可用实际上就是<strong>将自己作为服务向其他服务注册中心注册自己</strong>，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 1.创建application-peer1.properties,作为peer1服务中心的配置，并将serviceUrl指向peer2</span><br><span class="hljs-attr">spring.application.name</span> = <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">server.port</span> = <span class="hljs-string">1111</span><br><br><span class="hljs-attr">eureka.instance.hostname</span> = <span class="hljs-string">peer1</span><br><span class="hljs-attr">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://peer2:1112/eureka/</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 2.创建application-peer2.properties,作为peer2服务中心的配置，并将serviceUrl指向peer1</span><br><span class="hljs-attr">spring.application.name</span> = <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">server.port</span> = <span class="hljs-string">1112</span><br><br><span class="hljs-attr">eureka.instance.hostname</span> = <span class="hljs-string">peer2</span><br><span class="hljs-attr">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://peer1:1111/eureka/</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707135750.png" alt="server1"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707135754.png" alt="server2"></p><h4 id="4、Eureka停止更新"><a href="#4、Eureka停止更新" class="headerlink" title="4、Eureka停止更新"></a>4、Eureka停止更新</h4><p>在1.x版本项目还是活跃的,但是在2.x版本中停止维护。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707140031.png" alt="image-20210707140029011"></p><h3 id="三、Consul"><a href="#三、Consul" class="headerlink" title="三、Consul"></a>三、Consul</h3><p><a href="https://www.consul.io/">https://www.consul.io</a></p><h4 id="1、Consul简介"><a href="#1、Consul简介" class="headerlink" title="1、Consul简介"></a>1、Consul简介</h4><p>​Consul是一个可以提供服务发现，健康检查，多数据中心，Key&#x2F;Value存储等功能的分布式服务框架，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、Windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署。</p><p>安装Consul：<a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a></p><p>启动Consul服务：<code>consul agent -dev</code></p><p>访问consul的web服务端口：<code>http://localhost:8500</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707140542.png" alt="consul web页面"></p><h4 id="2、开发Consul客户端"><a href="#2、开发Consul客户端" class="headerlink" title="2、开发Consul客户端"></a>2、开发Consul客户端</h4><h5 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入consul依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--这个包是用做健康度监控的--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--全局管理springcloud版本,并不会引入具体依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="properties文件-2"><a href="#properties文件-2" class="headerlink" title="properties文件"></a>properties文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8888</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">client</span><br><span class="hljs-attr">spring.cloud.consul.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.cloud.consul.port</span>=<span class="hljs-string">8500</span><br></code></pre></td></tr></table></figure><h5 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210707141546.png" alt="Consul web"></p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息中间件的设计</title>
    <link href="/2021/07/09/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/07/09/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="消息中间件的设计"><a href="#消息中间件的设计" class="headerlink" title="消息中间件的设计"></a>消息中间件的设计</h2><h3 id="一、什么是消息中间件"><a href="#一、什么是消息中间件" class="headerlink" title="一、什么是消息中间件"></a>一、什么是消息中间件</h3><p>消息中间件的运用</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709192314.png" alt="消息中间件实例"></p><p>上图是一个基于消息中间件的分布式系统架构。</p><p>用户想要实现某种功能，比如注册、创建订单、支付等。并没有通过前台系统直接去调用其他的子系统。而是将这个请求包装成消息和数据，暂时存放在消息中间件中。而其他子系统接受到这些消息后会去处理对应的请求。</p><p>好处：</p><p><strong>解决系统之间的耦合。</strong>我们并没有实现系统与系统之间的直接调用。而是通过中间件的转换。</p><p>因此，什么是消息中间件：</p><ol><li>利用可靠的消息传递机制进行<em><strong>平台无关</strong>的</em>*数据交流**。</li><li><strong>基于数据和消息</strong>来进行分布式系统的集成。</li><li>通过提供消息传递和消息排队模型，它可以在分布式环境下扩展<strong>进程间的通信</strong>。</li></ol><p>应用场景：</p><p>跨系统数据传递、高并发流量削峰、数据异步处理……</p><p>常见的消息中间件：</p><p><code>ActiveMQ</code>、<code>RabbitMQ</code>、<code>kafka</code>、<code>RocketMQ</code>……</p><h3 id="二、消息中间件核心设计"><a href="#二、消息中间件核心设计" class="headerlink" title="二、消息中间件核心设计"></a>二、消息中间件核心设计</h3><p>本质：</p><p><strong>一种具备接受请求、保存数据、发送数据等功能的网络应用。</strong></p><p>和其他的应用程序不同，消息中间件不会去处理复杂的业务逻辑，因此，它的效率会更高。</p><p>消息中间件的核心：</p><ul><li>协议</li><li>持久化机制</li><li>消息分发机制</li><li>高可用、好可靠设计</li></ul><h4 id="1、协议"><a href="#1、协议" class="headerlink" title="1、协议"></a>1、协议</h4><p>协议是：计算机之间通信时共同遵从的一组约定，都遵守相同的约定，计算机之间才能交流。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">协议的三要素：<br><span class="hljs-bullet">1.</span> 语法：数据与控制信息的结构或格式<br><span class="hljs-bullet">2.</span> 语义：需要发出何种控制信息，完成何种动作以及做出何种响应<br><span class="hljs-bullet">3.</span> 时序：事件实现顺序的详细说明<br></code></pre></td></tr></table></figure><p>常用的消息中间件协议：</p><p><code>OpenWire</code>、<code>AMQP</code>、<code>MQTT</code>、<code>Kafka</code>、<code>OpenMassage</code></p><p>为什么不使用HTTP协议呢？</p><p>HTTP语法中规定了太多的请求头、响应头等。这对于消息中间件来说是不需要的。影响数据传输效率。</p><h4 id="2、持久化"><a href="#2、持久化" class="headerlink" title="2、持久化"></a>2、持久化</h4><p>就是将数据存入磁盘中，如果在内存中，服务重启就会消失。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709195642.png" alt="持久化"></p><p>常见的持久化机制有两种：存储在文件中、存储在数据库中</p><p>不同的消息中间件支持不同的持久化机制。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709195834.png" alt="常见的持久化机制"></p><h4 id="4、消息分发"><a href="#4、消息分发" class="headerlink" title="4、消息分发"></a>4、消息分发</h4><p>场景一：消息中间件需要将消息<strong>正确的发送</strong>到子系统中。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709200218.png" alt="消息分发场景1"></p><p>场景二：消息中间件在业务逻辑失败后可以<strong>重新发送</strong>。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709200413.png" alt="消息分发场景2"></p><p>常见消息中间件的发送策略：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709200608.png" alt="发送策略"></p><h4 id="5、高可用"><a href="#5、高可用" class="headerlink" title="5、高可用"></a>5、高可用</h4><p>高可用是指：<strong>产品在规定的条件和规定的时刻内处于可执行规定功能状态的能力。</strong></p><p>因此：</p><p>当业务量大时，一台消息中间件服务器可能无法满足需求，所以需要消息中间件<strong>集群部署</strong>。</p><p>问题：和<code>MySQL</code>、<code>Redis</code>等集群一样，这些都是存放数据的。这时候需要考虑数据共享的问题了。</p><p>解决方法一：基于主从<strong>共享</strong>数据的部署方式</p><p>客户端将数据存放在主服务器中，然后数据就会存放在文件系统中，而其他的从服务器想要得到数据，就从文件系统中读取。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709201317.png" alt="主从部署"></p><p>解决方法二：基于主从<strong>同步</strong>的部署方式</p><p>生产者发送数据到中间件，消息会同步到其他的中间件上。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709201609.png" alt="同步部署"></p><p>解决方法三：多主集群转发部署方式</p><p>消息中间件的集群之间知道消费者想要的数据在哪里，通过中间件之间转发，发送给消费者。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210709202207.png" alt="多主集群"></p><h4 id="6、高可靠"><a href="#6、高可靠" class="headerlink" title="6、高可靠"></a>6、高可靠</h4><p>高可靠是指：系统可以无故障地持续运行。比如一个系统从来不崩溃、报错或者概率很低。</p><p>消息中间件中的高可靠：</p><ul><li>消息传输可靠：协议来保证系统间数据解析的正确性</li><li>消息存储可靠：持久化保证存储可靠性</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现 -- 链表</title>
    <link href="/2021/07/05/Redis%E5%AE%9E%E7%8E%B0-%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/07/05/Redis%E5%AE%9E%E7%8E%B0-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Redis实现-–-链表"><a href="#Redis实现-–-链表" class="headerlink" title="Redis实现 – 链表"></a>Redis实现 – 链表</h2><h3 id="一、链表的特点"><a href="#一、链表的特点" class="headerlink" title="一、链表的特点"></a>一、链表的特点</h3><p>链表作为一种常用的数据结构，链表内置在许多的高级语言中，比如Java中：<code>LinkedList</code>等集合类工具。</p><p>链表是一种线性表，和数组不同的是，他不能随机访问结点，只能顺序的访问。同时它可以通过增删结点来灵活地调整链表的长度。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210705133959.png" alt="链表结构"></p><h3 id="二、Redis中的链表"><a href="#二、Redis中的链表" class="headerlink" title="二、Redis中的链表"></a>二、Redis中的链表</h3><p>C语言中没有设计这种数据结构，因此Redis构建了自己的链表实现。</p><h4 id="1、链表的实现"><a href="#1、链表的实现" class="headerlink" title="1、链表的实现"></a>1、链表的实现</h4><p>源代码在<code>adlist.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结点信息</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-comment">// 后置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-type">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><p>可以看到，这是一个双向链表。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210705134653.png" alt="image-20210705134653786"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链表信息</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br><br>    <span class="hljs-comment">// 表头节点</span><br>    listNode *head;<br><br>    <span class="hljs-comment">// 表尾节点</span><br>    listNode *tail;<br><br>    <span class="hljs-comment">// 节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br><br>    <span class="hljs-comment">// 节点值释放函数</span><br>    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br><br>    <span class="hljs-comment">// 节点值对比函数</span><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br><br>    <span class="hljs-comment">// 链表所包含的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br><br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><p>同时，Redis还设计了一个<code>list</code>结构，为链表提供了表头指针<code>head</code>，表尾指针<code>tail</code>，链表长度<code>len</code>，还提供了一些特定的函数。</p><ul><li><code>dup</code>：用于复制链表结点所保存的值</li><li><code>free</code>：用于释放链表结点所保存的值</li><li><code>match</code>：用于对比链表结点所保存的值和另一个输入值是否相等</li></ul><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210705140425.png" alt="链表结构"></p><p>Redis中定义了一些宏函数，这些函数都是Redis中链表的核心操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回给定链表所包含的节点数量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listLength(l) ((l)-&gt;len)</span><br><br><span class="hljs-comment">// 返回给定链表的表头节点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listFirst(l) ((l)-&gt;head)</span><br><br><span class="hljs-comment">// 返回给定链表的表尾节点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listLast(l) ((l)-&gt;tail)</span><br><br><span class="hljs-comment">// 返回给定节点的前置节点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span><br><br><span class="hljs-comment">// 返回给定节点的后置节点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span><br><br><span class="hljs-comment">// 返回给定节点的值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span><br><br><span class="hljs-comment">// 将链表 l 的值复制函数设置为 m</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span><br><br><span class="hljs-comment">// 将链表 l 的值释放函数设置为 m</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span><br><br><span class="hljs-comment">// 将链表的对比函数设置为 m</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span><br><br><span class="hljs-comment">// 返回给定链表的值复制函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span><br><br><span class="hljs-comment">// 返回给定链表的值释放函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span><br><br><span class="hljs-comment">// 返回给定链表的值对比函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span><br></code></pre></td></tr></table></figure><h4 id="2、Redis中的链表特点"><a href="#2、Redis中的链表特点" class="headerlink" title="2、Redis中的链表特点"></a>2、Redis中的链表特点</h4><ol><li>双向链表：结点中带有<code>prev</code>和<code>next</code>指针。</li><li>不是循环链表：表头指针的<code>prev</code>指向<code>null</code>，表尾指针的<code>next</code>指向<code>null</code>。</li><li>List结构：list结构中有len，head，tail等属性。</li><li>多态：链表结点使用<code>void*</code>指针来保存节点值，并且可以通过list结构的<code>dup、free、match</code>三个属性为结点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ol><h3 id="三、Redis中链表源码"><a href="#三、Redis中链表源码" class="headerlink" title="三、Redis中链表源码"></a>三、Redis中链表源码</h3><h4 id="1、创建一个新的链表"><a href="#1、创建一个新的链表" class="headerlink" title="1、创建一个新的链表"></a>1、创建一个新的链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建一个新的链表</span><br><span class="hljs-built_in">list</span> *<span class="hljs-title function_">listCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> *<span class="hljs-title">list</span>;</span><br><br>    <span class="hljs-comment">// 分配内存</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">list</span> = zmalloc(<span class="hljs-keyword">sizeof</span>(*<span class="hljs-built_in">list</span>))) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 初始化属性</span><br>    <span class="hljs-built_in">list</span>-&gt;head = <span class="hljs-built_in">list</span>-&gt;tail = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">list</span>-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">list</span>-&gt;dup = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">list</span>-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">list</span>-&gt;match = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、添加结点到表尾"><a href="#2、添加结点到表尾" class="headerlink" title="2、添加结点到表尾"></a>2、添加结点到表尾</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将一个包含有给定值指针 value 的新节点添加到链表的表尾</span><br><span class="hljs-built_in">list</span> *<span class="hljs-title function_">listAddNodeTail</span><span class="hljs-params">(<span class="hljs-built_in">list</span> *<span class="hljs-built_in">list</span>, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    listNode *node;<br><br>    <span class="hljs-comment">// 为新节点分配内存</span><br>    <span class="hljs-keyword">if</span> ((node = zmalloc(<span class="hljs-keyword">sizeof</span>(*node))) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 保存值指针</span><br>    node-&gt;value = value;<br><br>    <span class="hljs-comment">// 目标链表为空</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">list</span>-&gt;head = <span class="hljs-built_in">list</span>-&gt;tail = node;<br>        node-&gt;prev = node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 目标链表非空</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;prev = <span class="hljs-built_in">list</span>-&gt;tail;<br>        node-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">list</span>-&gt;tail-&gt;next = node;<br>        <span class="hljs-built_in">list</span>-&gt;tail = node;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新链表节点数</span><br>    <span class="hljs-built_in">list</span>-&gt;len++;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、添加结点到表头"><a href="#3、添加结点到表头" class="headerlink" title="3、添加结点到表头"></a>3、添加结点到表头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将一个包含有给定值指针 value 的新节点添加到链表的表头</span><br><span class="hljs-built_in">list</span> *<span class="hljs-title function_">listAddNodeHead</span><span class="hljs-params">(<span class="hljs-built_in">list</span> *<span class="hljs-built_in">list</span>, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    listNode *node;<br><br>    <span class="hljs-comment">// 为节点分配内存</span><br>    <span class="hljs-keyword">if</span> ((node = zmalloc(<span class="hljs-keyword">sizeof</span>(*node))) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 保存值指针</span><br>    node-&gt;value = value;<br><br>    <span class="hljs-comment">// 添加节点到空链表</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">list</span>-&gt;head = <span class="hljs-built_in">list</span>-&gt;tail = node;<br>        node-&gt;prev = node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 添加节点到非空链表</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        node-&gt;next = <span class="hljs-built_in">list</span>-&gt;head;<br>        <span class="hljs-built_in">list</span>-&gt;head-&gt;prev = node;<br>        <span class="hljs-built_in">list</span>-&gt;head = node;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新链表节点数</span><br>    <span class="hljs-built_in">list</span>-&gt;len++;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、释放整个链表"><a href="#4、释放整个链表" class="headerlink" title="4、释放整个链表"></a>4、释放整个链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">listRelease</span><span class="hljs-params">(<span class="hljs-built_in">list</span> *<span class="hljs-built_in">list</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>    listNode *current, *next;<br><br>    <span class="hljs-comment">// 指向头指针</span><br>    current = <span class="hljs-built_in">list</span>-&gt;head;<br>    <span class="hljs-comment">// 遍历整个链表</span><br>    len = <span class="hljs-built_in">list</span>-&gt;len;<br>    <span class="hljs-keyword">while</span>(len--) &#123;<br>        next = current-&gt;next;<br><br>        <span class="hljs-comment">// 如果有设置值释放函数，那么调用它</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;<span class="hljs-built_in">free</span>) <span class="hljs-built_in">list</span>-&gt;<span class="hljs-built_in">free</span>(current-&gt;value);<br>        <span class="hljs-comment">// 释放节点结构</span><br>        zfree(current);<br>        current = next;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放链表结构</span><br>    zfree(<span class="hljs-built_in">list</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、删除给定结点"><a href="#5、删除给定结点" class="headerlink" title="5、删除给定结点"></a>5、删除给定结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">listDelNode</span><span class="hljs-params">(<span class="hljs-built_in">list</span> *<span class="hljs-built_in">list</span>, listNode *node)</span><br>&#123;<br>    <span class="hljs-comment">// 调整前置节点的指针</span><br>    <span class="hljs-keyword">if</span> (node-&gt;prev)<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">list</span>-&gt;head = node-&gt;next;<br><br>    <span class="hljs-comment">// 调整后置节点的指针</span><br>    <span class="hljs-keyword">if</span> (node-&gt;next)<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">list</span>-&gt;tail = node-&gt;prev;<br><br>    <span class="hljs-comment">// 释放值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;<span class="hljs-built_in">free</span>) <span class="hljs-built_in">list</span>-&gt;<span class="hljs-built_in">free</span>(node-&gt;value);<br><br>    <span class="hljs-comment">// 释放节点</span><br>    zfree(node);<br><br>    <span class="hljs-comment">// 链表数减一</span><br>    <span class="hljs-built_in">list</span>-&gt;len--;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、创建一个迭代器"><a href="#6、创建一个迭代器" class="headerlink" title="6、创建一个迭代器"></a>6、创建一个迭代器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//为给定链表创建一个迭代器，</span><br><span class="hljs-comment">//之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</span><br>listIter *<span class="hljs-title function_">listGetIterator</span><span class="hljs-params">(<span class="hljs-built_in">list</span> *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> direction)</span><br>&#123;<br>    <span class="hljs-comment">// 为迭代器分配内存</span><br>    listIter *iter;<br>    <span class="hljs-keyword">if</span> ((iter = zmalloc(<span class="hljs-keyword">sizeof</span>(*iter))) == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 根据迭代方向，设置迭代器的起始节点</span><br>    <span class="hljs-keyword">if</span> (direction == AL_START_HEAD)<br>        iter-&gt;next = <span class="hljs-built_in">list</span>-&gt;head;<br>    <span class="hljs-keyword">else</span><br>        iter-&gt;next = <span class="hljs-built_in">list</span>-&gt;tail;<br><br>    <span class="hljs-comment">// 记录迭代方向</span><br>    iter-&gt;direction = direction;<br><br>    <span class="hljs-keyword">return</span> iter;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、返回迭代器当前所指向的节点"><a href="#7、返回迭代器当前所指向的节点" class="headerlink" title="7、返回迭代器当前所指向的节点"></a>7、返回迭代器当前所指向的节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//返回迭代器当前所指向的节点</span><br><span class="hljs-comment">//删除当前节点是允许的，但不能修改链表里的其他节点。</span><br>listNode *<span class="hljs-title function_">listNext</span><span class="hljs-params">(listIter *iter)</span><br>&#123;<br>    listNode *current = iter-&gt;next;<br><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 根据方向选择下一个节点</span><br>        <span class="hljs-keyword">if</span> (iter-&gt;direction == AL_START_HEAD)<br>            <span class="hljs-comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span><br>            iter-&gt;next = current-&gt;next;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span><br>            iter-&gt;next = current-&gt;prev;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> current;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8、复制整个链表"><a href="#8、复制整个链表" class="headerlink" title="8、复制整个链表"></a>8、复制整个链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//复制成功返回输入链表的副本，</span><br><span class="hljs-comment">//如果因为内存不足而造成复制失败，返回 NULL 。</span><br><span class="hljs-comment">//如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，</span><br><span class="hljs-comment">//否则，新节点将和旧节点共享同一个指针。</span><br><span class="hljs-built_in">list</span> *<span class="hljs-title function_">listDup</span><span class="hljs-params">(<span class="hljs-built_in">list</span> *orig)</span><br>&#123;<br>    <span class="hljs-built_in">list</span> *copy;<br>    listIter *iter;<br>    listNode *node;<br><br>    <span class="hljs-comment">// 创建新链表</span><br>    <span class="hljs-keyword">if</span> ((copy = listCreate()) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 设置节点值处理函数</span><br>    copy-&gt;dup = orig-&gt;dup;<br>    copy-&gt;<span class="hljs-built_in">free</span> = orig-&gt;<span class="hljs-built_in">free</span>;<br>    copy-&gt;match = orig-&gt;match;<br><br>    <span class="hljs-comment">// 迭代整个输入链表</span><br>    iter = listGetIterator(orig, AL_START_HEAD);<br>    <span class="hljs-keyword">while</span>((node = listNext(iter)) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">void</span> *value;<br><br>        <span class="hljs-comment">// 复制节点值到新节点</span><br>        <span class="hljs-keyword">if</span> (copy-&gt;dup) &#123;<br>            value = copy-&gt;dup(node-&gt;value);<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">NULL</span>) &#123;<br>                listRelease(copy);<br>                listReleaseIterator(iter);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span><br>            value = node-&gt;value;<br><br>        <span class="hljs-comment">// 将节点添加到链表</span><br>        <span class="hljs-keyword">if</span> (listAddNodeTail(copy, value) == <span class="hljs-literal">NULL</span>) &#123;<br>            listRelease(copy);<br>            listReleaseIterator(iter);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放迭代器</span><br>    listReleaseIterator(iter);<br><br>    <span class="hljs-comment">// 返回副本</span><br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现 -- 动态字符串</title>
    <link href="/2021/07/05/Redis%E5%AE%9E%E7%8E%B0-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/07/05/Redis%E5%AE%9E%E7%8E%B0-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="简单的动态字符串"><a href="#简单的动态字符串" class="headerlink" title="简单的动态字符串"></a>简单的动态字符串</h2><h3 id="一、C语言中的字符串"><a href="#一、C语言中的字符串" class="headerlink" title="一、C语言中的字符串"></a>一、C语言中的字符串</h3><p>字符串是一种非常重要的数据类型，在Java中，有专门的数据类型来表示字符串。比如<code>String</code>类型、<code>StringBuffer</code>类型等。但是在C语言中不存在显示的字符串类型，都是以<strong>字符串常量的形式出现或存储在字符数组</strong>中。</p><h4 id="1、字符串常量"><a href="#1、字符串常量" class="headerlink" title="1、字符串常量"></a>1、字符串常量</h4><p>所谓的字符串常量，就是：<strong>以’&#x2F;0’结尾的多个字符组成的序列。字符串常量是不可被修改的。</strong></p><p>比如：”Hello world”，””，”字符串”。</p><p>字符串常量可以为空，但是依旧会存在终止符”&#x2F;0”。</p><p>前面说过，C语言中不能直接进行字符串赋值。因此在C语言中，<strong>通常声明一个指向char类型的指针并将其初始化为一个字符串常量的方式来访问一个字符串。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//声明一个指向char类型的指针</span><br><span class="hljs-type">char</span> *name = <span class="hljs-string">&quot;Jiang Zhwiei&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="2、字符数组"><a href="#2、字符数组" class="headerlink" title="2、字符数组"></a>2、字符数组</h4><p>字符数组就是：<strong>char类型的数组。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> charArray[] = &#123;<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;Z&#x27;</span>,<span class="hljs-string">&#x27;W&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码，声明并且初始化了一个字符数组。数组的长度是4，因为会自动添加’\0’。</p><p>我们可以简化上述的字符串初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> charArray = <span class="hljs-string">&quot;JZW&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="二、Redis中的字符串"><a href="#二、Redis中的字符串" class="headerlink" title="二、Redis中的字符串"></a>二、Redis中的字符串</h3><p>在Redis中，没有直接使用C语言中传统的字符串。而是自己构建了一种名为<strong>简单动态字符串</strong>（Simple Dynamic String，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。</p><h4 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h4><p>在源文件<code>sds.h</code>中有SDS的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">// 记录buf数组中已使用字节的数量</span><br>    <span class="hljs-comment">// 等于SDS所保存字符串的长度</span><br>    <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-comment">// 记录buf数组中未使用字节数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br><br>    <span class="hljs-comment">// 字节数组   用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210703130931.png" alt="SDS示例"></p><p>上图中是一个SDS字符串的实例。</p><p>buf[] 记录了字符串的内容。数组的前五个是保存的字符，最后一个是结束符。</p><p>len 记录了SDS字符串的长度。当前记录了五个字节长度的字符串。</p><p>free 记录了SDS中还未分配空间。当前还未分配字符的空间未0。</p><p>SDS遵循了C语言串以空字符结尾的惯例。并且最后的’\0’没有记录在len属性中。</p><p>这个空字符’\0’对于SDS来说是透明的。因此关于这个空字符的操作都是由SDS函数自动完成的。比如：添加空字符到字符串末尾、未空字符分配额外的1字节空间。</p><h3 id="三、SDS与C字符串的区别"><a href="#三、SDS与C字符串的区别" class="headerlink" title="三、SDS与C字符串的区别"></a>三、SDS与C字符串的区别</h3><h4 id="1、常量复杂度获取字符串长度"><a href="#1、常量复杂度获取字符串长度" class="headerlink" title="1、常量复杂度获取字符串长度"></a>1、常量复杂度获取字符串长度</h4><p>在C语言字符串中并不记录自身的长度。因此为了获取C字符串的长度，就必须遍历整个字符串。**时间复杂度是O(N)**。</p><p>与C字符串不同，因为SDS在len属性中记录了SDS本身的长度。时间复杂度是O(1)。设置和更新SDS长度的工作是由SDS的API在执行时自动完成的。使用SDS无须无需进行任何手动修改长度的工作。</p><h4 id="2、杜绝缓冲区溢出"><a href="#2、杜绝缓冲区溢出" class="headerlink" title="2、杜绝缓冲区溢出"></a>2、杜绝缓冲区溢出</h4><p>在C字符串不记录自身长度带来的另一个问题就是缓冲区溢出。</p><p>在C语言库函数中，有字符串拼接函数，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210703134032.png" alt="在内存中的两个字符串"></p><p>此时如果执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">strcat</span>(s1,<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><p>因为<code>s1</code>中缓冲区长度不够，那么就会出现溢出。就会覆盖<code>s2</code>的内容。</p><p>对于SDS来说，因为记录了缓冲区的长度。因此在执行拼接操作之前，会<strong>检查给定的SDS的空间是否足够。</strong> 在之后的API中我们可以具体来查看源码。</p><h4 id="3、减少修改字符串时带来的内存重分配次数"><a href="#3、减少修改字符串时带来的内存重分配次数" class="headerlink" title="3、减少修改字符串时带来的内存重分配次数"></a>3、减少修改字符串时带来的内存重分配次数</h4><h5 id="C语言中的重分配"><a href="#C语言中的重分配" class="headerlink" title="C语言中的重分配"></a>C语言中的重分配</h5><p>C语言不记录字符串长度，因此在增长或缩短一个字符串时，程序总是会对保存这个C字符串的数组进行一个内存的重分配操作。</p><ul><li>如果程序执行的是增长字符串的操作。比如拼接操作(append)。那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小。否则会出现缓冲区溢出。</li><li>如果程序执行的是缩短字符串的操作。比如截断操作(trim)。那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间。否则会出现内存泄漏。</li></ul><p>Redis作为数据库，速度要求严苛，数据修改频繁。如果每次修改字符串的长度都需要执行一次内存重分配的话，会对性能会造成影响。</p><h5 id="Redis中的改进"><a href="#Redis中的改进" class="headerlink" title="Redis中的改进"></a>Redis中的改进</h5><p>因此，为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联。在SDS中，buf数组长度不一定是字符数量加1。<strong>数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。</strong></p><ol><li><p>空间预分配</p><p>空间预分配用于优化SDS的字符串增长操作，当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间。</p><p>SDS额外分配未使用空间数量由以下公式来决定：</p><ul><li><p>如果修改SDS之后的长度小于1 MB。那么程序分配和len属性同样大小的未使用空间。这是SDS中len属性和free属性的值相同。</p><p>比如：如果进行修改之后，SDS的len属性变成了13字节，那么程序也会分配13字节的未使用空间。此时SDS的buf[]数组的长度将变成27字节(13 B + 13 B + 1 B)。</p></li><li><p>如果修改SDS之后的长度大于1 MB。那么程序会分配1 MB的未使用空间。</p><p>如果：如果进行修改之后，SDS的len变成30 MB，那么程序会分配1 MB的未使用空间。此时buf[]数组中的长度将变成30 MB+1 MB+1 B。</p></li></ul></li></ol><p>​通过这种方式，SDS会先检查未使用空间是否足够，<strong>如果足够的话，API就会直接使用未使用空间，而无需执行内存重分配。</strong></p><p>​<strong>通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</strong></p><ol start="2"><li><p>惰性空间释放</p><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是<strong>使用free属性将这些字节的数量记录起来，并等待将来使用。</strong></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210703155342.png" alt="执行sdstrim之前"></p><p>移除SDS字符串中所有的’B’字符。</p><p>如果执行sdstrim(s,”B”);</p></li></ol><p>​<img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210703155641.png" alt="image-20210703155641507"></p><p>​执行sdstrim之后的SDS并没有释放出来1个字节。而是将这1字节空间作为未使用空间保留在SDS里面。</p><p>​同时，SDS也提供了相应的API，让我们可以在有需要时，真正地释放SDS的未使用空间，所以不要担心惰性空间释放策略会造成内存浪费。</p><h4 id="4、二进制安全"><a href="#4、二进制安全" class="headerlink" title="4、二进制安全"></a>4、二进制安全</h4><p>什么是二进制安全？</p><p>二进制安全是一种主要用于字符串操作函数相关的计算机编程术语。一个二进制安全的函数，其本质上将操作输入作为原始的、无任何特殊格式意义的数据流。对于每个字符都公平对待，不特殊处理某一个字符。</p><p>C语言中以’\0’为结束符。那么C字符串所用的函数只会识别出其中的<code>&quot;ACD&quot;</code>，而忽略<code>&quot;ABC&quot;</code>。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210703161956.png" alt="image-20210703161956935"></p><p>对于Redis来说：</p><p>SDS的API都是二进制安全的。所有的SDS API 都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据进行任何的过滤和限制。</p><h4 id="5、兼容部分C字符串函数"><a href="#5、兼容部分C字符串函数" class="headerlink" title="5、兼容部分C字符串函数"></a>5、兼容部分C字符串函数</h4><p>虽然SDS的API都是二进制安全的，但他们一样遵循C字符串以空字符结尾的惯例。</p><p>因此SDS可以重用一部分<code>&lt;String.h&gt;</code>库定义的函数。</p><h3 id="四、SDS-API"><a href="#四、SDS-API" class="headerlink" title="四、SDS API"></a>四、SDS API</h3><p>在源代码中，<code>sds.h  和  sds.c</code>中有声明和定义这些SDS API。</p><p>在下面的代码中，会大量出现这样的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> *<span class="hljs-title">sh</span> =</span> (<span class="hljs-type">void</span>*) (s-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr));<br></code></pre></td></tr></table></figure><p>sh是SDS的指针，而s是SDS中buf的指针。</p><p>我们通常在SDS函数中，使用的是s来记录SDS。这样可以方便去访问buf缓冲区，还可以轻松去得到SDS的地址。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210703171354.png" alt="结构"></p><h4 id="1、-创建一个-SDS"><a href="#1、-创建一个-SDS" class="headerlink" title="1、 创建一个 SDS"></a>1、 创建一个 SDS</h4><p><code>根据给定的初始化字符串 init 和字符串长度 initlen</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//init 字符串   initlen  字符串长度</span><br>sds <span class="hljs-title function_">sdsnewlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *init, <span class="hljs-type">size_t</span> initlen)</span> &#123;<br>    <span class="hljs-comment">//声明sds变量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> *<span class="hljs-title">sh</span>;</span><br><br>    <span class="hljs-comment">// 根据是否有初始化内容，选择适当的内存分配方式</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    <span class="hljs-keyword">if</span> (init) &#123;<br>        <span class="hljs-comment">// zmalloc 不初始化所分配的内存</span><br>        sh = zmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr)+initlen+<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// zcalloc 将分配的内存全部初始化为 0</span><br>        sh = zcalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr)+initlen+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 内存分配失败，返回</span><br>    <span class="hljs-keyword">if</span> (sh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 设置初始化长度</span><br>    sh-&gt;len = initlen;<br>    <span class="hljs-comment">// 新 sds 不预留任何空间</span><br>    sh-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    <span class="hljs-keyword">if</span> (initlen &amp;&amp; init)<br>        <span class="hljs-built_in">memcpy</span>(sh-&gt;buf, init, initlen);<br>    <span class="hljs-comment">// 以 \0 结尾</span><br>    sh-&gt;buf[initlen] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 返回 buf 部分，而不是整个 sdshdr</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>*)sh-&gt;buf;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、释放SDS"><a href="#2、释放SDS" class="headerlink" title="2、释放SDS"></a>2、释放SDS</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sdsfree</span><span class="hljs-params">(sds s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    zfree(s-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、重置SDS内容"><a href="#3、重置SDS内容" class="headerlink" title="3、重置SDS内容"></a>3、重置SDS内容</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sdsclear</span><span class="hljs-params">(sds s)</span> &#123;<br><br>    <span class="hljs-comment">// 取出 sdshdr</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> *<span class="hljs-title">sh</span> =</span> (<span class="hljs-type">void</span>*) (s-(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr)));<br><br>    <span class="hljs-comment">// 重新计算属性</span><br>    sh-&gt;<span class="hljs-built_in">free</span> += sh-&gt;len;<br>    sh-&gt;len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将结束符放到最前面（相当于惰性地删除 buf 中的内容）</span><br>    sh-&gt;buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、扩展SDS长度"><a href="#4、扩展SDS长度" class="headerlink" title="4、扩展SDS长度"></a>4、扩展SDS长度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDS_MAX_PREALLOC (1024*1024)</span><br><br>sds <span class="hljs-title function_">sdsMakeRoomFor</span><span class="hljs-params">(sds s, <span class="hljs-type">size_t</span> addlen)</span> &#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> *<span class="hljs-title">sh</span>, *<span class="hljs-title">newsh</span>;</span><br><br>    <span class="hljs-comment">// 获取 s 目前的空余空间长度</span><br>    <span class="hljs-type">size_t</span> <span class="hljs-built_in">free</span> = sdsavail(s);<br><br>    <span class="hljs-type">size_t</span> len, newlen;<br><br>    <span class="hljs-comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &gt;= addlen) <span class="hljs-keyword">return</span> s;<br><br>    <span class="hljs-comment">// 获取 s 目前已占用空间的长度</span><br>    len = sdslen(s);<br>    sh = (<span class="hljs-type">void</span>*) (s-(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr)));<br><br>    <span class="hljs-comment">// s 最少需要的长度</span><br>    newlen = (len+addlen);<br><br>    <span class="hljs-comment">// 根据新长度，为 s 分配新空间所需的大小</span><br>    <span class="hljs-keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)<br>        <span class="hljs-comment">// 如果新长度小于 SDS_MAX_PREALLOC </span><br>        <span class="hljs-comment">// 那么为它分配两倍于所需长度的空间</span><br>        newlen *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span><br>        newlen += SDS_MAX_PREALLOC;<br>    <span class="hljs-comment">// T = O(N)</span><br>    newsh = zrealloc(sh, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr)+newlen+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 内存不足，分配失败，返回</span><br>    <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 更新 sds 的空余长度</span><br>    newsh-&gt;<span class="hljs-built_in">free</span> = newlen - len;<br><br>    <span class="hljs-comment">// 返回 sds</span><br>    <span class="hljs-keyword">return</span> newsh-&gt;buf;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、-追加字符串"><a href="#5、-追加字符串" class="headerlink" title="5、 追加字符串"></a>5、 追加字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">sds <span class="hljs-title function_">sdscatlen</span><span class="hljs-params">(sds s, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *t, <span class="hljs-type">size_t</span> len)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> *<span class="hljs-title">sh</span>;</span><br>    <br>    <span class="hljs-comment">// 原有字符串长度</span><br>    <span class="hljs-type">size_t</span> curlen = sdslen(s);<br><br>    <span class="hljs-comment">// 扩展 sds 空间</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    s = sdsMakeRoomFor(s,len);<br><br>    <span class="hljs-comment">// 内存不足？直接返回</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 复制 t 中的内容到字符串后部</span><br>    <span class="hljs-comment">// T = O(N)</span><br>    sh = (<span class="hljs-type">void</span>*) (s-(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sdshdr)));<br>    <span class="hljs-built_in">memcpy</span>(s+curlen, t, len);<br><br>    <span class="hljs-comment">// 更新属性</span><br>    sh-&gt;len = curlen+len;<br>    sh-&gt;<span class="hljs-built_in">free</span> = sh-&gt;<span class="hljs-built_in">free</span>-len;<br><br>    <span class="hljs-comment">// 添加新结尾符号</span><br>    s[curlen+len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 返回新 sds</span><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、对比两个SDS字符串是否相同"><a href="#6、对比两个SDS字符串是否相同" class="headerlink" title="6、对比两个SDS字符串是否相同"></a>6、对比两个SDS字符串是否相同</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//对比两个 sds ， strcmp 的 sds 版本</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sdscmp</span><span class="hljs-params">(<span class="hljs-type">const</span> sds s1, <span class="hljs-type">const</span> sds s2)</span> &#123;<br>    <span class="hljs-type">size_t</span> l1, l2, minlen;<br>    <span class="hljs-type">int</span> cmp;<br><br>    l1 = sdslen(s1);<br>    l2 = sdslen(s2);<br>    minlen = (l1 &lt; l2) ? l1 : l2;<br>    cmp = <span class="hljs-built_in">memcmp</span>(s1,s2,minlen);<br><br>    <span class="hljs-keyword">if</span> (cmp == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> l1-l2;<br><br>    <span class="hljs-keyword">return</span> cmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核体系结构</title>
    <link href="/2021/06/29/Linux%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2021/06/29/Linux%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Linux内核体系结构"><a href="#Linux内核体系结构" class="headerlink" title="Linux内核体系结构"></a>Linux内核体系结构</h2><h3 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h3><h4 id="操作系统的架构"><a href="#操作系统的架构" class="headerlink" title="操作系统的架构"></a>操作系统的架构</h4><p>一个完整的操作系统主要由四部分组成：硬件层、操作系统内核层、操作系统服务层和用户应用程序层。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210629225725.png" alt="操作系统结构"></p><p>用户应用程序层：是指那些字处理程序，Internet浏览器程序。以及一些用户自己编写的应用程序。</p><p>操作系统服务层：是指那些向用户提供的服务被看做时操作系统部分功能的程序。比如X窗口系统、shell命令解释系统以及内核编程接口等系统程序。</p><p>操作系统内核层：主要用于对硬件资源的抽象和访问调度。与硬件之间交互，实现对硬件部件的编程控制和接口操作。</p><h4 id="Linux内核模式"><a href="#Linux内核模式" class="headerlink" title="Linux内核模式"></a>Linux内核模式</h4><p>操作系统内核的结构模式主要分成整体式的单内核模式和层次式的微内核模式。</p><p>对于Linux 0.11内核，则是采用了单内核模式。</p><p>操作系统所提供服务的流程为：</p><ol><li><p>应用程序使用指定的参数值执行系统调用命令，使CPU从用户态切换为内核态。</p></li><li><p>然后操作系统根据具体的参数值调用特定的系统调用服务程序。</p></li><li><p>服务程序根据需要调用底层的一些支持函数完成特定的功能。</p></li><li><p>完成应用程序所要求的服务之后，操作系统又使CPU从核心态转换为用户态。</p></li></ol><p>因此，单内核也可粗略地分成三个层次：</p><ul><li>调用服务的主程序层</li><li>执行系统调用的服务层</li><li>支持系统调用的底层函数</li></ul><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210629225930.png" alt="单模式简单结构模型"></p><h3 id="二、Linux内核系统体系结构"><a href="#二、Linux内核系统体系结构" class="headerlink" title="二、Linux内核系统体系结构"></a>二、Linux内核系统体系结构</h3><p>Linux 内核主要由5个模式构成，分别是：进程调度模块、内存管理模块、文件系统模块、进程间通信模块和网络接口模块。</p><p><strong>进程调用模块：</strong>负责进程对CPU资源的使用。所采用的调度策略是各个进程能够公平合理地访问CPU，保证内核能及时地执行硬件操作。</p><p><strong>内存管理模块：</strong>用于确保进程能够安全地共享机器主内存区。同时，内存管理模块还支持<code>虚拟内存管理方式</code>。</p><p><strong>文件系统模块：</strong>用于支持对外部设备的驱动和存储。虚拟文件系统模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件设备的不同细节。</p><p><strong>进程间通信模块：</strong>用于支持多种进程间的信息交换方式。</p><p><strong>网络接口模块：</strong>提供对多种网络通信标准的访问并支持许多网络硬件。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210629232157.png" alt="Linux内核结构框图"></p><p>Linux 内核中各个模块之间存在依赖关系。比如：</p><p>所有的模块都与进程调度模块存在依赖关系。因为它们都需要依靠进程调度程序来挂起或重新运行它们的进程。</p><p>进程调度子系统需要使用内存管理来调整一特定进程所使用的物理内存空间。</p><p>进程间通信子系统需要依靠内存管理器来支持共享内存通信机制。</p><p>除了模块之间的依赖关系，所有的这些模块还会依赖于内核中的通用资源。这些资源包括内核所有子系统都会调用的内存分配和收回函数，打印警告或出错信息函数以及一些系统调试函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock的使用</title>
    <link href="/2021/06/15/ReentrantLock/"/>
    <url>/2021/06/15/ReentrantLock/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相对于synchronized，它具备的特点是：</p><ol><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ol><p>与synchronized一样，都支持可重入。</p><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//临界区</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">//释放锁</span><br>reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、ReentrantLock的特点"><a href="#1、ReentrantLock的特点" class="headerlink" title="1、ReentrantLock的特点"></a>1、ReentrantLock的特点</h3><h4 id="1、可重入"><a href="#1、可重入" class="headerlink" title="1、可重入"></a>1、可重入</h4><p>可重入是指：同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此由权力再次获取这把锁。</p><p>下面这个例子：主线程调用方法method1()，在method1中获取lock锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;方法1 执行&quot;</span>);<br>        method2();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;方法2 执行&quot;</span>);<br>        method3();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;方法3 执行&quot;</span>);<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method1();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210602222128.png" alt="image-20210602222121768"></p><h4 id="2、可打断"><a href="#2、可打断" class="headerlink" title="2、可打断"></a>2、可打断</h4><p><code>lock.lockInterruptibly()</code>方法。</p><p>如果没有竞争那么此方法就会获取lock对象锁。</p><p>如果有竞争就进入阻塞队列，<code>可以被其他线程用 interruput 方法打断。</code></p><p>下面这个例子：主线程先获取锁，t1线程进入阻塞队列。主线程执行中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;t1线程启动&quot;</span>);<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            lock.lockInterruptibly();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;等待的过程中被打断&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br><br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>    lock.lock();<br>    System.out.println(<span class="hljs-string">&quot;主线程获得了锁&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>        t1.interrupt();<br>        System.out.println(<span class="hljs-string">&quot;执行中断&quot;</span>);<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210602223017.png" alt="image-20210602223017282"></p><h4 id="3、-锁超时"><a href="#3、-锁超时" class="headerlink" title="3、 锁超时"></a>3、 锁超时</h4><p>当线程在尝试获取锁时，可能锁已经被其他线程占了。</p><p>这是我们可以设置一段时间，在这段时间内，线程可以获得锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;t1线程启动&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS))&#123;<br>                System.out.println(<span class="hljs-string">&quot;获取锁等待1s后失败,返回&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;t1线程获取锁&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>    lock.lock();<br>    System.out.println(<span class="hljs-string">&quot;主线程获取了锁&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-keyword">try</span>&#123;<br>        sleep(<span class="hljs-number">3000</span>);<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;主线程释放锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210602225851.png" alt="image-20210602225851021"></p><h4 id="4、公平锁"><a href="#4、公平锁" class="headerlink" title="4、公平锁"></a>4、公平锁</h4><p>ReentrantLock 默认是<strong>不公平</strong>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>不公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//设置为非公平锁</span><br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">false</span>);<br><br>    lock.lock();<br><br>    <span class="hljs-comment">//创建500个线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;Running&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t&quot;</span> + i).start();<br>    &#125;<br><br>    <span class="hljs-comment">//1s之后争抢锁</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start&quot;</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Running&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;强行插入&quot;</span>).start();<br><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210615214004.png" alt="非公平锁"></p><p>公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-comment">//公平锁</span><br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br><br>    lock.lock();<br><br>    <span class="hljs-comment">//创建500个线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;Running&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t&quot;</span> + i).start();<br>    &#125;<br><br>    <span class="hljs-comment">//1s之后争抢锁</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start&quot;</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Running&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;强行插入&quot;</span>).start();<br><br>    lock.unlock();<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210615214000.png" alt="公平锁"></p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>在synchronized中也有条件变量。</p><p>某一个线程获取锁之后，调用wait()方法。就会进入waitiing队列中。(这就是为什么调用wait()方法必须先所得锁)</p><p><code>但是synchronized中只有一个wait队列。而ReentrantLock支持多个wait队列。</code></p><p>如何使用：</p><ul><li>await前需要获得锁</li><li>await执行后，会释放锁，进入conditionObject等待</li><li>await的线程被唤醒（或打断、或超时）去重新竞争lock锁</li><li>竞争lock锁成功后，从await后继续执行</li></ul><p>例子：有两个员工需要等到烟和早餐才能工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">//两个条件变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitbreakfastQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">//初始化  没有烟  也没有早餐</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigrette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasBreakfast</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();<br><span class="hljs-comment">//没有烟时</span><br>                <span class="hljs-keyword">while</span>(!hasCigrette)&#123;<br>                    <span class="hljs-keyword">try</span>&#123;<br>                        waitCigaretteQueue.await();<br>                        System.out.println(<span class="hljs-string">&quot;t1线程正在等烟&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//有烟了</span><br>                System.out.println(<span class="hljs-string">&quot;t1线程等到了他的烟&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();<br>                <span class="hljs-comment">//没有早餐</span><br>                <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;t2线程正在等早餐&quot;</span>);<br>                        waitbreakfastQueue.await();<br><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//有早餐了</span><br>                System.out.println(<span class="hljs-string">&quot;t2等到了他的早餐&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        sendBreakfast();<br>        sleep(<span class="hljs-number">1</span>);<br>        sendCigarette();<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendCigarette</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;t1线程烟到了&quot;</span>);<br>            hasCigrette = <span class="hljs-literal">true</span>;<br>            waitCigaretteQueue.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendBreakfast</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;t2线程早餐到了&quot;</span>);<br>            hasBreakfast = <span class="hljs-literal">true</span>;<br>            waitbreakfastQueue.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2021/05/01/Docker/"/>
    <url>/2021/05/01/Docker/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>docker中文网：<a href="https://vuepress.mirror.docker-practice.com/">https://vuepress.mirror.docker-practice.com/</a></p><h4 id="1、-什么是Docker"><a href="#1、-什么是Docker" class="headerlink" title="1、 什么是Docker"></a>1、 什么是Docker</h4><h5 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h5><blockquote><p>官方介绍：</p><p>We have a complete container solution for you no matter who you are and where you are on your containerization journey</p><p>我们为你提供了一个完整的容器解决方案，不管你是谁，不管你在哪，你都可以开启你的容器旅程。</p><p>Docker就是容器技术</p></blockquote><h5 id="docker的作用"><a href="#docker的作用" class="headerlink" title="docker的作用"></a>docker的作用</h5><ol><li><p>在开发的时候，在本地测试环境可以跑，生产环境跑不起来。</p><p>我们在一个Java web应用程序涉及很多东西，比如jdk，tomcat，mysql等软件环境。当这些软件的某一项版本不一致时候，可能就会导致应用程序跑不起来。Docker则将程序以及使用软件环境直接打包在一起，无论在哪个机器上保证了环境的一致。</p><p><code>一致的运行环境，更轻松的迁移</code></p></li><li><p>服务器自己的程序挂了，结果发现是别人的程序出了问题把内存吃完了，自己程序因为内存不够挂了。</p><p>这种也是一种常见的情况，你的服务器会跟公司其他人的程序共享一台服务器。所以不可避免受到其他程序的干扰。docker很好的解决了环境隔离的问题。</p><p><code>对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源。</code></p></li><li><p>大量的流量，需要在多部署几十台服务器</p><p>部署几十台服务器，可能服务器的环境还不是一致的。就会出现各种问题。如果用docker，我们只需要将程序打包到镜像，你要多少台服务器，极大提高了部署效率。</p><p><code>通过镜像复制多个环境一致容器</code></p></li></ol><span id="more"></span><h5 id="docker与虚拟机的区别"><a href="#docker与虚拟机的区别" class="headerlink" title="docker与虚拟机的区别"></a>docker与虚拟机的区别</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527201910.png" alt="docker和虚拟机区别"></p><blockquote><p>虚拟机的缺点：</p><ol><li>虚拟机运行软件环境之前必须自身携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大。很笨重。</li><li>通过虚拟机在资源调度上经过很多步骤。</li></ol></blockquote><blockquote><p>docker的优势：</p><ol><li>docker是不携带操作系统的，所以docker的应用非常轻巧。</li></ol></blockquote><table><thead><tr><th></th><th>传统虚拟机</th><th>Docker容器</th></tr></thead><tbody><tr><td>磁盘占用</td><td>几个GB到几十个GB</td><td>几十MB到几百MB</td></tr><tr><td>CPU内存占用</td><td>虚拟操作系统非常占用CPU和内存</td><td>Docker引擎占用极低</td></tr><tr><td>启动速度</td><td>几分钟</td><td>几秒</td></tr><tr><td>安装管理</td><td>需要专门的运维技术</td><td>安装、管理方便</td></tr><tr><td>应用部署</td><td>每次部署都耗时费力</td><td>第二次部署轻松便捷</td></tr><tr><td>耦合性</td><td>多个应用服务器安装到一起，容易互相影响</td><td>每个应用服务器一个容器，达到隔离</td></tr><tr><td>系统依赖</td><td>无</td><td>需要相同或相似的内核，Linux</td></tr></tbody></table><h4 id="2、-docker安装"><a href="#2、-docker安装" class="headerlink" title="2、 docker安装"></a>2、 docker安装</h4><p>通用所有的平台</p><p>在测试或开发环境中，Docker官方为了简化安装流程，提供了一套便捷的安装脚本，Centos系统上可以使用这套脚本，另外可以通过<code>--mirror</code>选项来使用国内镜像源进行安装。</p><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把Docker的稳定版本安装在系统中。</p><p>脚本：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">curl</span> -<span class="hljs-string">fsSL</span> <span class="hljs-string">get</span>.<span class="hljs-string">docker</span>.<span class="hljs-string">com</span> -<span class="hljs-string">o</span> <span class="hljs-built_in">get-docker.sh</span><br><br><span class="hljs-string">sudo</span> <span class="hljs-string">sh</span> <span class="hljs-built_in">get-docker.sh</span> <span class="hljs-built_in">--mirror</span> <span class="hljs-string">Aliyun</span><br></code></pre></td></tr></table></figure><h4 id="3、docker的基本使用"><a href="#3、docker的基本使用" class="headerlink" title="3、docker的基本使用"></a>3、docker的基本使用</h4><h5 id="查看docker版本"><a href="#查看docker版本" class="headerlink" title="查看docker版本"></a>查看docker版本</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><h5 id="查看docker状态："><a href="#查看docker状态：" class="headerlink" title="查看docker状态："></a>查看docker状态：</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status docker</span><br></code></pre></td></tr></table></figure><h5 id="启动docker服务："><a href="#启动docker服务：" class="headerlink" title="启动docker服务："></a>启动docker服务：</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure><h5 id="停止docker服务："><a href="#停止docker服务：" class="headerlink" title="停止docker服务："></a>停止docker服务：</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">systemctl stop docker<br></code></pre></td></tr></table></figure><h5 id="重启docker服务："><a href="#重启docker服务：" class="headerlink" title="重启docker服务："></a>重启docker服务：</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart docker</span><br></code></pre></td></tr></table></figure><h5 id="查看docker信息："><a href="#查看docker信息：" class="headerlink" title="查看docker信息："></a>查看docker信息：</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span><br></code></pre></td></tr></table></figure><h5 id="docker开机自启动"><a href="#docker开机自启动" class="headerlink" title="docker开机自启动"></a>docker开机自启动</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><h5 id="建立docker组，并使用root用户"><a href="#建立docker组，并使用root用户" class="headerlink" title="建立docker组，并使用root用户"></a>建立docker组，并使用root用户</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 创建docker组</span><br>sudo groupadd docker<br><span class="hljs-comment"># 将当前用户加入docker组</span><br>sudo usermod -aG docker $<span class="hljs-keyword">USER</span><br><span class="hljs-title"># 重启docker</span>服务<br>systemctl restart docker<br></code></pre></td></tr></table></figure><h4 id="4、docker核心概念和核心架构图"><a href="#4、docker核心概念和核心架构图" class="headerlink" title="4、docker核心概念和核心架构图"></a>4、docker核心概念和核心架构图</h4><h5 id="1-镜像-image"><a href="#1-镜像-image" class="headerlink" title="1. 镜像 image"></a>1. 镜像 image</h5><p>定义：<strong>一个镜像代表着一个软件</strong>。比如说mysql镜像、redis镜像、nginx镜像……</p><h5 id="2-容器-container"><a href="#2-容器-container" class="headerlink" title="2.容器 container"></a>2.容器 container</h5><p>定义：<strong>基于某个镜像运行一次就会生成一个实例，这个实例称为一个容器。</strong></p><h5 id="3-仓库-repository"><a href="#3-仓库-repository" class="headerlink" title="3. 仓库 repository"></a>3. 仓库 repository</h5><p>定义：<strong>用于存储docker中所有镜像的具体位置</strong>。</p><p>远程仓库：docker在世界范围维护一个唯一的远程仓库</p><p>本地仓库：当前自己机器中下载镜像存储位置</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527133415.png" alt="Docker使用"></p><p>例子：启动一个安装mysql 5.7 版本的容器</p><ol><li><p>打开docker hub   <a href="https://registry.hub.docker.com/">https://registry.hub.docker.com/</a></p></li><li><p>选择mysql官方镜像，并选择版本5.7</p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527133809.png" alt="Docker Hub使用"></p><ol start="3"><li><p>启动docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure></li><li><p>拉取docker</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527134104.png" alt="拉取镜像 - 1"></p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527135624.png" alt="拉取镜像 - 2"></p><h4 id="5、docker镜像相关操作"><a href="#5、docker镜像相关操作" class="headerlink" title="5、docker镜像相关操作"></a>5、docker镜像相关操作</h4><h5 id="查看本地仓库中存在的镜像"><a href="#查看本地仓库中存在的镜像" class="headerlink" title="查看本地仓库中存在的镜像"></a>查看本地仓库中存在的镜像</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527141036.png" alt="镜像字段"></p><h5 id="显示镜像ID"><a href="#显示镜像ID" class="headerlink" title="显示镜像ID"></a>显示镜像ID</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker images -<span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> pull 镜像:版本号<br></code></pre></td></tr></table></figure><h5 id="通过命令行搜索镜像"><a href="#通过命令行搜索镜像" class="headerlink" title="通过命令行搜索镜像"></a>通过命令行搜索镜像</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker search mysql</span><br></code></pre></td></tr></table></figure><h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><p>镜像没有被使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">rm</span> 镜像名:tag<br><br>docker image <span class="hljs-built_in">rm</span> 镜像<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>镜像被使用过</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker image <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 镜像名:tag<br>docker image <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 镜像id<br></code></pre></td></tr></table></figure><p>简化写法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker rmi <span class="hljs-operator">-f</span> 镜像ID<br>docker rmi <span class="hljs-operator">-f</span> 镜像名:<span class="hljs-number">5.7</span><br><br><span class="hljs-comment"># 删除所有</span><br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker images <span class="hljs-literal">-q</span>)<br></code></pre></td></tr></table></figure><h4 id="6、容器相关命令"><a href="#6、容器相关命令" class="headerlink" title="6、容器相关命令"></a>6、容器相关命令</h4><h5 id="通过镜像运行一个容器"><a href="#通过镜像运行一个容器" class="headerlink" title="通过镜像运行一个容器"></a>通过镜像运行一个容器</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker run 镜像名:<span class="hljs-keyword">tag</span> <span class="hljs-title">| 镜像ID</span><br><br><span class="hljs-comment"># 后台执行</span><br>docker run -d 镜像名:<span class="hljs-keyword">tag</span> <span class="hljs-title">| 镜像ID</span><br><br><span class="hljs-comment"># 映射宿主机</span><br>docker run -p  宿主机端口号:容器内端口号  镜像名:<span class="hljs-keyword">tag</span><br><br><span class="hljs-title">比如：</span><br><span class="hljs-title">docker</span> run tomcat:<span class="hljs-number">8.0</span>-jre8<br></code></pre></td></tr></table></figure><p>我们启动的一个容器，具有隔离性，是没有办法与外界交互的。</p><p>启动tomcat:8080后，输入Linux系统IP地址和tomcat端口号</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527151007.png" alt="访问失败"></p><p>我们需要在启动容器时添加参数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8080</span>(系统上外部端口) : <span class="hljs-number">8080</span>(容器内服务监听的端口)  tomcat:<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-jre8<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527153012.png" alt="成功访问"></p><p><strong>注意：容器和容器之间是隔离的，因此我们启动多个容器，对于容器内可以都是用8080端口，但是容器映射的操作系统不能出现相同的端口号。</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 我们在启动一个tomcat</span><br><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8081</span>:<span class="hljs-number">8080</span> tomcat:<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-jre8<br></code></pre></td></tr></table></figure><p>我们查看此时的容器：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker ps</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527153517.png" alt="查看容器"></p><h5 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 查看正在运行程序</span><br>docker <span class="hljs-built_in">ps</span> <br><span class="hljs-comment"># 查看所有程序</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br><span class="hljs-comment"># 返回正在运行的容器ID</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-q</span> <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527145515.png" alt="查看容器命令"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake">CONTAINER ID   容器ID<br>IMAGE        镜像<br><span class="hljs-keyword">COMMAND</span>        容器内执行命令      <br>CREATED        创建时间<br>STATUS         当前状态<br>PORTS         容器服务监听的端口<br>NAMES   容器名称<br></code></pre></td></tr></table></figure><h5 id="重启、停止容器"><a href="#重启、停止容器" class="headerlink" title="重启、停止容器"></a>重启、停止容器</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 启动容器</span><br>docker start 容器ID<span class="hljs-string">|容器名称</span><br><span class="hljs-meta"># 重启容器</span><br>docker restart 容器ID<span class="hljs-string">|容器名称</span><br><span class="hljs-meta"># 正常停止容器</span><br>docker stop 容器ID<span class="hljs-string">|容器名称</span><br><span class="hljs-meta"># 立即停止容器</span><br>docker kill 容器ID<span class="hljs-string">|容器名称</span><br></code></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 删除停止的容器</span><br>docker <span class="hljs-built_in">rm</span> 容器ID|容器名称 <br><span class="hljs-comment"># 删除正在运行的容器</span><br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 容器ID|容器名称<br><span class="hljs-comment"># 删除所有容器</span><br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-aq</span>)<br></code></pre></td></tr></table></figure><h5 id="查看容器内服务运行日志"><a href="#查看容器内服务运行日志" class="headerlink" title="查看容器内服务运行日志"></a>查看容器内服务运行日志</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker logs 容器ID<span class="hljs-string">|容器名称</span><br><br><span class="hljs-meta"># 实时监听日志信息</span><br>docker logs -f 容器ID<span class="hljs-string">|容器名称</span><br><br><span class="hljs-meta"># 加上日志的时间戳</span><br>docker logs -t  容器ID<span class="hljs-string">|容器名称</span><br></code></pre></td></tr></table></figure><h5 id="查看容器内进程"><a href="#查看容器内进程" class="headerlink" title="查看容器内进程"></a>查看容器内进程</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker top 容器ID<span class="hljs-string">|容器名称</span><br></code></pre></td></tr></table></figure><h5 id="宿主机和容器内部进行交互"><a href="#宿主机和容器内部进行交互" class="headerlink" title="宿主机和容器内部进行交互"></a>宿主机和容器内部进行交互</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 进入容器，并于容器内命令终端进行交互</span><br>docker exec -it 容器ID<span class="hljs-string">|容器名称 bash</span><br></code></pre></td></tr></table></figure><p>bash就是容器内的终端。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527160713.png" alt="容器内部"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 退出容器</span><br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527160916.png" alt="退出容器"></p><h5 id="宿主机和容器的传输文件"><a href="#宿主机和容器的传输文件" class="headerlink" title="宿主机和容器的传输文件"></a>宿主机和容器的传输文件</h5><p>从容器复制文件到宿主机</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp 容器ID|容器名称:容器内资源路径 宿主机路径<br><br>如：<br>docker cp <span class="hljs-number">86</span>fe26389d83:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>RUNNING.txt ./RUNNING.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527161639.png" alt="image-20210527161639012"></p><p>从宿主机复制文件到容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> 文件|路径  容器ID|容器名称 : /容器内资源路径<br><br>如：<br>docker <span class="hljs-built_in">cp</span> aa.txt 86fe26389d83:/usr/local/tomcat<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527162033.png" alt="image-20210527162033156"></p><h5 id="查看容器内细节"><a href="#查看容器内细节" class="headerlink" title="查看容器内细节"></a>查看容器内细节</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker inspect 容器ID<span class="hljs-string">|容器名称</span><br></code></pre></td></tr></table></figure><h5 id="数据卷Volume"><a href="#数据卷Volume" class="headerlink" title="数据卷Volume"></a>数据卷Volume</h5><blockquote><p>实现宿主机系统与容器之间的文件共享</p><p>类似于挂载：</p><p>宿主机系统目录改变，直接影响docker目录</p></blockquote><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210527204555.png" alt="image-20210527204555352"></p><p>如何使用：</p><p>启动一个容器时 比如启动一个tomcat</p><ol><li><p>自定义数据卷目录</p><p><code>docker run-d -p 8080:8080 -v 宿主机目录(绝对路径):容器内路径  tomcat:8.0-jre8</code></p><p>例：<br><code>docker run -d -p 8080:8080 -v /root/apps/:/usr/local/tomcat/webapps tomcat:8.0-jre8</code></p></li><li><p>自动数据卷目录</p><p><code>docker run -d -p 8080:8080 -v aa:/usr/local/tomcat/webapps tomcat:8.0-jre8</code></p><p>注意：</p><ol><li>aa代表一个数据卷名字，可以随便写。docker在不存在时自动创建这个数据卷同时自动映射宿主机中某个目录</li><li>同时在启动容器时，会将aa对应容器目录中全部内容复制到aa映射目录中</li></ol></li></ol><h5 id="将容器打包成新镜像"><a href="#将容器打包成新镜像" class="headerlink" title="将容器打包成新镜像"></a>将容器打包成新镜像</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker commit -m <span class="hljs-string">&quot;&quot;</span>  -a<span class="hljs-string">&quot;&quot;</span>  容器ID<span class="hljs-string">|容器名称   打包的镜像名称:标签</span><br></code></pre></td></tr></table></figure><h5 id="将镜像备份出来"><a href="#将镜像备份出来" class="headerlink" title="将镜像备份出来"></a>将镜像备份出来</h5><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">docker <span class="hljs-keyword">save</span> 容器名称 -o 文件名<br></code></pre></td></tr></table></figure><h4 id="7、-docker镜像原理"><a href="#7、-docker镜像原理" class="headerlink" title="7、 docker镜像原理"></a>7、 docker镜像原理</h4><blockquote><p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p></blockquote><p>一个软件镜像不仅仅是原来的软件包，包含软件包所需的操作系统依赖，软件自身的依赖，以及自身的软件包组成。不同的镜像之间可能会存在公共的镜像，因此，<strong>docker镜像采用分层镜像原理</strong>。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528125334.png" alt="image-20210528125326506"></p><p>docker在设计镜像时，每一个镜像都是由多个镜像共同组成。</p><h5 id="镜像原理-—-UnionFS（联合文件系统）"><a href="#镜像原理-—-UnionFS（联合文件系统）" class="headerlink" title="镜像原理  —-   UnionFS（联合文件系统）"></a>镜像原理  —-   UnionFS（联合文件系统）</h5><blockquote><p> UnionFS文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加。同时可以将不同目录挂载到同一虚拟文件系统下。</p></blockquote><p>UnionFS文件系统是docker镜像的基础。</p><p>这种文件系统特性：就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><p><code>docker的镜像实际上是由一层一层的文件系统组成。</code></p><h5 id="为什么要采用这种分层结构"><a href="#为什么要采用这种分层结构" class="headerlink" title="为什么要采用这种分层结构"></a>为什么要采用这种分层结构</h5><p><code>资源共享</code></p><p>有多个镜像都是从相同的base镜像构建而来，那么宿主机只需在磁盘中保存一份base镜像。同时内存也只需要要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都是可以被共享的。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</p><h4 id="8、docker安装mysql服务"><a href="#8、docker安装mysql服务" class="headerlink" title="8、docker安装mysql服务"></a>8、docker安装mysql服务</h4><h5 id="1、dockerhub中搜索mysq服务"><a href="#1、dockerhub中搜索mysq服务" class="headerlink" title="1、dockerhub中搜索mysq服务"></a>1、dockerhub中搜索mysq服务</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h5 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h5><p>在<code>dockerhub</code>中详细的解释的如何使用这个镜像。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528132841.png" alt="image-20210528132841767"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-built_in">run</span> --name some-mysql -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag<br></code></pre></td></tr></table></figure><p>-e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw     代表给root用户指定密码</p><p>比如：启动一个mysql服务，操作系统端口号为3307，密码为root，并且在后台执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=root mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>此时，就已经启动了mysql服务</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528133928.png" alt="image-20210528133928618"></p><p>我们可以通过SQLyog来查看：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528134124.png" alt="image-20210528134123883"></p><p>​<img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528134204.png" alt="image-20210528134204014"></p><h5 id="3、持久化"><a href="#3、持久化" class="headerlink" title="3、持久化"></a>3、持久化</h5><p>容器与容器之间是隔离的。如果我们删除某个容器，那么容器中的数据就会被删除。因此我们要做数据持久化。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528135042.png" alt="image-20210528135042157"></p><p>通过数据卷的方式持久化。</p><p>启动一个容器，后台运行，操作系统的端口号为3307，用户密码为root，名称为mysql1</p><p>mysqldata数据卷没有会重新创建。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p  <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=root --name mysql1 -v mysqldata:/var/lib/mysql  mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>执行之后，启动mysql服务</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528140034.png" alt="image-20210528140034121"></p><p>我们查看是否有mysqldata数据卷</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528140149.png" alt="image-20210528140149727"></p><p>我们查看mysqldata数据卷中的信息</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect mysqldata</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528140405.png" alt="image-20210528140405571"></p><p>此时，数据卷创建好了，并且挂载到宿主机的某个位置。</p><p>我们在客户端创建表，添加数据。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528140654.png" alt="image-20210528140654325"></p><p>此时，我们停掉mysql服务，并且删除这个容器。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-aq</span>)<br></code></pre></td></tr></table></figure><p>然后重新启动容器，并且指定数据卷为mysqldata。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p  <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=root --name mysql1 -v mysqldata:/var/lib/mysql  mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>重新打开客户端。数据依然还在。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528141026.png" alt="image-20210528141026518"></p><h5 id="4、-修改配置文件"><a href="#4、-修改配置文件" class="headerlink" title="4、 修改配置文件"></a>4、 修改配置文件</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528141428.png"></p><p>默认的配置文件是在<code>/etc/mysql/my.cnf</code>。</p><p>启动一个mysql服务，后台运行，指定root用户密码，指定容器名，使用数据卷进行数据持久化，以修改之后的配置文件启动。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">3308</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=root --name mysql3308 -v mysqldata:/var/lib/mysql -v mysqlconfig:/etc/mysql mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>我们通过数据卷的方式将MySQL的配置文件挂载到操作系统的某个目录文件中。</p><p>查看配置文件的位置：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528142409.png" alt="image-20210528142409329"></p><p>我们在宿主机中找到这个目录文件。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528142453.png" alt="image-20210528142452935"></p><p>所以我们在启动MySQL时，指定数据卷。就可以达到通过配置文件来启动的目的。</p><h4 id="9、docker中容器之间的网络配置"><a href="#9、docker中容器之间的网络配置" class="headerlink" title="9、docker中容器之间的网络配置"></a>9、docker中容器之间的网络配置</h4><h5 id="1、-为什么要提供网络功能"><a href="#1、-为什么要提供网络功能" class="headerlink" title="1、 为什么要提供网络功能"></a>1、 为什么要提供网络功能</h5><p><code>docker允许通过外部访问容器或容器互联的方式来提供网络服务。</code></p><h5 id="2、网络配置原理"><a href="#2、网络配置原理" class="headerlink" title="2、网络配置原理"></a>2、网络配置原理</h5><p>当docker启动时，会自动在主机上创建一个<code>docker0</code>虚拟网桥。实际上是Linux的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>同时，docker随机分配一个本地未占用的私有网段中的一个地址给<code>docker0</code>接口。</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。</p><p>通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528193314.png" alt="image-20210528193306826"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528194234.png" alt="image-20210528194234276"></p><h5 id="3、网络使用"><a href="#3、网络使用" class="headerlink" title="3、网络使用"></a>3、网络使用</h5><p><strong>查看docker中的网络配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><code>bridge</code>是默认的网桥</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528194827.png" alt="image-20210528194820229"></p><p>我们可以进入一个容器来查看网络配置信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 启动容器</span><br><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> --name mytomcat tomcat:<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-jre8<br><br><span class="hljs-attribute">docker</span> inspect 容器ID|容器名<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528195619.png" alt="image-20210528195619131"></p><p><strong>容器与容器之间的交互</strong></p><p>我们创建两个tomcat，mytomcat和tomcat2。我们进入mytomcat的容器内，在这个容器内去访问tomcat2的8080端口。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528200352.png" alt="image-20210528200352177"></p><p>我们还需要知道tomcat2的ip地址。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> inspect <span class="hljs-number">55</span>fd2f590189<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528200907.png" alt="image-20210528200907644"></p><p>进入mytomcat容器内</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> exec -it <span class="hljs-number">66</span>fd52d82688 bash<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">访问tomcat2的<span class="hljs-number">8080</span>端口<br>curl http:<span class="hljs-regexp">//</span><span class="hljs-number">172.17</span>.<span class="hljs-number">0.3</span>:<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528201243.png" alt="image-20210528201243617"></p><h5 id="自定义网桥"><a href="#自定义网桥" class="headerlink" title="自定义网桥"></a>自定义网桥</h5><p>如果我们每一个容器都是用默认的网桥。就会造成带宽的降低。因此我们自定义网桥。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 创建自定义网桥</span><br>docker<span class="hljs-built_in"> network </span>create -d<span class="hljs-built_in"> bridge </span>网桥名称 <br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>create -d<span class="hljs-built_in"> bridge </span>net<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528202247.png" alt="image-20210528202247215"></p><p>我们查看net网桥中的信息。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528202552.png" alt="image-20210528202552064"></p><p>我们在启动一个tomcat，这是的tomcat IP地址就会是172.18.0.xxx这个网段了。</p><h5 id="使用自定义网桥"><a href="#使用自定义网桥" class="headerlink" title="使用自定义网桥"></a>使用自定义网桥</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> --name tomcat --network net tomcat:<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-jre8<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528203139.png" alt="image-20210528203139533"></p>]]></content>
    
    
    
    <tags>
      
      <tag>容器</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronized原理</title>
    <link href="/2021/04/05/Synchronized%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/05/Synchronized%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h3><h3 id="1、Synchronized使用"><a href="#1、Synchronized使用" class="headerlink" title="1、Synchronized使用"></a>1、Synchronized使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//synchronized代码块</span><br><span class="hljs-keyword">synchronized</span> (SynchronizedTest.class)&#123;<br>    System.out.println(<span class="hljs-string">&quot;进入同步代码块&quot;</span>);<br>&#125;<br><span class="hljs-comment">//synchronized代码方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFun</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;进入同步方法&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (SynchronizedTest.class)&#123;<br>            System.out.println(<span class="hljs-string">&quot;进入同步代码块&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br>  <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=3,</span> <span class="hljs-string">args_size=1</span><br>     <span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // class jiang/JVM/SynchronizedTest</span><br>     <span class="hljs-attr">2:</span> <span class="hljs-string">dup</span><br>     <span class="hljs-attr">3:</span> <span class="hljs-string">astore_1</span><br>     <span class="hljs-attr">4:</span> <span class="hljs-string">monitorenter</span><br>     <span class="hljs-attr">5:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>     <span class="hljs-attr">8:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String 进入同步代码块</span><br>    <span class="hljs-attr">10:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>    <span class="hljs-attr">13:</span> <span class="hljs-string">aload_1</span><br>    <span class="hljs-attr">14:</span> <span class="hljs-string">monitorexit</span><br>    <span class="hljs-attr">15:</span> <span class="hljs-string">goto</span>          <span class="hljs-number">23</span><br>    <span class="hljs-attr">18:</span> <span class="hljs-string">astore_2</span><br>    <span class="hljs-attr">19:</span> <span class="hljs-string">aload_1</span><br>    <span class="hljs-attr">20:</span> <span class="hljs-string">monitorexit</span><br>    <span class="hljs-attr">21:</span> <span class="hljs-string">aload_2</span><br>    <span class="hljs-attr">22:</span> <span class="hljs-string">athrow</span><br>    <span class="hljs-attr">23:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>我们发现有两条陌生的指令：<code>monitorenter</code>和<code>monitorexit</code></p><p>Javac在编译时，会生成对应的<code>monitorenter</code>和<code>monitorexit</code>指令分别对应<code>synchronized</code>同步块的进入和退出</p><p>其中，我们可以发现有两个<code>monitorexit</code>，这是因为：</p><p>为了保证抛异常的情况下也能释放锁，所以java为同步代码块添加了一个隐式的try-finally，在finally中会调用<code>monitorexit</code>命令释放锁。</p><p>对于<code>synchronized</code>方法而言，<code>javac</code>为其生成了一个<code>ACC_SYNCHRONIZED</code>关键字，在JVM进行方法调用时，发现调用的方法被<code>ACC_SYNCHRONIZED</code>修饰，则会先尝试获得锁。</p><p>我们发现在字节码中出现了两次<code>monitorexit</code>。这是在两个不同的代码路径上执行一次。</p><ul><li>第一个指令用于synchronized块的正常退出。</li><li>为了保证抛出异常的情况下也能释放锁，所以Javac为同步代码块添加一个隐式try-finally，在finally中会调用<code>monitorexit</code>命令释放锁。可以看到，在第一个<code>monitorexit</code>之后有一个goto 23，说明，直接跳到23行指令，<code>因此有两个monitorexit并没有执行</code>。</li></ul><h6 id="x3D-x3D-monitorenter-x3D-x3D"><a href="#x3D-x3D-monitorenter-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;monitorenter&#x3D;&#x3D;"></a>&#x3D;&#x3D;monitorenter&#x3D;&#x3D;</h6><p>每一个对象都会和一个<code>监视器锁monitor</code>关联。监视器被占用时会被锁住，其他线程无法来获取该monitor。当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。过程如下：</p><ol><li>若monitor的进入数为0，线程可以进入monitor，并将monitor的进入树置为1.当前线程成为monitor的ower(所有者)</li><li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li><li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li></ol><p>synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量owner:拥有这把锁的线程,recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待</p><p>&#x3D;&#x3D;monitorexit&#x3D;&#x3D;</p><ol><li><p>能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权的线程。</p></li><li><p>执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</p></li></ol><p>monitorexit释放锁。monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit。</p><h3 id="2、Java对象头"><a href="#2、Java对象头" class="headerlink" title="2、Java对象头"></a>2、Java对象头</h3><p>synchronized用的锁是存放在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头。如果对象是非数组类型，则用2字宽存储对象头。</p><p>在32位虚拟机中，1字宽等于4字节，即32bit。</p><p>普通对象：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520131637.png" alt="image-20210520131637139"></p><p>数组对象：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520131541.png" alt="image-20210520131541197"></p><p>Mark Word：存储对象的hashCode或一些锁信息</p><p>Klass Word：存储到对象类型数据的指针</p><p>array length：数组的长度（如果当前对象是数组）</p><p>具体的MarkWord信息和状态变化：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520132016.png" alt="image-20210520132016211"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520132049.png" alt="image-20210520132049817"></p><h3 id="3、监视器锁monitor"><a href="#3、监视器锁monitor" class="headerlink" title="3、监视器锁monitor"></a>3、监视器锁monitor</h3><p>无论是同步代码方法，同步代码块，都依赖于一个monitor监视器锁。</p><h4 id="monitor源码"><a href="#monitor源码" class="headerlink" title="monitor源码"></a>monitor源码</h4><p>下面是HotSpot虚拟机中的monitor源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ObjectMonitor</span>()<br>&#123;<br>    _header=<span class="hljs-literal">NULL</span>;<br>    _count=<span class="hljs-number">0</span>;<br>    _waiters=<span class="hljs-number">0</span>;<br>    _recursions=<span class="hljs-number">0</span>;<span class="hljs-comment">//线程的重入次数</span><br>    _object=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//存储该monitor的对象</span><br>    owner=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//标识拥有该monitor的线程</span><br>    _WaitSet=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock=<span class="hljs-number">0</span>;<br>    _Responsible=<span class="hljs-literal">NULL</span>;<br>    _succ=<span class="hljs-literal">NULL</span>;<br>    _cxq=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//多线程竞争锁时的单向列表</span><br>    FreeNext=<span class="hljs-literal">NULL</span>;<br>    _EntryList=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//处于等待锁block状态的线程，会被加入到该列表</span><br>    _SpinFreq=<span class="hljs-number">0</span>;<br>    _SpinClock=<span class="hljs-number">0</span>;<br>    OwnerIsThread=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在源码中，我们要注意一些重要的数据结构：</p><ol><li><p>_owner</p><p>初始化时为NULL。当有线程占有该monitor时，owner标记为线程的唯一标识。当线程释放monitor时，owner又恢复为NULL。owner是一个临时资源，JVM是通过CAS操作来保证其线程安全的。</p></li><li><p>_cxq  :竞争队列</p><p>所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个<strong>临时资源</strong>，JVM通过CAS原子指令来修改cxq队列。</p></li><li><p>_EntryList</p><p>存放处于等待锁block状态的线程队列</p></li><li><p>_WaitSet</p><p>存放处于wait状态的线程队列，即调用wait()方法的线程</p></li></ol><h4 id="monitor使用"><a href="#monitor使用" class="headerlink" title="monitor使用"></a>monitor使用</h4><ol><li>刚开始Monitor时Owner为null</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520132558.png" alt="image-20210520132558728"></p><ol start="2"><li><p>当Thread-2执行synchronized(obj)就会将monitor的所有者owner置为Thread-2，monitor只能有一个owner。</p><p>MarkWord中的信息会按照不同的锁进行更改。如果是重量级锁，会指向Monitor对象</p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520133209.png" alt="image-20210520133209752"></p><ol start="3"><li><p>在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520133724.png" alt="image-20210520133724097"></p></li><li><p>Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁。这个竞争是非公平的。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520133922.png" alt="image-20210520133922131"></p></li></ol><h3 id="4、锁升级"><a href="#4、锁升级" class="headerlink" title="4、锁升级"></a>4、锁升级</h3><p>Java SE1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在JavaSE1.6中，锁一共有四种状态，级别从低到高依次是：无锁状态，偏向锁、轻量级锁、重量级锁。这几个状态会随着竞争情况逐渐升级。所可以升级但不能降级，意味着偏向锁升级为轻量级锁之后不能降级为偏向锁。（锁降级发生在读写锁上）。</p><h4 id="1、轻量级锁"><a href="#1、轻量级锁" class="headerlink" title="1、轻量级锁"></a>1、轻量级锁</h4><p>轻量级锁的使用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的，语法依旧是synchronized。</p><h5 id="轻量级锁流程"><a href="#轻量级锁流程" class="headerlink" title="轻量级锁流程"></a>轻量级锁流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>         <span class="hljs-comment">// 同步块 A</span><br>         method2();<br>     &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>         <span class="hljs-comment">// 同步块 B</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>首先判断obj的对象是否处于无锁的状态。如果是，创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，&#x3D;&#x3D;内部可以存储锁对象的Mark Word&#x3D;&#x3D;</p><p><code>Lock Record</code>对象中，有两个结构，<code>Displaced Mark Word</code>记录锁对象的MarkWord，<code>Object reference</code>指向锁对象。比如上面程序中的obj锁对象。</p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520143416.png" alt="image-20210520143416139"></p><ol start="2"><li><p>让锁记录中<code>Object reference</code>指向锁对象后，并尝试用CAS替换obj对象锁的<code>Mark Word</code>。将MarkWord的值存入锁记录。</p><p>CAS如何替换：</p><p>根据对象的<code>MarkWord</code>最后两位是否是01，如果是表示此时无锁，可以成功。如果其他线程将它修改为00，那么CAS操作失败。</p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520144450.png" alt="image-20210520144450659"></p><ol start="3"><li>如果CAS替换成功，对象头中存储了锁记录地址和状态00，表示由该线程给对象加锁。</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520144617.png" alt="image-20210520144617367"></p><ol start="4"><li>如果CAS失败，可能由两种情况。<ul><li>如果是其他线程已经持有了该obj的轻量级锁，这时表明有竞争，进入锁膨胀过程。</li><li>如果是自己执行了synchronized锁重入。那么在添加一条Lock Record作为重入的计数。</li></ul></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520145725.png" alt="image-20210520145725597"></p><ol start="5"><li>当退出synchronized代码块（解锁时），如果由取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减1。</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520150020.png" alt="image-20210520150020755"></p><ol start="6"><li><p>当退出synchronized代码块（解锁时），如果由取值为null的锁记录，这是使用CAS将MarkWord的值给对象头。</p><p>如果成功：则解锁成功</p><p>如果失败：说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程。</p></li></ol><h5 id="轻量级锁锁膨胀"><a href="#轻量级锁锁膨胀" class="headerlink" title="轻量级锁锁膨胀"></a>轻量级锁锁膨胀</h5><p>在解锁时，如果CAS操作失败，表示当前线程执行同步代码块时，有其他线程也在访问，当前的锁是被竞争。那么轻量级锁会膨胀为重量级锁。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520151755.png" alt="image-20210520151755439"></p><ol><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520152533.png" alt="image-20210520152533571"></p><ol start="2"><li><p>这时Thread-1加轻量级锁，进入锁膨胀流程</p><p>Thread-1为obj对象申请一个Monitor锁，让Obj的<code>MarkWord</code>指向重量级锁地址。原来是指向锁记录中的<code>Displaced Mark Word</code>。最后两位是01。</p><p>然后Thread-1进入Monitor的EntyList  BLOCKED。</p><p>并且要改成obj中<code>Displaced Mark Word</code>的最后两位为10，表示是重量级锁。</p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520152838.png" alt="image-20210520152838701"></p><ol start="3"><li>对于Thread-0来说，执行完同步代码块后。使用CAS将Mark Word的值恢复给Obj锁对象的对象头。但是失败，因为此时最后两位已经被更改为10。说明此时已经是重量级锁，需要按照重量级锁的解锁流程来解锁。</li></ol><h5 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h5><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><h4 id="2、偏向锁"><a href="#2、偏向锁" class="headerlink" title="2、偏向锁"></a>2、偏向锁</h4><p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是有同一线程多次获得。为了让线程获得锁的代价更低而引入了偏向锁。</p><p>使用jar包可以查看对象头MarkWord信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassLayout.parseInstance(test.class).toPrintable());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520165144.png" alt="image-20210520165144296"></p><h5 id="偏向锁的特点"><a href="#偏向锁的特点" class="headerlink" title="偏向锁的特点"></a>偏向锁的特点</h5><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword值的最后三位是001，这是它的thread、epoch、age都为0。</li><li>偏向锁是默认延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数<code>-XX:BiasedLockingStartupDelay=0</code>来禁用延迟。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在jvm添加上参数<br>-XX:BiasedLockingStartupDelay=0<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520165301.png" alt="image-20210520165301145"></p><ul><li><p>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (o)&#123;<br>        <span class="hljs-comment">//添加上偏向锁之后</span><br>        System.out.println(ClassLayout.parseInstance(o).toPrintable());<br>    &#125;<br>    System.out.println(ClassLayout.parseInstance(o).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到两次打印的对象头都是相等的</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520165615.png" alt="image-20210520165615643"></p><h5 id="偏向锁流程"><a href="#偏向锁流程" class="headerlink" title="偏向锁流程"></a>偏向锁流程</h5><ol><li><p>当一个线程访问同步块并获取锁时，会在<strong>对象头和栈帧中的锁记录里存储锁偏向的线程ID</strong>。</p></li><li><p>以后该线程在进入和退出同步块时<strong>不需要进入CAS操作来加锁和解锁</strong>，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p><ul><li><p>如果测试成功，表示线程已经获得了锁。</p></li><li><p>如果测试失败，则需要在测试一下Mark Word中偏向锁的标识是否设置成1（表示当前时偏向锁），如果没有设置，则使用CAS竞争锁。如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p></li></ul></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520154833.png" alt="image-20210520154833068"></p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><ol><li>调用对象的 hashCode</li></ol><p>调用了对象的 hashCode，但此时偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销。</p><ol start="2"><li><p>其他线程使用锁对象</p><p>当有多个线程竞争时，会撤销偏向锁。改为轻量级锁。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存模型</title>
    <link href="/2021/04/02/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/04/02/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>​<code>在并发程序中，涉及到操作系统的底层，因此我们很难去判断程序的执行是怎样的。同时涉及到多个线程对共享资源的访问。一致性和安全性将会受到严重挑战。所以，我们需要保证多个线程正确的协同工作。Java内存模型可以帮助我们解决这些问题。</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Java内存区域(结构)和Java内存模型</span><br><span class="hljs-bullet">1.</span> java内存区域和Java内存模型是两个不一样的东西。内存区域是指JVM运行时将数据分区域存储，强调与内存空间的划分。<br><span class="hljs-bullet">2.</span> Java内存模型时定义了线程和主内存之间的抽象关系，用来屏蔽各种硬件和操作系统的内存之间的访问差异。JMM定义了JVM在计算机内存中的工作方式。规范了Java虚拟机与计算机内存之间如何协同工作。Java内存模型跟CPU缓存模型类似，是基于CPU缓存模型来建立的。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量一定要是共享变量，比如实例字段，静态变量等。<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="1、CPU缓存"><a href="#1、CPU缓存" class="headerlink" title="1、CPU缓存"></a>1、CPU缓存</h3><p><code>为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化</code></p><p>例如：CPU高速缓存。尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210508082612.png" alt="image-20210508082604913"></p><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><blockquote><p>L1 Cache(一级缓存) ：CPU第一层高速缓存，分为数据缓存和指令缓存。一般服务器CPU的L1缓存的容量通常在32-4096kb。</p><p>L2 Cache(二级缓存) ：由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一高速存储器。</p><p>L3 Cache(三级缓存) ：现在L3都是内置，它可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。一般是多核共享一个L3缓存。</p></blockquote><p>&#x3D;&#x3D;CPU在读取数据时，先在L1中寻找，再从L2寻找，再从L3寻找，然后是内存，再后是外存储器。&#x3D;&#x3D;</p><h4 id="缓存同步协议"><a href="#缓存同步协议" class="headerlink" title="缓存同步协议"></a>缓存同步协议</h4><p>在多CPU读取同样的数据进行缓存，进行不同运算之后，最终写入主内存以哪个CPU为准？</p><p><code>在这种高速缓存回写的场景下，有一个缓存一致性协议</code>，大多数的CPU厂商对它进行了实现。</p><p>MESI协议，它规定了每条缓存有个状态位，同时定义下面四个状态：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">修改态(Modified)      此缓存行已被修改过(脏行) ，内容以不同于主存，为此cache专有。<br><br>专有态(Exclusive)     此缓存行内容同于主存，但不出现于其他cache中<br><br>共享态(Shared)        此缓存行内容同于主存，可以出现在其他cache中<br><br>无效态(Invalid)       此缓存行内容无效。<br></code></pre></td></tr></table></figure><p>多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU。</p><p>也就是意味着：<code>CPU处理器要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证最终一致</code></p><h4 id="运行时指令重排序"><a href="#运行时指令重排序" class="headerlink" title="运行时指令重排序"></a>运行时指令重排序</h4><p>&#x3D;&#x3D;指令重排序也是CPU性能优化手段&#x3D;&#x3D;</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210508085016.png" alt="image-20210508085016469"></p><p>指令重排的场景：当CPU写缓存发现缓存区正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 举一个生活中的重排序例子</span><br>将一条鱼加工成鱼罐头需要50分钟，一次只能加工一条鱼。<br><br>可以将每个鱼罐头的加工流程分成5个步骤：<br><span class="hljs-bullet">1.</span> 去鳞清洗 10分钟<br><span class="hljs-bullet">2.</span> 蒸煮沥水 10分钟<br><span class="hljs-bullet">3.</span> 加注汤料 10分钟<br><span class="hljs-bullet">4.</span> 杀菌出锅 10分钟<br><span class="hljs-bullet">5.</span> 真空封罐 10分钟<br><br>我们可以通过这种方式来提高加工的效率。这种方法类似于计算机体系结构中的流水线技术。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210419150856.png" alt="image-20210419150849274"></p><p>但并非随便的重排序，需要遵守<code>as-if-serial</code>语义</p><blockquote><p>as-if-serial语义：</p><p>不管怎么重排序，单线程程序的执行结果不能被改变。也就是说，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p></blockquote><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>在多级缓存中存在的问题：</p><ol><li><p>缓存中的数据于主内存的数据不是实时同步的，各个缓存之间的数据也不是同步的。</p></li><li><p>在多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误</p></li></ol><p>因此，CPU厂商提供了&#x3D;&#x3D;两个内存屏障指令(Memory Barrier)用于解决上述两个问题：</p><ol><li>&#x3D;&#x3D;写内存屏障(Store Memory Barrier)&#x3D;&#x3D;：在指令后插入Store Barrier，能让<code>写入工作内存中的最新数据更新写入主内存中，让其他线程可见。</code>强制将最新数据写入主内存中，这种显示调用，CPU就不会因为性能考虑而对指令重排。</li><li>&#x3D;&#x3D;读内存屏障(Load Memory Barrier)&#x3D;&#x3D;：在指令前插入Load Barrier，可以让工作内存中的数据失效，强制从主内存中加载数据。</li></ol><h3 id="2、什么是主内存和工作内存"><a href="#2、什么是主内存和工作内存" class="headerlink" title="2、什么是主内存和工作内存"></a>2、什么是主内存和工作内存</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 什么是主内存和工作内存</span><br>java内存模型规定了所有的变量在主内存中。每个线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝。线程对变量的所有操作(读取、赋值)都必须在工作内存中进行。而不能直接去读写主内存中的变量。不同的线程之间无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 下图就是线程、主内存、工作内存三者的交互关系</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210411120918.png" alt="image-20210411120918064"></p><h3 id="3、内存之间的交互操作"><a href="#3、内存之间的交互操作" class="headerlink" title="3、内存之间的交互操作"></a>3、内存之间的交互操作</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步会主内存。<br>Java内存模型定义了一下8中操作来完成，虚拟机实现时必须保证每一种操作都是原子操作。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 8种操作</span><br><span class="hljs-bullet">1.</span> lock(锁定):作用于主内存的变量，它把一个变量标识为一条线程独占的状态<br><span class="hljs-bullet">2.</span> unlick(解锁):作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。<br><span class="hljs-bullet">3.</span> read(读取):作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存，以便随后的load动作使用<br><span class="hljs-bullet">4.</span> load(载入):作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。<br><span class="hljs-bullet">5.</span> use(使用) :作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个这个操作<br><span class="hljs-bullet">6.</span> assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个需要变量赋值的字节码指令时将会执行这个这个操作<br><span class="hljs-bullet">7.</span> store(存储):作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用<br><span class="hljs-bullet">8.</span> write(写入):作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 变量同步 (只需顺序执行操作，不需要连续执行操作)</span><br>如果要把一个变量从主内存复制到工作内存中，那就要顺序执行read和load操作。<br>如果要把变量从工作内存同步回主内存，就要顺序执行store和write操作。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 对于内存之间的交互，主要注意下面的几点：</span><br><span class="hljs-bullet">1.</span> 不允许read、load、store和write操作单独出现，也就是说，不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存执行回写操作但主内存不接受。<br><br><span class="hljs-bullet">2.</span> 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步到主内存。<br><br><span class="hljs-bullet">3.</span> 不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步会主内存中。<br><br><span class="hljs-bullet">4.</span> 一个变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，也就是说对一个变量实施use和store操作之前，必须先执行过了assign和load操作。<br><br><span class="hljs-bullet">5.</span> 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁。<br><br><span class="hljs-bullet">6.</span> 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load和assign操作初始化变量的值。<br><br><span class="hljs-bullet">7.</span> 如果变量实现没有被lock操作锁住，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁住的变量。<br><br><span class="hljs-bullet">8.</span> 对一个变量执行unlock操作之前，必须先把此变量同步会主内存中。<br></code></pre></td></tr></table></figure><h3 id="4、原子性、可见性和有序性"><a href="#4、原子性、可见性和有序性" class="headerlink" title="4、原子性、可见性和有序性"></a>4、原子性、可见性和有序性</h3><p><code>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性着3个特征来建立的。</code></p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><code>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write。</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">原子型是指操作是不可分的，要么全部一起执行，要么不执行。在Java中，其表现在对于共享变量的某些操作，是不可分的，必须连续完成。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 例：对于i++操作，有下面几个操作</span><br><span class="hljs-bullet">1.</span> 读取变量i的值<br><span class="hljs-bullet">2.</span> 将i的值加1<br><span class="hljs-bullet">3.</span> 将值重新赋值给i<br><br>如果在进行着三个操作中的任何一个操作时，将i的值进行更改。都不会得到正确的值。因此对于i++操作必须是原子性的<br></code></pre></td></tr></table></figure><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><code>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 为什么会有可见性</span><br>我们知道，在JMM中有以下规范<br><span class="hljs-code">    定义的所有变量都存储在主内存中。</span><br><span class="hljs-code">    每个线程都有自己独立的工作空间，里面保存了该线程使用到的共享变量的副本拷贝。</span><br><span class="hljs-code">    线程对共享变量的操作都在自己的工作内存中进行，而非直接从主内存中读写。</span><br><span class="hljs-code">    不同线程之间无法直接访问其他线程的共享变量</span><br></code></pre></td></tr></table></figure><p><code>线程需要修改一个共享变量i，需要先把i从主内存拷贝到该线程的工作内存中，在自己的工作内存中修改完毕之后，再从工作内存中回到主内存中。如果线程对变量的操作没有回写到主内存的话，没有改变主内存中共享变量的值，那么对其他线程是不可见的。如果其他线程没有读取主内存中新的值，而是使用旧的值，同样的也是不可见的</code></p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><code>有序性指的是程序严格按照代码先后顺序执行。</code></p><p>我们知道，为了CPU的性能，我们允许 运行时指令重排序</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 重排序对多线程的影响</span><br>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果(这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因)。<br>但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。<br></code></pre></td></tr></table></figure><h5 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则(happens-before)"></a>先行发生原则(happens-before)</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Java语言中有一个先行发生原则，他是判断数据是否存在竞争、线程是否安全的主要依据。依靠这个原则，我们可以通过几条规则解决并发环境下两个操作之间是否可能存在冲突的所有问题。<br></code></pre></td></tr></table></figure><p><code>happens-before是指两个操作存在确定的先后顺序，前面的操作产生的结果则可以被后面的操作使用。所谓确定的先后顺序，即是在任何情况下两个操作的先后顺序是确定不变的。</code></p><p><code>在多线程中，happens-berfore是确定变量是否线程安全的充要条件。也就是说，如果线程A先行发生于线程B，则线程A中的变量相对于线程B而言是线程安全的。反过来，没有遵循happens-before，则必须借助线程同步手段才能保证线程的安全性。</code></p><ul><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行在后面的操作</p></li><li><p>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</p></li><li><p>volatile变量规则：对一个变量的写操作先行于后面对这个变量的读操作。</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p></li><li><p>线程启动机制：Thread对象的start()方法先行发生于此线程每一个动作</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2021/03/01/RabbitMQ/"/>
    <url>/2021/03/01/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="1-RabbitMQ引言"><a href="#1-RabbitMQ引言" class="headerlink" title="1. RabbitMQ引言"></a>1. RabbitMQ引言</h3><p>官方网站：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><h4 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h4><p>MQ(Message Queue)：<strong>消息队列</strong>。通过<code>典型的生产者和消费者模型</code>，生产者不断的向消息队列中生产消息，消费者不断的从队列中获取消息。因为<code>消息的生产和消费都是异步的</code>，而且只关心消息的发送和接受。没有业务逻辑的侵入，轻松的实现系统间解耦。</p><p>别名：<strong>消息中间件</strong>，通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529134502.png" alt="image-20210529134454943"></p><p>上图就是消息队列最原始的模型，其中两个关键词：消息、队列</p><ol><li><strong>消息</strong>：就是要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式</li><li><strong>队列</strong>：存放消息的容器。入队即发消息的过程，出队即收消息的过程。</li></ol><h4 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>基于<code>AMQP</code>协议，<code>erlang</code>语言开发，是部署最广泛的开源消息中间件，是最受欢迎的开源消息中间件之一。</p><p>RabbitMQ的主要特征是面向消息、队列、路由（包含点对点和发布&#x2F;订阅）、可靠性、安全。</p><h3 id="2-RabbitMQ安装"><a href="#2-RabbitMQ安装" class="headerlink" title="2.RabbitMQ安装"></a>2.RabbitMQ安装</h3><h5 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h5><p>在Docker hub中找到docker 镜像。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">docker run -d -p <span class="hljs-number">15672</span><span class="hljs-symbol">:</span><span class="hljs-number">15672</span> -p <span class="hljs-number">5672</span><span class="hljs-symbol">:</span><span class="hljs-number">5672</span> -v <span class="hljs-title class_">RabbitMQConfig</span><span class="hljs-symbol">:/etc/rabbitmq</span> -v <span class="hljs-title class_">RabbitMQData</span><span class="hljs-symbol">:/var/lib/rabbitmq</span> --name docker c9b2833379d6<br></code></pre></td></tr></table></figure><p>输入：192.168.111.128(Linux系统IP地址):15672。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529145059.png" alt="image-20210529145058481"></p><p>用户名密码都是guest</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529145225.png" alt="image-20210529145225750"></p><h3 id="3、AMQP协议"><a href="#3、AMQP协议" class="headerlink" title="3、AMQP协议"></a>3、AMQP协议</h3><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529152358.png" alt="image-20210529152358392"></p><p>主要包含了三个主要的组件：</p><ul><li><p><code>exchange</code>（交换器）：从Publisher程序中收取消息，并把这些消息根据一些规则路由到消息队列（Message Queue）中</p></li><li><p><code>Queue</code>（消息队列）：存储消息。直到消息被安全的投递给了消费者。</p></li><li><p><code>binding</code> ：定义了 <code>Queue</code> 和 <code>exchange</code> 之间的关系，提供了消息路由的规则。</p></li></ul><p>可以把AMQP的架构理解为一个邮件服务：</p><ul><li>一个消息类似于一封邮件信息</li><li>消息队列类似于一个邮箱（Mailbox）</li><li>消费者类似一个邮件客户端，能够拉取和删除邮件。</li><li>交换器类似一个MTA（邮件服务器）。检查邮件，基于邮件里的路由信息、路由表，来决定如何把邮件发送到一个或多个邮箱里。</li><li>Routing Key类似于邮件中的<code>To:</code>，<code>Cc:</code>， <code>Bcc:</code> 的地址。不包含服务端信息。</li><li>每一个交换器实例，类似于各个MTA进程。用于处理不同子域名的邮件，或者特定类型的邮件。</li><li><code>Binding</code> 类似于MTA中的路由表。</li></ul><p>在AMQP里，生产者直接把消息发到服务端，服务端通过这些消息路由发送到邮箱中。消费者直接从邮箱里取消息。</p><p>在RabbitMQ中，有多种模型，有的模型直接发送给队列，有的模型需要通过交换机。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529235639.png" alt="image-20210529235632153"></p><h3 id="4、直连模型"><a href="#4、直连模型" class="headerlink" title="4、直连模型"></a>4、直连模型</h3><p>我们可以看到，直连是最简单的一种模型，生产者直接将消息放入队列中，消费者直接从队列读取消息。并且生产者、队列和消费者都是一一对应的。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530083911.png" alt="image-20210530083904074"></p><h4 id="1、创建Virtual-Host"><a href="#1、创建Virtual-Host" class="headerlink" title="1、创建Virtual Host"></a>1、创建Virtual Host</h4><p>在实现这种模型之前。我们需要通过RabbitMQ的web管理界面新建一些东西。</p><p>下图看出，队列都在Virtual Host中，我们需要去创建它。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529152358.png" alt="image-20210529152358392"></p><ol><li>打开Virtual Host界面</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530084822.png" alt="image-20210530084822053"></p><ol start="2"><li>添加Virtual Host</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530085034.png" alt="image-20210530085034109"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530085106.png" alt="image-20210530085106920"></p><ol start="3"><li>添加User</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530085242.png" alt="image-20210530085242819"></p><ol start="4"><li>允许User访问我们的Virtual Host</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530085426.png" alt="image-20210530085426373"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530085440.png" alt="image-20210530085440943"></p><h4 id="2、构建项目并引入依赖"><a href="#2、构建项目并引入依赖" class="headerlink" title="2、构建项目并引入依赖"></a>2、构建项目并引入依赖</h4><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530084143.png" alt="image-20210530084143676"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3、生产者"><a href="#3、生产者" class="headerlink" title="3、生产者"></a>3、生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br>    <span class="hljs-comment">//发送消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br><br>        <span class="hljs-comment">//创建连接mq的连接工厂对象</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">//设置连接rabbitMQ的主机</span><br>        factory.setHost(<span class="hljs-string">&quot;192.168.111.128&quot;</span>);<br>        <span class="hljs-comment">//设置端口号</span><br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//设置连接哪个虚拟主机</span><br>        factory.setVirtualHost(<span class="hljs-string">&quot;/test1&quot;</span>);<br>        <span class="hljs-comment">//设置访问虚拟主机的用户名和密码</span><br>        factory.setUsername(<span class="hljs-string">&quot;jiang&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br><br>        <span class="hljs-comment">//获取连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br><br>        <span class="hljs-comment">//获取连接中的通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        <span class="hljs-comment">//通道绑定对应的消息队列</span><br>        <span class="hljs-comment">/***</span><br><span class="hljs-comment">         * 参数1：队列名称  如果队列不存在会自动创建</span><br><span class="hljs-comment">         * 参数2：是否持久化</span><br><span class="hljs-comment">         * 参数3：是否独占队列</span><br><span class="hljs-comment">         * 参数4：是否在消费完成后自动删除队列</span><br><span class="hljs-comment">         * 参数5：额外附加参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：交换机  这里不需要</span><br><span class="hljs-comment">         * 参数2：队列名称</span><br><span class="hljs-comment">         * 参数3：传递消息额外设置</span><br><span class="hljs-comment">         * 参数4：消息的具体内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span>.getBytes());<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看web管理页面，可以看到自动创建了一个队列。并且队列中有一条消息。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530093419.png" alt="image-20210530093418943"></p><h4 id="4、消费者"><a href="#4、消费者" class="headerlink" title="4、消费者"></a>4、消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.111.128&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/test1&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;jiang&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br><br>        <span class="hljs-comment">//创建连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br><br>        <span class="hljs-comment">//创建通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br><br>        <span class="hljs-comment">//通道绑定对象   参数必须与生产者的的参数一致</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消费消息</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：开启消息的自动确认机制</span><br><span class="hljs-comment">         * 参数3：消费时的回调接口</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(java.lang.String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530102411.png" alt="image-20210530102411929"></p><p>此时web管理页面中队列中没有数据</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530102448.png" alt="image-20210530102448600"></p><h4 id="5、连接和关闭的工具类"><a href="#5、连接和关闭的工具类" class="headerlink" title="5、连接和关闭的工具类"></a>5、连接和关闭的工具类</h4><p>有大量的冗余代码。因此新建一个连接和关闭的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionUtils</span> &#123;<br><br>    <span class="hljs-comment">//返回连接对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection  <span class="hljs-title function_">Connect</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建连接工厂</span><br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            factory.setHost(<span class="hljs-string">&quot;192.168.111.128&quot;</span>);<br>            factory.setPort(<span class="hljs-number">5672</span>);<br>            factory.setVirtualHost(<span class="hljs-string">&quot;/test1&quot;</span>);<br>            factory.setUsername(<span class="hljs-string">&quot;jiang&quot;</span>);<br>            factory.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br><br>            <span class="hljs-comment">//创建连接对象</span><br>            <span class="hljs-keyword">return</span> factory.newConnection();<br>        &#125;<span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//关闭连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConn</span><span class="hljs-params">(Channel channel, Connection connection)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(channel != <span class="hljs-literal">null</span>)&#123;<br>                channel.close();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>)&#123;<br>                connection.close();<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、API的细节"><a href="#6、API的细节" class="headerlink" title="6、API的细节"></a>6、API的细节</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通道绑定队列</span><br>Queue.DeclareOk <span class="hljs-title function_">queueDeclare</span><span class="hljs-params">(String queue, <span class="hljs-type">boolean</span> durable, <span class="hljs-type">boolean</span> exclusive, <span class="hljs-type">boolean</span> autoDelete,</span><br><span class="hljs-params">                             Map&lt;String, Object&gt; arguments)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><ul><li><p>queue：队列名称</p></li><li><p>durable：是否将队列持久化，如果是true ，重启RabbitMQ时会重新创建队列，<strong>但不会将队列中的消息持久化</strong></p></li><li><p>exclusive：是否独占队列</p></li><li><p>autoDelete：是否自动删除队列。当队列中没有消息，并且没有消费者正在监听时会自动删除队列。</p></li></ul><h3 id="5、任务模型"><a href="#5、任务模型" class="headerlink" title="5、任务模型"></a>5、任务模型</h3><p><code>work queue</code>也称为<code>task queues</code>，任务模型。当消息处理比较耗时，可能生产者生产消息的速度远远大于消息的消费速度。因此，消息就会堆积越来越多。无法及时处理。</p><p>此时就可以使用任务模型：<strong>让多个消费者绑定一个队列，共同消费队列中的消息。</strong>队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530105549.png" alt="image-20210530105541874"></p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>        <span class="hljs-comment">//创建通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定对象   参数必须与生产者的的参数一致</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(java.lang.String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者1&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> TimeoutException, IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>        <span class="hljs-comment">//创建通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定对象   参数必须与生产者的的参数一致</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(java.lang.String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者2&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br>    <span class="hljs-comment">//发送消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br><br>        <span class="hljs-comment">//获取连接中的通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">//生产二十条消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span> + i).getBytes());<br>        &#125;<br><br><br>        ConnectionUtils.closeConn(channel,connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：我们先启动两个消费者，然后再启动生产者生产消息。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530123141.png" alt="image-20210530123134328"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530123340.png" alt="image-20210530123339957"></p><p>总结：<strong>在默认的情况下，RabbitMQ将按顺序将每条消息发送给下一个使用者。每个消费者都会受到相同的消息。称为轮询。</strong></p><h4 id="自动确认"><a href="#自动确认" class="headerlink" title="自动确认"></a>自动确认</h4><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530124724.png" alt="image-20210530124724347"></p><p>RabbitMQ默认是使用<strong>轮询</strong>的方式来发送消息给消费者。因此当生产者生产一条消息之后，就直接发送给对应的消费者，不关心消费者的情况。</p><p>但此时的消费者可能出现了问题。比如：被阻塞、异常，或者处理时间过长等。</p><p>此时消费者1被阻塞</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530130031.png" alt="image-20210530130031461"></p><p>消费者2已经消费完</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530130107.png" alt="image-20210530130107821"></p><p>对于自动确认来说：当方法没有异常执行完毕后，会对MQ发出ACK；若方法出现异常，会对MQ发出nack，消息会重回队列。<strong>要分清哪些是可以恢复的异常，哪些是不可以恢复的异常。不可恢复的异常，在消费者代码中捕获异常，并记录日志表或放入死信队列。可恢复的异常，那么放入业务队列中重试。</strong></p><h4 id="手动确认"><a href="#手动确认" class="headerlink" title="手动确认"></a>手动确认</h4><p>我们将autoack置为false，并且每一次只能消费一个消息。</p><p>同时消费完之后手动确认。</p><p>下面的代码中，消费者1消费的更快，消费者2消费慢。那么消费者1会消费更多的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-comment">//创建通道</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>    <span class="hljs-comment">//通道绑定对象   参数必须与生产者的的参数一致</span><br>    channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    channel.basicQos(<span class="hljs-number">1</span>);<br>    channel.basicConsume(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(java.lang.String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者1   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> TimeoutException, IOException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-comment">//创建通道</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>    <span class="hljs-comment">//通道绑定对象   参数必须与生产者的的参数一致</span><br>    channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>    channel.basicQos(<span class="hljs-number">1</span>);<br>    channel.basicConsume(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(java.lang.String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;消费者2   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530132954.png" alt="image-20210530132954363"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530132943.png" alt="image-20210530132943602"></p><h3 id="6、广播"><a href="#6、广播" class="headerlink" title="6、广播"></a>6、广播</h3><p><code>fanout</code>也成为广播。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530133348.png" alt="image-20210530133348191"></p><p>在广播模型下：消息发送流程是这样的。</p><ul><li>可以有多个消费者</li><li><strong>每个消费者都有自己的队列</strong></li><li><strong>每个队列都要绑定到交换机</strong></li><li>生产者发送的消息，只能发送到交换机，交换机来决定要发到哪个队列，生产者无法决定</li><li>交换机把消息发送给绑定的所有队列</li><li><strong>队列的消费者都能拿到消息</strong>。实现一条消息被多个消费者消费。</li></ul><h4 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//获取连接对象</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br><br>    <span class="hljs-comment">//将通道声明指定交换机</span><br>    <span class="hljs-comment">//广播模型</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 参数1：exchange 交换机</span><br><span class="hljs-comment">     * 参数2：routingKey  路由关键字  在下面两种模型使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//发送消息</span><br>    channel.basicPublish(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fanout type message&quot;</span>.getBytes());<br>    ConnectionUtils.closeConn(channel,connect);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br>    <span class="hljs-comment">//通道绑定交换机</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br><br>    <span class="hljs-comment">//临时队列</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br><br>    <span class="hljs-comment">//绑定交换机和队列</span><br>    channel.queueBind(queue,<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">//消费消息</span><br>    channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者1   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br>    <span class="hljs-comment">//通道绑定交换机</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br>    <span class="hljs-comment">//临时队列</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>    <span class="hljs-comment">//绑定交换机和队列</span><br>    channel.queueBind(queue,<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">//消费消息</span><br>    channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者2   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530195028.png" alt="image-20210530195028841"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530195012.png" alt="image-20210530195005079"></p><h3 id="7、Direct"><a href="#7、Direct" class="headerlink" title="7、Direct"></a>7、Direct</h3><p><code>在Fanout模型下，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这就用到了Direct类型的Exchange。</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530200025.png" alt="image-20210530200025805"></p><p>在Direct模型下：</p><ul><li><p>队列与交换机的绑定，不能是任务绑定了，而是指定一个<code>RoutingKey</code>。</p></li><li><p>消息的发送放在向<code>Exchange</code>发送消息时，也必须指定消息的<code>RoutingKey</code>。</p></li><li><p><code>Exchange</code>不再把消息交给每一个队列，而是根据消息的<code>RoutingKey</code>进行判断，只有队列的<code>RoutingKey</code>与消息的<code>Routingkey</code>一致时，才会接受消息。</p></li></ul><h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//获取连接对象</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br><br>    <span class="hljs-comment">//将通道声明指定交换机</span><br>    <span class="hljs-comment">//广播模型</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br><br>    <span class="hljs-comment">//发送消息</span><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 参数1：交换机</span><br><span class="hljs-comment">     * 参数2：路由关键字</span><br><span class="hljs-comment">     */</span><br>    channel.basicPublish(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;Customer1&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;direct type message 1&quot;</span>.getBytes());<br>    channel.basicPublish(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;Customer2&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;direct type message 2&quot;</span>.getBytes());<br>    ConnectionUtils.closeConn(channel,connect);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br>    <span class="hljs-comment">//通道绑定交换机</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br><br>    <span class="hljs-comment">//临时队列</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br><br>    <span class="hljs-comment">//绑定交换机和队列</span><br>    channel.queueBind(queue,<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;Customer1&quot;</span>);<br><br>    <span class="hljs-comment">//消费消息</span><br>    channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者1   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br>    <span class="hljs-comment">//通道绑定交换机</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>    <span class="hljs-comment">//临时队列</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>    <span class="hljs-comment">//绑定交换机和队列</span><br>    channel.queueBind(queue,<span class="hljs-string">&quot;exchange1&quot;</span>,<span class="hljs-string">&quot;Customer2&quot;</span>);<br>    <span class="hljs-comment">//消费消息</span><br>    channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者2   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530201314.png" alt="image-20210530201314100"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530201307.png" alt="image-20210530201307827"></p><h3 id="8、Topic"><a href="#8、Topic" class="headerlink" title="8、Topic"></a>8、Topic</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定在<code>RoutingKey</code>的时候使用<strong>通配符</strong>。</p><p>这种模型<code>RoutingKey</code>一般都是由一个或多个单词组成。多个单词之间以<code>.</code>分割，例如：<code>item.insert</code>。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530202438.png" alt="image-20210530202438147"></p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">* 匹配不多不少恰好<span class="hljs-number">1</span>个词<br><span class="hljs-meta"># 匹配一个或多个词</span><br><br>例如：<br>audit.<span class="hljs-meta">#    只能audit.irs.corporate  或者   audit.irs等</span><br>audit.*    只能匹配  audit.irs<br><br></code></pre></td></tr></table></figure><h4 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//获取连接对象</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br><br>    <span class="hljs-comment">//将通道声明指定交换机</span><br>    <span class="hljs-comment">//广播模型</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br><br>    <span class="hljs-comment">//发送消息</span><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 参数1：交换机</span><br><span class="hljs-comment">     * 参数2：路由关键字</span><br><span class="hljs-comment">     */</span><br>    channel.basicPublish(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.save.test&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;topic type message&quot;</span>.getBytes());<br>    ConnectionUtils.closeConn(channel,connect);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br>    <span class="hljs-comment">//通道绑定交换机</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br><br>    <span class="hljs-comment">//临时队列</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br><br>    <span class="hljs-comment">//绑定交换机和队列</span><br>    channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.*&quot;</span>);<br><br>    <span class="hljs-comment">//消费消息</span><br>    channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者1   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530203810.png" alt="image-20210530203809948"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> ConnectionUtils.Connect();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connect.createChannel();<br>    <span class="hljs-comment">//通道绑定交换机</span><br>    channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>    <span class="hljs-comment">//临时队列</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>    <span class="hljs-comment">//绑定交换机和队列</span><br>    channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.#&quot;</span>);<br>    <span class="hljs-comment">//消费消息</span><br>    channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者2   &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210530203838.png"></p><h3 id="9、SpringBoot整合RabbitMQ"><a href="#9、SpringBoot整合RabbitMQ" class="headerlink" title="9、SpringBoot整合RabbitMQ"></a>9、SpringBoot整合RabbitMQ</h3><h4 id="1、-搭建初始环境"><a href="#1、-搭建初始环境" class="headerlink" title="1、 搭建初始环境"></a>1、 搭建初始环境</h4><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">rabbitMQ-springboot</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置RabbitMQ</span><br><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.111.128</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">jiang</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">123</span><br><span class="hljs-attr">spring.rabbitmq.virtual-host</span>=<span class="hljs-string">/test1</span><br></code></pre></td></tr></table></figure><h4 id="2、直连模型"><a href="#2、直连模型" class="headerlink" title="2、直连模型"></a>2、直连模型</h4><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = RabbitmqdemoApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRabbitMQ</span> &#123;<br>    <span class="hljs-comment">//注入rabbitTemplate</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//参数1：队列，有消费者创建</span><br>        <span class="hljs-comment">//参数2：消息</span><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-comment">//创建队列，并设置队列参数</span><br><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hello</span> &#123;<br>    <span class="hljs-comment">//回调函数</span><br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message : &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、-任务模型"><a href="#2、-任务模型" class="headerlink" title="2、 任务模型"></a>2、 任务模型</h4><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = RabbitmqdemoApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRabbitMQ</span> &#123;<br>    <span class="hljs-comment">//注入rabbitTemplate</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">workTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-string">&quot;work&quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">work</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive1</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者1  &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive2</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者2  &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210531122106.png" alt="image-20210531122059284"></p><h4 id="3、广播模型"><a href="#3、广播模型" class="headerlink" title="3、广播模型"></a>3、广播模型</h4><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = RabbitmqdemoApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRabbitMQ</span> &#123;<br>    <span class="hljs-comment">//注入rabbitTemplate</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanout</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fanout模型数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fanout</span> &#123;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">        @QueueBinding(</span><br><span class="hljs-meta">            value = @Queue,</span><br><span class="hljs-meta">            exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;)</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive1</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message1  &quot;</span> + message);<br>    &#125;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">        @QueueBinding(</span><br><span class="hljs-meta">            value = @Queue,</span><br><span class="hljs-meta">            exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;)</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive2</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message2  &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210531123205.png" alt="image-20210531123205281"></p><h4 id="4、路由模型"><a href="#4、路由模型" class="headerlink" title="4、路由模型"></a>4、路由模型</h4><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = RabbitmqdemoApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRabbitMQ</span> &#123;<br>    <span class="hljs-comment">//注入rabbitTemplate</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRoute</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directs&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>,<span class="hljs-string">&quot;发送info路由信息&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Route</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    exchange = @Exchange(value = &quot;directs&quot;,type = &quot;direct&quot;),</span><br><span class="hljs-meta">                    key = &#123;&quot;info&quot;,&quot;error&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive1</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    exchange = @Exchange(value = &quot;directs&quot;,type = &quot;direct&quot;),</span><br><span class="hljs-meta">                    key = &#123;&quot;error&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive2</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210531124440.png" alt="image-20210531124440561"></p><h4 id="5、动态路由"><a href="#5、动态路由" class="headerlink" title="5、动态路由"></a>5、动态路由</h4><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = RabbitmqdemoApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRabbitMQ</span> &#123;<br>    <span class="hljs-comment">//注入rabbitTemplate</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTopic</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.save.test&quot;</span>,<span class="hljs-string">&quot;user.save.test路由消息&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Topic</span> &#123;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    exchange = @Exchange(name = &quot;topics&quot;,type = &quot;topic&quot;),</span><br><span class="hljs-meta">                    key = &#123;&quot;user.*&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive1</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    exchange = @Exchange(name = &quot;topics&quot;,type = &quot;topic&quot;),</span><br><span class="hljs-meta">                    key = &#123;&quot;user.#&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive2</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210531125047.png" alt="image-20210531125047616"></p>]]></content>
    
    
    
    <tags>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="/2021/02/05/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/05/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><blockquote><p>垃圾回收，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p><p>关于垃圾回收有三个问题：</p><ul><li>什么是垃圾</li><li>什么时候回收</li><li>如何回收</li></ul><p>垃圾回收机制是Java的招牌。<strong>极大地提高了开发效率</strong>。</p><p>如今，垃圾回收几乎成为了现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进，不同大小的设备、不同的特征的应用场景，对垃圾回收提出了新的挑战。</p></blockquote><h3 id="1、-垃圾回收概述"><a href="#1、-垃圾回收概述" class="headerlink" title="1、 垃圾回收概述"></a>1、 垃圾回收概述</h3><h4 id="1、什么是垃圾（Garbage）"><a href="#1、什么是垃圾（Garbage）" class="headerlink" title="1、什么是垃圾（Garbage）"></a>1、什么是垃圾（Garbage）</h4><p><code>垃圾是指 在运行程序中没有任何指向的对象。这个对象就是需要被回收的垃圾。</code></p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直被保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致<strong>内存溢出</strong>。</p><h4 id="2、为什么需要垃圾回收"><a href="#2、为什么需要垃圾回收" class="headerlink" title="2、为什么需要垃圾回收"></a>2、为什么需要垃圾回收</h4><ul><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收。就好像不停地生产生活垃圾而从来不打扫一样。</li><li>除了释放没用的对象，垃圾回收也可以消除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端。以便<strong>JVM将整理出的内存分配给新的对象</strong>。</li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW（Stop The World）的GC又跟不上实际的需求，没有不断地尝试对GC进行优化。</li></ul><h4 id="3、早期的垃圾回收机制"><a href="#3、早期的垃圾回收机制" class="headerlink" title="3、早期的垃圾回收机制"></a>3、早期的垃圾回收机制</h4><p>在早期的C&#x2F;C++时代，垃圾回收基本是手工进行的。开发人员使用new 关键字进行内存申请，并使用delete关键字进行内存释放。</p><p>比如下面的代码：C&#x2F;C++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">MibBridge *pBridge = new cmBaseGroupBridge();<br><span class="hljs-comment">//如果注册失败，使用Delete释放该对象所占的内存区域</span><br><span class="hljs-keyword">if</span>(pBridge -&gt; Register(kDestroy) != NO_ERROR)<br>    delete pBridge;<br></code></pre></td></tr></table></figure><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清楚，随着系统运行时间不断增长，垃圾对象所耗内存可能持续上升，直到出现<strong>内存溢出</strong>并造成应用程序崩溃。</p><p>在有了垃圾回收机制后，上述代码块就可能变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Mibridge *pBridge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">cmBaseGroupBridge</span>();<br>pBridge-&gt;Register(kDestroy);<br></code></pre></td></tr></table></figure><p>到如今，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收机制的思想，这也是未来发展的趋势。</p><h4 id="4、Java垃圾回收机制"><a href="#4、Java垃圾回收机制" class="headerlink" title="4、Java垃圾回收机制"></a>4、Java垃圾回收机制</h4><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong>。</p><p>如果没有垃圾回收器，Java也会和cpp一样，有各种的野指针，悬垂指针。各种泄漏问题。</p><p>自动内存管理，将程序员从繁重的内存管理中释放出来，可以更专心于业务开发。</p><blockquote><p>对于Java开发人员而言，自动内存管理像是一个黑匣子。如果过度依赖于“自动”，那么这将会是一场灾难，最严重就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OOM时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾回收成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p></blockquote><p>&#x3D;&#x3D;Java内存中的哪些区域需要回收&#x3D;&#x3D;：方法区和堆区</p><p>Java的堆是垃圾回收器的重点。</p><p>频繁收集新生代</p><p>较少收集老年代</p><p>基本不动元空间</p><h3 id="2、垃圾回收的相关概念"><a href="#2、垃圾回收的相关概念" class="headerlink" title="2、垃圾回收的相关概念"></a>2、垃圾回收的相关概念</h3><h4 id="1、System-gc"><a href="#1、System-gc" class="headerlink" title="1、System.gc()"></a>1、System.gc()</h4><p>在默认的情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用。会<strong>触发Full GC</strong>，同时对老年代和新生代进行垃圾回收，尝试释放被丢弃对象占用的内存。</p><p>然而System.gc()调用附带一个免责声明，<strong>无法保证对垃圾收集器的调用</strong>。</p><p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。<strong>而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用垃圾回收期 回收了Demo3对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3</span>();<br>        <span class="hljs-comment">//仅仅是提醒JVM的垃圾回收器，但不一定会执行</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了两次finalize()方法，将两个对象全部回收。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210519150955.png" alt="image-20210519150850981"></p><p>只调用System.gc()方法垃圾回收器可能不会进行Full GC，但可以通过System.runFinalization()强制执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.gc();<br><span class="hljs-comment">//强制回收</span><br>System.runFinalization();<br></code></pre></td></tr></table></figure><h4 id="2、内存溢出和内存泄漏"><a href="#2、内存溢出和内存泄漏" class="headerlink" title="2、内存溢出和内存泄漏"></a>2、内存溢出和内存泄漏</h4><p>&#x3D;&#x3D;内存溢出（OOM）&#x3D;&#x3D;</p><blockquote><p>​内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>​由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存的消耗的速度。否则不大容易出现OOM的情况。</p><p>​大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行，就会来一次Full GC操作。这时候会回收大量的内存，供应用程序继续使用。</p></blockquote><p>OutOfMemoryError：<strong>没有空闲的内存，并且垃圾回收也无法提供更多的内存。</strong></p><p>在抛出OutOfMemoryError之前，通常垃圾回收期会被触发，尽其所能去清理空间。如果分配一个超大对象，需要的内存直接超过了堆空间的最大值。那么者直接抛出OOM异常。</p><p>堆内存空间不够的原因</p><ol><li><p><strong>Java虚拟机的堆内存设置不够</strong></p><p>比如：我们需要处理大量的数据，设置的数值偏小或者没有显示指定虚拟机内存大小。可以通过参数-Xms和-Xmx来调整。</p><p>也有可能是内存泄漏，造成内存不够，最后处理数据时内存溢出。</p></li><li><p><strong>代码中创建了大量大对象，并且长时间不能被垃圾回收期收集。</strong></p><p>在项目的框架中，我们会创建大量的对象，这些对象占用的内存非常大，而且随着项目的运行会一直存在虚拟机中，并且存放在老年代中。</p></li></ol><p>&#x3D;&#x3D;内存泄漏&#x3D;&#x3D;</p><p>对于Java来说：<strong>只有对象不会在被程序用到了，但是GC又不能回收它们的情况，叫做内存泄漏。</strong></p><p>尽管内存泄漏并不会立刻导致程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM异常，导致程序崩溃。</p><blockquote><p>这里的存储空间不是物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p></blockquote><p>举例：</p><ol><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的问题。</p></li><li><p>一些提供close的资源未关闭导致内存泄漏</p><p>数据库连接（dataSourse.getConnection），网络连接（socket），io操作等必须手动close，否则是不能被回收的。</p></li></ol><h4 id="3、Stop-The-World（STW）"><a href="#3、Stop-The-World（STW）" class="headerlink" title="3、Stop The World（STW）"></a>3、Stop The World（STW）</h4><p><strong>在GC事件发生的过程中，会产生应用程序（用户线程）的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，这个停顿称为STW。</strong></p><p>比如：</p><p>在可达性分析算法中，我们要找出所有的GC Roots，这时候就需要STW。</p><p>因为：分析工作必须在一个能确保一致性的快照中进行。一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。如果时间在变化，那么引用对象也在变化，那么就无法保证找到正确的GC Roots。</p><p>STW和采用哪款GC无关，所有的GC都有这个事件。只能说优秀的垃圾回收器会尽可能的缩短暂停时间。</p><p>在开发中，不要使用System.gc()，这样会导致STW的发生。</p><h4 id="4、垃圾回收的并行与并发"><a href="#4、垃圾回收的并行与并发" class="headerlink" title="4、垃圾回收的并行与并发"></a>4、垃圾回收的并行与并发</h4><p>&#x3D;&#x3D;程序中的并行与并发&#x3D;&#x3D;：</p><p>并发：在<strong>一段时间段</strong>中有几个程序都处于已启动到运行完毕之间，且这<strong>几个程序都是在同一处理器上运行</strong>。</p><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分为几个时间片段（时间区间），然后在这几个时间区间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210519185252.png" alt="image-20210519185128143"></p><p>并行：当<strong>系统有一个以上CPU</strong>时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时进行。</strong></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210519185457.png" alt="image-20210519185457093"></p><p>&#x3D;&#x3D;垃圾回收中的并发和并行&#x3D;&#x3D;</p><p>不同的垃圾回收器执行情况是不一样的。</p><p><strong>并行垃圾回收器</strong>：指多条垃圾回收线程并行工作，但此时用户线程仍处于等待状态。</p><p>比如：PawNew、Parallel Scavenge、Parallel Old。</p><p><strong>并发垃圾回收器</strong>：指用户线程与垃圾回收线程同时执行，但不一定是并行的，可能会交替执行，<strong>垃圾回收线程在执行时不会停顿用户线程的运行</strong>。</p><p>比如：CMS、G1</p><h4 id="5、安全点和安全区域"><a href="#5、安全点和安全区域" class="headerlink" title="5、安全点和安全区域"></a>5、安全点和安全区域</h4><h6 id="x3D-x3D-安全点-x3D-x3D"><a href="#x3D-x3D-安全点-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;安全点&#x3D;&#x3D;"></a>&#x3D;&#x3D;安全点&#x3D;&#x3D;</h6><p>在进行STW时，程序并非在所有地方都能停顿下来开始GC，只有特定的位置才能停顿下来开始GC，这些位置称为安全点（Safe Point）。</p><p>Safe Point的选择是很重要的，如果太少可能会导致GC等待的时间太长，如果太频繁可能会导致运行时的性能问题。我们通常会选择一些执行时间较长的指令作为Safe Point，比如方法调用、循环跳转和异常跳转。 </p><p>如何在GC发生时，检查所有的线程都到达了最近的安全点停顿下来：</p><ul><li><p>抢先式中断：（目前没有虚拟机采用了）</p><p>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p></li><li><p>主动式中断</p><p>设置一个中断标志，各个线程运行到Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p></li></ul><h6 id="x3D-x3D-安全区域-x3D-x3D"><a href="#x3D-x3D-安全区域-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;安全区域&#x3D;&#x3D;"></a>&#x3D;&#x3D;安全区域&#x3D;&#x3D;</h6><p>SafePoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的SafePoint。但是，程序不执行的时候，比如线程处于Sleep状态或者Blocked状态。这时候线程无法响应JVM的中断请求，无法到达安全点。对于这种情况，就需要安全区域来解决。</p><p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。</strong>我们可以把安全区域看做是被扩展的安全点。</p><h4 id="6、引用"><a href="#6、引用" class="headerlink" title="6、引用"></a>6、引用</h4><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中。如果内存空间在进行垃圾回收后还是很紧张，则可以抛弃这些对象。</p><h5 id="1、强引用：不回收"><a href="#1、强引用：不回收" class="headerlink" title="1、强引用：不回收"></a>1、强引用：不回收</h5><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj &#x3D; new Object()”。这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾回收期永远不会回收被引用的对象。</strong></p><p>在Java程序中，最常见的就是强引用 ，也是默认的引用类型。</p><p>强引用时造成Java<strong>内存泄漏的</strong>主要原因之一。</p><h5 id="2、软引用：内存不足回收"><a href="#2、软引用：内存不足回收" class="headerlink" title="2、软引用：内存不足回收"></a>2、软引用：内存不足回收</h5><p><strong>在系统将要发生内存溢出之前，将会把这些弱引用对象列入回收范围之中进行第二次回收</strong>。如果这次回收之后还没有足够的内存，才会抛出OOM异常。</p><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空间内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p> 程序：</p><p>我们设置堆内存为10M</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-Xms10m -Xmx10m<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceTest</span> &#123;<br><span class="hljs-comment">//定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>        <span class="hljs-keyword">public</span> String name;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String name)</span>&#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                    <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//创建对象，建立软引用</span><br>        SoftReference&lt;User&gt; userSoftReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jiang&quot;</span>));<br><br>        <span class="hljs-comment">//从软引用中重新获得强引用对象</span><br>        System.out.println(userSoftReference.get());<br>        <br>        <span class="hljs-comment">//强制回收</span><br>        System.gc();<br>        System.runFinalization();<br>        <span class="hljs-comment">//再看是否有对象</span><br>        System.out.println(userSoftReference.get());<br><br>        <span class="hljs-comment">//让系统认为内存资源紧张</span><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">7</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//最后看是否有对象</span><br>            System.out.println(userSoftReference.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210519201424.png" alt="image-20210519201424873"></p><p>可以看到，在第一个强制进行GC之后，软引用依旧存在，之后我们定义大量的数据，内存OOM异常。此时软引用会被回收。</p><h5 id="3、弱引用：内存足够回收"><a href="#3、弱引用：内存足够回收" class="headerlink" title="3、弱引用：内存足够回收"></a>3、弱引用：内存足够回收</h5><p>被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，<strong>无论空间是否足够，都会回收被弱引用关联的对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>        <span class="hljs-keyword">public</span> String name;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String name)</span>&#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                    <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        WeakReference&lt;User&gt; userWeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jiang&quot;</span>));<br><br>        <span class="hljs-comment">//从弱引用中重新获得强引用对象</span><br>        System.out.println(userWeakReference.get());<br><br>        System.gc();<br>        <span class="hljs-comment">//强制回收</span><br>        System.runFinalization();<br><br>        System.out.println(userWeakReference.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210519202725.png" alt="image-20210519202725779"></p><p><strong>WeakHashMap</strong></p><p>Map本身生命周期很长，需要长期贮留内存中，但Map中的Entry可以删除，使用时可以从其它地方再次取得。</p><h5 id="4、虚引用：对象回收跟踪"><a href="#4、虚引用：对象回收跟踪" class="headerlink" title="4、虚引用：对象回收跟踪"></a>4、虚引用：对象回收跟踪</h5><blockquote><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。</p><p>如果一个对象仅持有虚引用，那么就和没有引用是一样。随时都可能被垃圾回收器回收。</p><p>他不能单独的使用，也无法通过虚引用来获取被引用的对象。当通过虚引用的get()方法取得对象时，总是返回null。</p></blockquote><p><strong>为一个对象设置虚引用关联的唯一目的就是在这个对象被收集器回收时收到一个系统通知。</strong></p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。<strong>当垃圾回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，已通知引用程序对象的回收情况。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.PhantomReference;<br><span class="hljs-keyword">import</span> java.lang.ref.ReferenceQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhantomReferenceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PhantomReferenceTest obj;<span class="hljs-comment">//当前类对象的声明</span><br>    <span class="hljs-keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="hljs-literal">null</span>;<span class="hljs-comment">//引用队列</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckRefQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (phantomQueue != <span class="hljs-literal">null</span>) &#123;<br>                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (objt != <span class="hljs-literal">null</span>) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; <span class="hljs-comment">//finalize()方法只能被调用一次！</span><br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类的finalize()方法&quot;</span>);<br>        obj = <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckRefQueue</span>();<br>        t.setDaemon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span><br>        t.start();<br><br>        phantomQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();<br>        obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReferenceTest</span>();<br>        <span class="hljs-comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span><br>        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//不可获取虚引用中的对象</span><br>            System.out.println(phantomRef.get());<br><br>            <span class="hljs-comment">//将强引用去除</span><br>            obj = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span><br>            System.gc();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 可用&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第 2 次 gc&quot;</span>);<br>            obj = <span class="hljs-literal">null</span>;<br>            System.gc(); <span class="hljs-comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 可用&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、垃圾回收的算法"><a href="#3、垃圾回收的算法" class="headerlink" title="3、垃圾回收的算法"></a>3、垃圾回收的算法</h3><h4 id="1、-标记阶段：对象存活判断"><a href="#1、-标记阶段：对象存活判断" class="headerlink" title="1、 标记阶段：对象存活判断"></a>1、 标记阶段：对象存活判断</h4><p>在堆里存放着几乎所有的Java对象实例，<strong>在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经是死亡的对象</strong>，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数算法和可达性分析算法</strong></p><h5 id="1-1、引用计数算法"><a href="#1-1、引用计数算法" class="headerlink" title="1.1、引用计数算法"></a>1.1、引用计数算法</h5><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整性的引用计数器属性。用于记录队对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象的引用计数器的值为0。即表示对象A不可能再被使用，可进行回收。</p><blockquote><p>引用计数算法的优点：</p><ol><li>实现简单，垃圾对象便于辨认。</li><li>判定效率高，回收没有延迟性。（与可达性分析算法对比）</li></ol><p>引用计数算法的缺点：</p><ol><li>它需要单独的字段存储计数器，增加了存储空间的开销</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作。增加了时间的开销</li><li>引用计数器有一个重要的问题，即<strong>无法处理循环引用的问题</strong>。这是引用计数的致命缺陷。</li></ol></blockquote><p>下面有三个对象互相指向。其中rc就是引用计数。</p><p>当我们将p指向第一个对象的指针断开。其他三个对象的rc都变为了1，但此时这三个对象应该是垃圾，但此时rc不为0，永远不能被收集。因此出现了内存泄漏。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210515234132.png" alt="image-20210515233601133"></p><p>引用计数算法，是很多语言的资源回收选择，例如Python，他更多同时支持引用计数和垃圾回收机制。</p><p>Python如何解决循环引用问题：</p><ul><li>手动解除：手动解除对象之间的引用关系。</li><li>使用弱引用weakref，它是python提供的标准库，旨在解决循环引用。</li></ul><h5 id="1-2、可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#1-2、可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="1.2、可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>1.2、可达性分析算法（根搜索算法、追踪性垃圾收集）</h5><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以<strong>有效地解决循环引用问题，防止内存泄漏问题</strong>。</p><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾回收通常也叫做追踪性垃圾回收（Tracing Garbage Collection）。</p><p>&#x3D;&#x3D;GC Roots 是一组必须活跃的对象集合&#x3D;&#x3D;</p><p>在Java中，GC Roots包含以下几类元素：</p><ul><li><p>虚拟机栈中引用的对象</p><p>比如：各种线程被调用的方法使用到的参数、局部变量</p></li><li><p>本地方法栈内JNI（通常说的本地方法）引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p><p>比如：Java类的引用类型静态变量</p></li><li><p>方法区中常量引用的对象</p><p>比如：字符串常量池（String Table）中的引用。</p></li><li><p>所有被同步锁synchronized持有的对象</p></li><li><p>Java虚拟机内部的引用</p><p>基本数据类型对应的Class对象，一些常驻的异常对象（NullPointerException、OutOfMemoryError），系统类加载器。</p></li><li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p></li></ul><p>可达性分析算法的基本思路：</p><ol><li>可达性分析算法是以跟对象集合（GC Roots）为起始点，按照从上至下的方式搜索被跟对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被跟对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被跟对象集合直接或间接连接的对象才是存活对象</li></ol><p> <img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210516000624.png" alt="image-20210516000624470"></p><blockquote><p>注意：</p><p>​如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话，分析结果的准确性就无法保证了。</p><p>​因此GC进行时有Stop The World</p></blockquote><h5 id="1-3、对象的finalization机制"><a href="#1-3、对象的finalization机制" class="headerlink" title="1.3、对象的finalization机制"></a>1.3、对象的finalization机制</h5><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p><p>当垃圾回收器发现一个没有引用指向的一个对象，即垃圾回收此对象之前，总会先调用这个对象的finalize()方法</p><p>finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放，通常在这个方法中进行一些资源释放和清理工作，比如关闭文件，套接字和数据库连接等。<strong>这个方法只能被调用一次</strong>。</p><p>从功能上来说，finalize()方法和C++中的析构函数比较相似。但是Java采用的是基于垃圾回收期的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。</p><blockquote><p>永远不要主动调用finalize()方法：</p><ul><li>在finalize()时可能会导致对象复活</li><li>finalize()方法的执行时间是没有保障的，他完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li>一个糟糕的finalize()会严重影响GC的性能。</li></ul></blockquote><p>如果从所有的根基欸但都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”，这个时候对象暂时处于缓刑的阶段。<strong>一个无法触及的对象可能在某一个条件下复活自己</strong>。</p><p>因此，<strong>虚拟机中的对象一般处于三种可能的状态</strong>：</p><ul><li><code>可触及的</code>：从根节点开始，可以到达这个对象。（活）</li><li><code>可复活的</code>：对象的所有引用都被释放，但是对象有可能在finalize()方法中复活。（复活）</li><li><code>不可触及的</code>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只能被调用一次。（死）</li></ul><h5 id="1-4、判断一个对象是否被回收过程"><a href="#1-4、判断一个对象是否被回收过程" class="headerlink" title="1.4、判断一个对象是否被回收过程"></a>1.4、判断一个对象是否被回收过程</h5><p>判定一个对象Obj是否被回收，至少要经历两次标记过程：</p><ol><li>如果对象Obj到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法。<ol><li>如果对象Obj没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过了，则虚拟机视为没有必要执行此方法。Obj被判定为不可触及的对象。</li><li>如果Obj对象重写了finalize()方法，且还未执行过，那么Obj会被插入到<strong>F-Queue队列</strong>中，有一个虚拟机自动创建的、低优先级的Funalizer线程触发其finalize()方法执行。</li><li><strong>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记</strong>。如果Obj在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，Obj会被移出“即将回收” 的集合（<strong>可复活对象</strong>）。之后，<strong>对象会再次出现没有引用存在</strong>的情况。在这个情况下，finalize()不会在调用，<strong>对象会直接变成不可触及的状态</strong>，也就是说，一个对象的finalize()方法只会被调用一次。</li></ol></li></ol><h4 id="2、清除阶段：垃圾清除"><a href="#2、清除阶段：垃圾清除" class="headerlink" title="2、清除阶段：垃圾清除"></a>2、清除阶段：垃圾清除</h4><p>当成功区分出内存中<strong>存活对象和死亡对象</strong>后，GC接下来的任务就是执行<strong>垃圾回收</strong>，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在JVM中比较常见的三种垃圾收集算法是：标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）</p><p><strong>什么是清除</strong>：</p><p>这里的所说的清除并不是真的置空，而是把<strong>需要清除的对象地址保存在空闲的地址列表里</strong>。下次有新对象需要加载时，判断垃圾的位置空间是否够用，如果够用，就存放。</p><h5 id="2-1、标记-清除算法（Mark-Sweep）"><a href="#2-1、标记-清除算法（Mark-Sweep）" class="headerlink" title="2.1、标记-清除算法（Mark-Sweep）"></a>2.1、标记-清除算法（Mark-Sweep）</h5><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法。该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</p><p>算法执行过程：</p><p>当堆中的有效空间被耗尽的时候，就会停止整个程序（Stop The World），然后进行两项工作，第一项是标记，第二项是清除。</p><ul><li>标记：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般在对象的Header中记录为可达对象</li><li>清除：Collector对<strong>堆内存从头到尾的线性遍历</strong>，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li></ul><blockquote><p>标记-清除算法缺点：</p><p>效率不高</p><p>在进行GC的时候，需要停止整个应用程序，导致用户体验差</p><p>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表。</p></blockquote><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210517201112.png" alt="image-20210517201104902"></p><h5 id="2-2、复制算法（Copying）"><a href="#2-2、复制算法（Copying）" class="headerlink" title="2.2、复制算法（Copying）"></a>2.2、复制算法（Copying）</h5><p>为了解决标记-清除算法在垃圾回收效率方面的缺陷，M.L.Minsky在论文中提出双存储区的垃圾回收算法。</p><p>复制算法的核心思想：</p><p>&#x3D;&#x3D;将活着的内存空间分成两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中。之后清除正在使用的内存块中的所有对象，交换两个内存的角色。最后完成垃圾回收。&#x3D;&#x3D;</p><p>我们找到A区所有的存活对象，并将这个对象以到B区，最后将A区中的对象全部清除。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210517202216.png" alt="image-20210517202216672"></p><blockquote><p>复制算法的优点：</p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题</li></ul><p>复制算法的缺点：</p><ul><li>需要两倍的内存空间</li><li>对于G1这种分拆称为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li></ul></blockquote><p>如果系统需要的复制的对象太多，这种算法的效率会非常低。</p><p>在堆的新生代中，大多数对象都是朝生夕死的，因此在新生代中使用复制算法是非常高效的。</p><h5 id="2-3、标记-压缩算法（Mark-Compact）"><a href="#2-3、标记-压缩算法（Mark-Compact）" class="headerlink" title="2.3、标记-压缩算法（Mark-Compact）"></a>2.3、标记-压缩算法（Mark-Compact）</h5><p>复制算法的<strong>高效性</strong>是建立在存活对象少、垃圾对象多的前提下。这种情况下在新生代经常发生。但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。因此，<strong>基于老年代的垃圾回收的特性</strong>，需要使用其他的算法。</p><p>标记-清除算法可以应用在老年代中，但是该算法不仅执行效率底下，而且清除之后还存在内存碎片，因此标记-压缩算法由此诞生。</p><p>标记-压缩算法的执行过程：</p><p>第一阶段：从根节点开始标记所有被引用对象</p><p>第二阶段：将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有空间。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210517222445.png" alt="image-20210517222438451"></p><p>标记-清除算法和标记-压缩算法的区别：</p><p>标记-压缩算法的最终效果等同于标记-消除执行完成之后，<strong>再进行一次内存碎片整理</strong>。因此也可以把它称为标记-清除-压缩算法（Mark-Sweep-Comoact）。二者的本质差异在于标记-清除算法是一种<strong>非移动的回收算法</strong>。标记-压缩算法是移动的。</p><blockquote><p>是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><ul><li>标记的存活对象将会被整理，按照内存地址依次排列，这样在回收阶段效率会降低。</li><li>我们在为新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多的开销。</li></ul></blockquote><blockquote><p> 标记-整理算法优点和缺点</p><p>优点：</p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点。</li><li>消除了复制算法当中，内存减半的高额代价</li></ul><p>缺点</p><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户的应用程序。（STW）</li></ul></blockquote><h5 id="2-4、三种算法的对比"><a href="#2-4、三种算法的对比" class="headerlink" title="2.4、三种算法的对比"></a>2.4、三种算法的对比</h5><p>垃圾回收算法的三个指标：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210517224657.png" alt="image-20210517224657424"></p><p>从效率上来说，复制算法是当之无愧的最高效。但是浪费了太多的内存。</p><p>而为了尽量兼顾上面提高的三个指标，标记-整理算法相对来说更平滑。但是效率太差。它比复制算法多一个标记阶段。比标记-清除多一个整理内存的阶段。</p><h4 id="3、分代收集算法"><a href="#3、分代收集算法" class="headerlink" title="3、分代收集算法"></a>3、分代收集算法</h4><p>前面所有这些的算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这个一个事实：<strong>不同的对象的生命周期是不一样的。</strong></p><p>因此不同的生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般来说，我们把Java堆分成新生代和老年代。这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><blockquote><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关的。比如：<strong>Http请求中的session对象、线程、Socket连接，这些对象跟业务直接挂钩，因此生命周期比较长</strong>。但是还有一些对象，主要<strong>程序运行过程中生成的临时变量</strong>，这些对象生命周期会比较短。比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p></blockquote><p>目前几乎所有的GC都是采用分代收集（Generational Collection）算法执行垃圾回收。</p><p>在HotSopt中，基于分代的概念，<strong>GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</strong>。</p><ul><li>年轻代</li></ul><p>年轻代的特点：区域相对老年代较小，对象生命周期短，存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题。通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代</li></ul><p>老年代的特点：区域较大，对象生命周期长，存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除算法或者标记-清除与标记-整理的混合实现。</p><p>Mark阶段的开销与存活对象的数量成正比</p><p>Sweep阶段的开销与所管理区域的大小成正比</p><p>Compact阶段的开销与存活对象的数据成正比</p><h4 id="4、增量收集算法"><a href="#4、增量收集算法" class="headerlink" title="4、增量收集算法"></a>4、增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop The  World  的状态。在STW状态下，应用程序中的所有线程都是挂起的。暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久。将严重影响用户体验或者系统的稳定性。</p><p>为了解决这种问题，即对实时垃圾收集算法的研究直接导致了<strong>增量收集算法</strong>的诞生</p><p>基本思想：</p><p>如果一次性将所有垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><blockquote><p>增量收集算法的基础仍是传统的标记-清除和复制算法。</p><p>增量收集算法通过线程间的冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p></blockquote><blockquote><p>缺点：</p><p>线程切换和上下文转换的消耗，造成系统的吞吐量下降。</p></blockquote><h4 id="5、分区算法"><a href="#5、分区算法" class="headerlink" title="5、分区算法"></a>5、分区算法</h4><p>一般来说：在相同条件下，堆越大，一次GC是所需要的时间就越长。有关GC产生的停顿也就越长。为了更好地控制GC产生的停顿时间，将一块大的区域分割成多个小块。根据目标的停顿时间，每次合理地回收若干个小区间（region）。而不是整个堆空间。从而减少一次GC所产生的停顿。</p><p><strong>分代算法将按照对象的生命周期长短划分为两个部分，分区将整个堆空间划分为连续的不同的小区间。</strong></p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个区间。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210524200553.png" alt="image-20210517235402109"></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><blockquote><p>垃圾回收器没有在规范中进行过多的规定，可以有不同的厂商、不同的版本的JVM来实现。</p><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p></blockquote><h4 id="1、-垃圾回收器的分类和性能指标"><a href="#1、-垃圾回收器的分类和性能指标" class="headerlink" title="1、 垃圾回收器的分类和性能指标"></a>1、 垃圾回收器的分类和性能指标</h4><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>&#x3D;&#x3D;按线程数来分&#x3D;&#x3D;：可以分为串行垃圾回收器和并行垃圾回收器。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520214726.png" alt="image-20210520214718969"></p><p>串行回收指的是在同一时间段内只允许有一个CPU用于垃圾回收操作。此时工作线程被暂停，直至垃圾回收工作结束。</p><p>并行回收可以运行多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制。</p><p>&#x3D;&#x3D;按工作模式来分&#x3D;&#x3D;：可以分为并发式垃圾回收器和独占式垃圾回收器</p><p>并行式垃圾回收器与应用程序线程交替工作，已尽可能减少应用程序的停顿时间。</p><p>独占式垃圾回收器（STW）一旦运行，就停止应用程序中的所有用户线程。直至垃圾回收过程完全结束。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520215642.png" alt="image-20210520215642258"></p><p>&#x3D;&#x3D;按碎片处理方式&#x3D;&#x3D;：可分为压缩式垃圾回收器和非压缩式垃圾回收器</p><ul><li><p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，清除回收后的碎片。再分配对象空间使用：指针碰撞</p></li><li><p>非压缩式的垃圾回收器不进行这步操作，再分配对象空间使用：空闲列表</p></li></ul><p>&#x3D;&#x3D;按工作的内存区间&#x3D;&#x3D;：又可分成年轻代垃圾回收器和老年代垃圾回收器。</p><h5 id="性能指标："><a href="#性能指标：" class="headerlink" title="性能指标："></a>性能指标：</h5><p>&#x3D;&#x3D;吞吐量&#x3D;&#x3D;：运行用户代码的时间占总运行时间的比例。</p><p>（总运行时间 &#x3D; 程序的运行时间  +  内存回收的时间）</p><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p><p>&#x3D;&#x3D;暂停时间&#x3D;&#x3D;：执行垃圾回收时，程序的工作线程被暂停时间。</p><p>收集频率：相对于应用程序的执行，回收操作发生的频率。</p><p>&#x3D;&#x3D;内存占用&#x3D;&#x3D;：Java堆区所占的内存大小</p><p>快速：一个对象从诞生被回收所经历的时间</p><p>其中我们主要关注的是：<strong>吞吐量、暂停时间</strong></p><p><strong>吞吐量</strong>：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。</p><p>吞吐量 &#x3D; 运行用户代码时间 &#x2F; （运行用户代码时间 + 垃圾回收时间）</p><p>比如：虚拟机总共运行100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p><strong>暂停时间</strong>：是指一个时间段内应用程序暂停，让GC线程执行的状态。</p><p>比如：GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520221758.png" alt="image-20210520221757926"></p><p>吞吐量和暂停时间的对比：</p><p>高吞吐量较高因为这会让应用程序的最终<strong>用户感觉只有应用程序在做“生产性”工作。</strong>不会感觉到GC的存在。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来所，不管是CG还是用户进程被挂起始终是不好。可能会打断终端用户的体验。特别是交互式的应用程序。</p><p><strong>如果以高吞吐量优先：必然会降低内存回收的执行频率</strong></p><p><strong>如果以低延迟优先：只能频率地执行内存回收。</strong></p><h4 id="2、垃圾回收器概述"><a href="#2、垃圾回收器概述" class="headerlink" title="2、垃圾回收器概述"></a>2、垃圾回收器概述</h4><h5 id="1-7中经典的垃圾回收器"><a href="#1-7中经典的垃圾回收器" class="headerlink" title="1. 7中经典的垃圾回收器"></a>1. 7中经典的垃圾回收器</h5><p>串行回收器：Serial、Serial Old</p><p>并行回收器：ParNew、Parallel Scavenge</p><p>并发回收器：CMS、G1</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210520225641.png" alt="image-20210520225641315"></p><h5 id="2-垃圾回收器和垃圾分代之间的关系："><a href="#2-垃圾回收器和垃圾分代之间的关系：" class="headerlink" title="2. 垃圾回收器和垃圾分代之间的关系："></a>2. 垃圾回收器和垃圾分代之间的关系：</h5><p>新生代回收器：Serial、ParNew、Paraller Scavenge</p><p>老年代回收器：Serial Old、Parallel Old、CMS</p><p>整堆收集器：G1</p><h5 id="3-垃圾回收器的组合关系："><a href="#3-垃圾回收器的组合关系：" class="headerlink" title="3. 垃圾回收器的组合关系："></a>3. 垃圾回收器的组合关系：</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210521221409.png" alt="image-20210520230049729"></p><h5 id="4-为什么要有这么多的收集器"><a href="#4-为什么要有这么多的收集器" class="headerlink" title="4. 为什么要有这么多的收集器"></a>4. 为什么要有这么多的收集器</h5><p>因为Java的使用场景很多，移动端，服务端等。所以就需要针对不同的场景，提供不同的垃圾收集器。提高垃圾回收的性能。<strong>我们对各个收集器比较，并非挑选一个最好的收集器，而是针对具体的应用挑选一个最合适的收集器。</strong></p><h5 id="5-如何查看默认的垃圾收集"><a href="#5-如何查看默认的垃圾收集" class="headerlink" title="5. 如何查看默认的垃圾收集"></a>5. 如何查看默认的垃圾收集</h5><p>在Java1.8中，查看默认的垃圾收集器。</p><p>加上参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+PrintCommandLineFlags<br></code></pre></td></tr></table></figure><p>打印出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:InitialHeapSize=132362496 -XX:MaxHeapSize=2117799936 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC <br></code></pre></td></tr></table></figure><p>最后一个<code>-XX:+UseParallelGC</code>：代表新生代使用的是：<code>Parallel GC </code>。那么老年代会自动选择<code>Parallel Old GC</code>。</p><h4 id="3、Serial回收器：串行回收"><a href="#3、Serial回收器：串行回收" class="headerlink" title="3、Serial回收器：串行回收"></a>3、Serial回收器：串行回收</h4><p>Serial收集器是最基本、历史最悠久的垃圾收集器。在JDK1.3之前是回收新生代唯一的选择。</p><p><strong>Serail收集器采用复制算法、串行回收和“Stop-The-World”机制的方式执行内存回收。</strong></p><p>除了年轻代之外，Serail收集器还提供用于执行老年代垃圾回收器的<code>Serial Old</code>收集器。Serial Old收集器同样采用了串行回收和“Stop - The - World”机制。只不过<strong>内存回收算法使用的是压缩算法</strong>。</p><p>Serail收集器作为HotSpot中Client模式下的默认新生代垃圾收集器，Serila Old是默认的老年代收集器。</p><p>在Server端，Serial Old主要有两个用途：</p><ol><li>与新生代Parallel Scavenge配合使用</li><li>作为老年代CMS收集器的后备方案</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210521221405.png" alt="image-20210520233937688"></p><p>Serial是一个单线程的收集器，<strong>单线程并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾回收时，必须暂停其他所有的工作线程。直到它收集结束。</strong></p><blockquote><p> Serial的优势</p><p>简单高效：以其他收集器的单线程相比。Serial收集器没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p></blockquote><p>使用SerialGC：</p><p>虚拟机参数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+UserSerialGC<br></code></pre></td></tr></table></figure><p>新生代使用Serail GC 且老年代使用Serial Old GC</p><p>&#x3D;&#x3D;总结：&#x3D;&#x3D;</p><p>现在的计算机都是多核，使用Serial效率低。</p><p>对于交互强的应用而言，这种垃圾收集器是不能接受的。</p><h4 id="4、ParNew回收器：并行回收"><a href="#4、ParNew回收器：并行回收" class="headerlink" title="4、ParNew回收器：并行回收"></a>4、ParNew回收器：并行回收</h4><p>Serial GC是年轻代中的单线程垃圾收集器，而ParNew回收器则是Serail收集器的多线程版本。</p><p>ParNew收集器除了<strong>采用并行回收</strong>的方式执行内存回收外，两款垃圾收集器几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、“Stop-The-World”机制。</p><p>ParNew是很多JVM运行在Srever模式下新生代的默认的垃圾收集器。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210521221400.png" alt="image-20210520235824160"></p><p>上图中，在新生代中，我们使用ParNew收集器，在老年代中，使用Serial Old收集器。</p><p>因为新生代回收次数频繁，使用并行方式高效。对于老年代，回收次数少，并行会造成上下文切换，使用串行方式节省资源。</p><blockquote><p>由于ParNew收集器是基于并发回收，那么是否可以断定ParNew一定比Serial高效吗？</p><p>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快地完成垃圾收集。提升程序的吞吐量。</p><p>但在<strong>单个CPU环境中</strong>，ParNew不比Serial更高效。</p></blockquote><p>在程序中，开发人员可以通过参数<code>-XX:+UserParNewGC</code>手动指定使用ParNew收集器执行内存回收任务。但它仅仅表示在年轻代中使用ParNew，不会影响老年代。</p><p>我们还可以通过参数<code>-XX:ParallelGCThreads</code>限定线程数量。默认开启和CPU数据相同的线程数。</p><h4 id="5、Parallel回收器：吞吐量优先"><a href="#5、Parallel回收器：吞吐量优先" class="headerlink" title="5、Parallel回收器：吞吐量优先"></a>5、Parallel回收器：吞吐量优先</h4><blockquote><p>高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，在常见的服务器环境中使用。例如：执行批量处理，订单处理，工资支付，科学计算的应用程序。</p></blockquote><p>Parallel优势年轻代中基于并行回收的回收器。</p><p>Parallel Scavenge收集器同样使用复制算法、并行回收和“Stop-The-World”机制</p><blockquote><p> 与ParNew回收器有什么不同？</p><ul><li><p>Parallel Scavenge收集器的目标是达到可控制的吞吐量。他也被成为吞吐量优先的垃圾收集器。</p></li><li><p>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。自适应调节是指：动态调整内存的分配</p></li></ul></blockquote><p><code>Parallel Old</code>收集器是JDK1.6时提供用于执行老年代收集器，用来代替<code>Serial Old</code>收集器。</p><p><code>Parallel Old</code>收集器采用了标记-压缩算法，但同样也是基于并行回收和“Stop-The-World”机制。</p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。Java8默认的垃圾收集器。</p><p>&#x3D;&#x3D;Parallel Scavenge回收器的参数&#x3D;&#x3D;：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+UserParallelGC<br><br>手动指定年轻代使用Parallel GC 并行收集器。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+UserParallelOldGC<br><br>手动指定老年代使用Parallel Old GC<br><br>对于这两个参数，只要开启一个，并一个会自动开启。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:ParallelGCThreads<br><br>设置年轻代并行收集器的线程数。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:MaxGCPauseMillis<br><br>设置垃圾收集器最大停顿时间，即STW的时间，单位是毫秒<br>为了尽可能地把停顿时间空间在MaxGCPauseMillis以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好。但是在服务端，我们注重高并发，整体的吞吐量。所以服务端适合Parallel。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:GCTimeRatio<br><br>垃圾回收时间占总时间的比例<br>取值范围(0,100).默认值99，也就是垃圾回收时间不超过1%<br>与-XX:MaxGCPauseMillis有矛盾，暂停时间越长，Radio参数就容易超过设定的比例<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+UseAdaptiveSizePolicy<br><br>设置Parallel Scavenge收集器具有自适应调节策略<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数都会自动调整<br>让虚拟机自己完成调优工作。<br></code></pre></td></tr></table></figure><h4 id="6、CMS回收器：低延迟"><a href="#6、CMS回收器：低延迟" class="headerlink" title="6、CMS回收器：低延迟"></a>6、CMS回收器：低延迟</h4><blockquote><p>​目前很大一部分的Java应用集中在互联网站或B&#x2F;S系统的服务器上，这类应用尤其重视服务的响应速度。希望系统停顿时间最短。已给用户带来较好的体验。CMS收集器就非常符和这类应用的需求。</p></blockquote><p>CMS（Concurrent-Mark-Sweep）收集器是一款老年代的收集器。但无法与新生代收集器Parallel Scavenge配合工作。</p><p>CMS这款收集器是HotSpot虚拟机中<strong>第一款</strong>真正意义上的<strong>并发收集器</strong>，它第一次实现了让垃圾收集器线程与用户线程同时工作。</p><p>CMS收集器的关注点是<strong>尽可能缩短垃圾收集时用户线程的停顿时间</strong>。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p>CMS的垃圾收集算法采用的是标记-清除算法。并且也会”Stop - The - World”。</p><p>&#x3D;&#x3D;CMS整个过程分成四个阶段&#x3D;&#x3D;：</p><p>初始标记、并发标记、重新标记和并发清除。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210521221400.png" alt="image-20210521221353658"></p><ol><li><p>初始标记（Initial - Mark）阶段：在这个阶段，程序中所有的工作线程都将会<strong>因为”Stop - The - World”机制而出现短暂的暂停</strong>这个阶段的主要任务仅仅是<strong>标记出GC Roots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快。</strong></p></li><li><p>并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，<strong>这个过程耗时较长但是不需要停顿用户线程</strong>。可以与垃圾收集线程一起并发运行。</p></li><li><p>重新标记（ReMark）阶段：由于并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行，由于为了修正并发标记期间，<strong>因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>。这个阶段的停顿时间通常会比初始标记阶段稍长一点，但也远比并发标记阶段的时间短。</p></li><li><p>并发清除（Concurrent-Sweep）阶段：此阶段清理删除标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发执行。</p></li></ol><p>&#x3D;&#x3D;CMS的特点&#x3D;&#x3D;</p><p>尽管CMS收集器采用的是并发回收（非独占式），但是在<strong>初始阶段</strong>和<strong>重新标记</strong>阶段都需要执行STW机制来暂停程序的工作线程。不过暂停时间的不会太长。</p><blockquote><p>目前的垃圾收集器都做不到完全不需要STW，只能尽可能缩短暂停时间。</p></blockquote><p>由于最耗费时间的<strong>并发标记</strong>与<strong>并发清除</strong>阶段都不需要暂停工作，所以成体的回收是低停顿的。</p><blockquote><p>由于垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，<strong>还应该确保应用程序用户线程有足够的内存可用。</strong>因此，CMS收集器不能像其他收集器那样等到老年代几乎完全填满再进行收集。<strong>而是当堆内存使用率达到了某一阈值时，</strong>便开始进行回收，以确保应用程序再CMS工作过程中依旧有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要。就会出现**”Concurrent Mode Failure”**失败，这是虚拟机将启动后备预案：临时Serial Old收集器来重新进行老年代的垃圾收集。这样停顿时间就很长了。</p></blockquote><p>CMS收集器的垃圾回收算法采用的是<strong>“标记-清除算法”</strong>，这意味着每次执行内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的内存块。不可避免的产生一些内存碎片。那么CMS在为新对象分配内存空间时，只能选择空闲列表。执行内存分配。</p><blockquote><p>为什么使用标记-压缩算法：</p><p>因为CMS是并发收集器。并发清理阶段是和用户线程一起执行的。我们不能去改变线程的地址。 </p></blockquote><p>CMS的弊端：</p><ol><li><p><strong>会产生内存碎片</strong>：</p><p>导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC</p></li><li><p><strong>CMS收集器堆CPU资源非常敏感</strong></p><p>在并发阶段。它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢。总吞吐量会降低。</p></li><li><p><strong>CMS无法处理浮动的垃圾</strong></p><p>可能出现“Concurrent Mode Failure”失败而导致另一次Fill GC的产生。在并发标记阶段由于程序的工作线程和垃圾是收集线程是同时运行或者交叉运行的。<strong>那么在并发标记阶段如果产生新的垃圾对象。</strong>CMS将无法对这些垃圾对象进行标记，<strong>最终会导致这些新产生垃圾对象没有被即使回收</strong>，从而只能在下一次执行GC时释放这些之前未被会回收的内存空间。</p></li></ol><p>CMS收集器设置参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+UseConcMarkSweepGC <br><br>手动指定使用CMS收集器执行内存回收任务。<br>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew(新生代) + CMS（老年代） + Serial Old的组合。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:CMSInitiatingOccupanyFraction<br><br>设置堆内存使用率的阈值，一旦达到该阈值。便开始进行回收。<br>JDK1.5及以前版本的默认值时68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6以后版本默认值为92%。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+UseCMSCompactAtFullCollection<br><br>用于指定在执行完Full GC后对内存空间进行压缩整理。但是无法并发进行整理，那么停顿时间变得更长了<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:CMSFullGCsBeforeCompaction<br><br>设置在执行多少次Full GC后对内存空间进行压缩整理<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:ParallelCMSThreads<br><br>设置CMS的线程数量<br></code></pre></td></tr></table></figure><h4 id="7、G1收集器：区域化分代式"><a href="#7、G1收集器：区域化分代式" class="headerlink" title="7、G1收集器：区域化分代式"></a>7、G1收集器：区域化分代式</h4><h5 id="为什么还有发布G1"><a href="#为什么还有发布G1" class="headerlink" title="为什么还有发布G1"></a>为什么还有发布G1</h5><ol><li><p>业务越来越庞大、复杂、用户越来越多。</p></li><li><p>为了适应不断扩大的内存和不断增加的处理器数量</p></li></ol><p>官方给G1设定的目标是<strong>在延迟可控的情况下，获得尽可能高的吞吐量</strong>。所以G1担当起“全功能收集器”的重任和期望。</p><blockquote><p>为什么名字叫做Garbage First（G1）？</p><ol><li><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存区0、幸存区1、老年代等。</p></li><li><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小记忆回收所需要的时间的经验值）。在后台维护一个优先列表。每次根据允许的手机时间，优先回收价值最大的Region。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（region），所以我们为G1去一个名字：</p><p><strong>垃圾优先（Garbage First）。</strong></p></li></ol></blockquote><p>G1(Garbage - Frist)是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还要兼备高吞吐量的性能特征。</p><p>在JDK1.7盘本正式启用，移除了Experumental的标识，是JDK 9以后默认的垃圾回收器。被Oracle官方称为“最全功能的垃圾收集器”。与此同时，CMS已经被标记为废弃。</p><h5 id="G1回收器的优势："><a href="#G1回收器的优势：" class="headerlink" title="G1回收器的优势："></a>G1回收器的优势：</h5><ol><li><p>并行与并发</p><p>并行性：G1在回收期间，<strong>可以在多个GC线程同时工作</strong>，有效利用多核计算能力。<strong>此时用户线程STW</strong>。</p><p>并发性<strong>：G1拥有与应用程序交替执行的能力</strong>，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</p></li><li><p>分代收集</p><p>从分代上看，G1依然属于分代型垃圾回收器，它会<strong>区分年轻代和老年代</strong>，年轻代依然有Eden区和Survivor区。但从堆的结构上看，他不要求<strong>整个Eden区，年轻代或老年代都是连续的</strong>。也不再坚持固定大小和固定数量。</p><p>将堆空间分成若干个区域（Region），这些区域中<strong>包含了逻辑上的年轻代和老年代</strong>。</p><p>和之前的各类回收器不同，他同时<strong>兼顾年轻代和老年代</strong>。</p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210524200516.png" alt="image-20210524183606405"></p><ol start="3"><li><p>空间整合</p><p>G1将内存划分为一个个的region。<strong>内存的回收是以region作为基本单位。Region之间是复制算法，但整体上实际可看做是标记-压缩算法</strong>。这两种都可以避免内存碎片。</p><p>这种特性有利于程序长时间运行，分配大对象是不会因为无法找到连续内存空间而提前触及下一次GC。</p></li><li><p>可预测的停顿时间模型</p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿之外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内。消耗在垃圾回收上的时间不得超过N毫秒。</p><p><strong>G1跟踪各个Region里面的垃圾堆积的价值大小。（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p></li></ol><h5 id="G1回收器的缺点："><a href="#G1回收器的缺点：" class="headerlink" title="G1回收器的缺点："></a>G1回收器的缺点：</h5><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高。</p><p>从经验上说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h5 id="G1回收器的参数："><a href="#G1回收器的参数：" class="headerlink" title="G1回收器的参数："></a>G1回收器的参数：</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+UseG1GC<br><br>手动指定使用G1收集器执行内存回收任务<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:+G1HeapRegionSize<br><br>设置每个Region的大小。值为2的幂。范围是1MB到32MB之间。<br>目标是根据最小的Java堆大小划分为大约2048个区域。<br>默认是堆内存的1/2000。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-X:MaxGCPauseMillis<br><br>设置期望达到的最大GC停顿时间指标<br>默认值是200ms<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:ParallelGCThread<br><br>设置STW工作线程数的值。最多设置为8<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-X:ConcGCThreads<br><br>设置并发标记的线程数。将n设置为并行垃圾回收线程数的1/4左右<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:InitiatingHeapOccupancyPercent<br><br>设置触发并发GC周期的Java堆占用率阈值。超过这个值，就触发GC。<br>默认是45<br></code></pre></td></tr></table></figure><h5 id="关于Region：划整为零"><a href="#关于Region：划整为零" class="headerlink" title="关于Region：划整为零"></a>关于Region：划整为零</h5><p>使用G1收集器时，他将整个Java堆划分成大约2048个大小相同的独立Region块。每个Region块的大小根据堆空间的实际大小而定。<strong>所有的Region大小相同。且在JVM生命周期内不会被改变。</strong></p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了。它们都是一部分Region的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210524200516.png" alt="image-20210524183606405"></p><p>一个region有可能属于Eden、Survivor或者Old&#x2F;Tenured内存区域。但是一个region只能属于一个区域。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域。主要用于存储大对象，如果超过1.5个region，就放在H中。</p><h5 id="G1回收器垃圾回收过程："><a href="#G1回收器垃圾回收过程：" class="headerlink" title="G1回收器垃圾回收过程："></a>G1回收器垃圾回收过程：</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210524200516.png" alt="image-20210524191629387"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载器</title>
    <link href="/2021/02/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2021/02/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="1-类加载器概述"><a href="#1-类加载器概述" class="headerlink" title="1.类加载器概述"></a>1.类加载器概述</h3><p>​<code>类加载就是将磁盘上的class文件加载到内存中。虚拟机设计团队把类加载阶段的&quot;通过一个类的全限定名获取描述此类的二进制字节流&quot;这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为&quot;类加载器&quot;。类加载器是JVM执行类加载机制的前提。</code></p><h4 id="ClassLoader的作用"><a href="#ClassLoader的作用" class="headerlink" title="ClassLoader的作用"></a>ClassLoader的作用</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># ClassLoader的作用</span><br>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的。<br>ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个于目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于他是否可以运行，则由Execution Engine决定。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Class、ClassLoader和实例对象的关系</span><br>在下图中：<br>类模板数据User Class 和ClassLoader之间是相互引用的关系。<br>在ClassLoader中，记录了加载类的集合，有那些类是由这个ClassLoader加载的。<br>我们可以通过Class创建实例对象<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416184233.png" alt="image-20210416184151816"></p><h4 id="类加载的命名空间"><a href="#类加载的命名空间" class="headerlink" title="类加载的命名空间"></a>类加载的命名空间</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 何为类的唯一性</span><br>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。<br><br>每一个类加载器，都会拥有一个独立的类名称空间:<br>比较两个类是否相等，只有在这两个类是由同一类加载器加载的前提下才有意义。<br>否则即使这两个类源自同一Class文件，被同一个虚拟机加载，只要加载他们类加载器不同，那这两个类就必定不相等。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 命名空间</span><br><span class="hljs-bullet">-</span> 每一个类加载器都有自己命名空间，命名空间由该加载器及所有的父加载器锁加载的类组成。<br><span class="hljs-bullet">-</span> 在同一命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类，只加载一次类。<br><span class="hljs-bullet">-</span> 在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类，可以加载多次。<br></code></pre></td></tr></table></figure><h4 id="类加载机制的特征"><a href="#类加载机制的特征" class="headerlink" title="类加载机制的特征"></a>类加载机制的特征</h4><ol><li><p>双亲委派机制</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">双亲委派模型，不是所有的类加载都遵守这个模型。<br></code></pre></td></tr></table></figure></li><li><p>可见性</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。<br></code></pre></td></tr></table></figure></li><li><p>单一性</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。<br>但是，类加载器&quot;邻居&quot;间，同一类型仍然可以被加载多次，因为互相并不可见。<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-类加载分类"><a href="#2-类加载分类" class="headerlink" title="2.类加载分类"></a>2.类加载分类</h3><p>​<code>JVM支持两种类型的类加载器，分别是启动类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)。</code></p><p>​<code>从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载结构主要是如下情况:</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416192539.png" alt="image-20210416192532384"></p><ul><li>除了顶层的启动类加载器，其余的类加载应当有自己的”父类“加载器。</li><li>不同类加载看似是继承关系，<code>实际上是包含关系。在下层加载器中，包含上层加载器的引用</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    ClassLoader parent;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParentClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;<br>        <span class="hljs-built_in">super</span>(parent);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChildClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;<br>        <span class="hljs-built_in">super</span>(parent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><ul><li><p>这个类加载使用C&#x2F;C++语言实现，嵌套在JVM内部。</p></li><li><p>用来加载Java核心库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容)，用于<code>提供JVM自身需要的类。</code></p></li><li><p><code>并不继承自java.lang.ClassLoader，没有所谓的父加载器</code></p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p></li><li><p>启动类加载器还用于去加载扩展类加载器和应用程序类加载器，并指定为他们的父类加载器。</p></li></ul><p>我们去加载这个一个类，去看一下它的ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416195107.png" alt="image-20210416195107806"></p><p>加载ClassLoader</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416195133.png" alt="image-20210416195133745"></p><p>加载自定义类加载器</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416195459.png" alt="image-20210416195458986"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Provider.class.getClassLoader();<br>        System.out.println(classLoader);<span class="hljs-comment">//null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><ul><li><p>有Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</p></li><li><p>继承于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的jar放在目录下，也会自动有扩展类加载器加载。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> SunEC.class.getClassLoader();<br>        System.out.println(classLoader);   <br>        System.out.println(classLoader.getParent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416200839.png" alt="image-20210416200839429"></p><h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><ul><li><p>Java语言编写，由sun.misc.Launcher$AppClassLoader实现</p></li><li><p>继承于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p></li><li><p>应用程序中的类加载器默认是系统类加载器。</p></li><li><p>它是用户自定义类加载器的默认父加载器。</p></li><li><p>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Test.class.getClassLoader();<br>        System.out.println(classLoader);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> classLoader;<br>        <span class="hljs-keyword">while</span>(loader != <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(loader.getParent());<br>            loader = loader.getParent();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416201450.png" alt="image-20210416201450867"></p><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416202239.png" alt="image-20210416202239533"></p><h3 id="3-ClassLoader源码分析"><a href="#3-ClassLoader源码分析" class="headerlink" title="3. ClassLoader源码分析"></a>3. ClassLoader源码分析</h3><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416202956.png" alt="image-20210416202956662"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerNatives</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        registerNatives();<br>    &#125;<br><br><span class="hljs-comment">//该类的父类加载器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br><br>   <br><span class="hljs-comment">//加载名称为name的类，返回结果为java.lang.Class类的实例。</span><br>    <span class="hljs-comment">//该方法时双亲委派机制的实现。下文详细解析</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">//根据名称读取文件存入字节数组</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);<br>    &#125;<br><br> <br><span class="hljs-comment">//查找二进制名称为name的类，返回结果为java.lang.Class实例。这是一个受保护的方法，</span><br>    <span class="hljs-comment">//jvm鼓励我们重写此方法，需要自定义加载器遵循双亲委派机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</span><br>    <br>    <span class="hljs-comment">//转换从Byte到类的实例</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len,<br>                                         ProtectionDomain protectionDomain)<br>        <span class="hljs-keyword">throws</span> ClassFormatError<br>    &#123;<br>        protectionDomain = preDefineClass(name, protectionDomain);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> defineClassSourceLocation(protectionDomain);<br>        Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);<br>        postDefineClass(c, protectionDomain);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-comment">//返回父类加载器进行委派</span><br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>            checkClassLoaderPermission(parent, Reflection.getCallerClass());<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-双亲委派模型"><a href="#4-双亲委派模型" class="headerlink" title="4. 双亲委派模型"></a>4. 双亲委派模型</h3><p><code>类加载器用来把来加载到Java虚拟机中，从jdk1.2开始，类加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</code></p><h4 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h4><p><code>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个类请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</code></p><p>实质上:<code>规定了类加载的顺序是:引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</code></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416204503.png" alt="image-20210416204503607"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210416204424.png" alt="image-20210416204424305"></p><h4 id="双亲委派机制的优势和劣势"><a href="#双亲委派机制的优势和劣势" class="headerlink" title="双亲委派机制的优势和劣势"></a>双亲委派机制的优势和劣势</h4><h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><ul><li><p>避免了类的重复加载，确保一个类的全局唯一性</p><p>Java类随着它的类加载器一起具备了一种带有优先级的层级关系，通过这种层级关系可以避免类的重复加载，<code>当父加载器已经加载了该类时，就没有必要子加载器再加载一次。</code></p></li><li><p>保护程序安全，防止核心API被随意篡改。</p></li></ul><h6 id="源码解释："><a href="#源码解释：" class="headerlink" title="源码解释："></a>源码解释：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  <span class="hljs-comment">//同步操作</span><br>        <span class="hljs-comment">// 首先，检查当前加载器的缓存中有无目标类。</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//判断当前加载器的父类加载器是否是空</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//如果不是，调用父类加载器的loadClass()</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果为空，让引导类加载器进行加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            &#125;<br><br>            <span class="hljs-comment">//如果还是为空，调用findClass()进行加载</span><br>            <span class="hljs-comment">//最终会调用defineClass系列的native接口加载目标类。</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//双亲委派模型就隐藏在第2步和第3步上<br><span class="hljs-bullet">1.</span> 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。<br><span class="hljs-bullet">2.</span> 判断当前加载器的父加载器是否为空，如果不为空，调用parent.loadClass(name,false)<br><span class="hljs-bullet">3.</span> 如果为空，调用引导类加载器加载<br><span class="hljs-bullet">4.</span> 如果还没有加载成功，调用findClass(name)接口进行加载，最终会调用defineClass加载目标类<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 问题</span><br>如果在自定义的类加载中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String,boolean)方法，<br>抹去其中的双亲委派机制，仅保留上面的第一步和第四步，是不是就能够加载类库了?<br><br>不行，因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器，最终都必须调用java.lang.ClassLoader.defineClass(String,byte[],int,int,ProtectDomain)方法，<br>而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。<br></code></pre></td></tr></table></figure><h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ul><li>顶层的ClassLoader无法访问到底层的ClassLoader所加载的类</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>Java虚拟机规范并没有明确要求类加载的加载机制一定要使用双亲委派机制</code>，只是建议采用这种方式而已。</p><p>在Tomcat中，类加载器所采用的加载机制和传统的双亲委派机制有一定的区别，当缺省的类加载器接受到一个类的加载任务时，<code>首先会由它自行加载</code>，当他加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2021/02/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><code>虚拟机把描述类的数据从Class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型有虚拟机预先定义，引用数据类型需要进行类的加载。<br><br>在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的灵活性。<br><br>Java作为可以动态扩展的语言这种特性，依赖于运行期动态加载和动态连接这个特点实现的。<br></code></pre></td></tr></table></figure><h3 id="2-类生命周期"><a href="#2-类生命周期" class="headerlink" title="2.类生命周期"></a>2.类生命周期</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括:加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)。<br><br>其中验证、准备、解析3个部分统称为连接(Linking)。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3fe69ece0b2a786b0ea981a88a37348b.png" alt="image-20210330084512036"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在类的生命周期中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定:它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。<br></code></pre></td></tr></table></figure><h3 id="3-Loading-加载-阶段"><a href="#3-Loading-加载-阶段" class="headerlink" title="3.Loading(加载)阶段"></a>3.Loading(加载)阶段</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 加载</span><br>就是将java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型-类模板对象。<br><br><span class="hljs-section"># 类模板对象</span><br>其实就是将Java类在jvm内存中的一个快照。jvm将从字节码文件中解析出的常量池、类字段、类方法等信息存储在类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。  反射的机制即基于这一基础。如果JVM没有将java类的声明信息存储起来，则JVM在运行期也无法反射。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在加载阶段，虚拟机完成以下3件事<br><span class="hljs-bullet">1.</span> 通过一个类的全限定名来获取定义此类的二进制字节流<br><span class="hljs-bullet">2.</span> 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构<br><span class="hljs-bullet">3.</span> 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">二进制流的获取方式：<br>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。<br><span class="hljs-bullet">1.</span> 虚拟机可能通过文件系统读入一个class后缀的文件(最常见)<br><span class="hljs-bullet">2.</span> 读入jar、zip、war等数据包，提取类文件。<br><span class="hljs-bullet">3.</span> 从网络中获取，applet<br><span class="hljs-bullet">4.</span> 运行时计算生成，这种场景使用得最多的就是动态代理技术。<br><span class="hljs-bullet">5.</span> 有其他文件生成，典型场景JSP应用。<br><span class="hljs-bullet">6.</span> 从数据库中读取<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 生成的类模板的位置</span><br>加载的类在JVM中创建相应的类结构，类结构会存储在方法区(java1.8之前:永久代，java1.8之后:元空间)<br><br><span class="hljs-section"># Class实例的位置</span><br>类将class文件加载至方法区之后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。<br><br>Class类的构造方法是私有的，只有JVM能够创建。<br></code></pre></td></tr></table></figure><h3 id="4-Linking-连接阶段"><a href="#4-Linking-连接阶段" class="headerlink" title="4.Linking(连接阶段)"></a>4.Linking(连接阶段)</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">加载阶段于连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。<br></code></pre></td></tr></table></figure><h4 id="4-1验证阶段-Verification"><a href="#4-1验证阶段-Verification" class="headerlink" title="4.1验证阶段(Verification)"></a>4.1验证阶段(Verification)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">验证阶段大致上会完成文件格式验证、元数据验证、字节码验证、符号引用验证<br></code></pre></td></tr></table></figure><p><strong>文件格式验证</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 文件格式验证</span><br>是否是以魔数0xCAFEBAVE<br>主、次版本号是否是当前虚拟机处理范围之内<br>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)<br>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量<br>......<br><br><span class="hljs-section"># 文件格式验证的目的</span><br>保证输入的字节流能正确地解析并存储与方法区之内，格式上符合描述一个Java类型信息的要求。<br>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法去的存储结构进行的，不会再直接操作字节流。<br></code></pre></td></tr></table></figure><p><strong>元数据验证</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 元数据验证</span><br>是否继承final<br>是否有父类<br>如果这个类不是抽象类，是否实现了父类或接口之中要求实现的所有方法<br>类中的字段、方法是否与父类产生了矛盾<br>......<br><br><span class="hljs-section"># 元数据验证的目的</span><br>对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。<br></code></pre></td></tr></table></figure><p><strong>字节码验证</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 字节码验证</span><br>跳转指令是否指向正确的位置<br>操作数类型是否合理<br>......<br><br><span class="hljs-section"># 字节码验证的目的</span><br>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<br><br>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的，但如果一个类方法体的字节码通过了字节码验证，也不能说明其一定安全。<br></code></pre></td></tr></table></figure><p><strong>符号引用验证</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 符号引用验证</span><br>符号引用的直接引用是否存在<br>......<br><br><span class="hljs-section"># 什么是符号引用</span><br>以一组符号来描述所引用的目标，付哈可以是任何形式的字面量，只要使用能无歧义地定位到目标即可。<br><br><span class="hljs-section"># 什么是直接引用</span><br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。<br><br><br><span class="hljs-section"># 符号引用的发生时间</span><br>符号引用的发生时间在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段--解析阶段中发生。<br><br><span class="hljs-section"># 符号引用的目的</span><br>对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。<br></code></pre></td></tr></table></figure><h4 id="4-2准备-Preparation"><a href="#4-2准备-Preparation" class="headerlink" title="4.2准备(Preparation)"></a>4.2准备(Preparation)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">为类的静态变量分配内存，并将其初始化为默认值。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">下图是Java基本数据类型的零值:<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c6afb7f3c955e6200d8a1dc4d12dc9ad.png" alt="image-20210330200934471"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例外:<br>如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，比如<br>public static final int value = 123;<br>编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue赋值为123<br></code></pre></td></tr></table></figure><h4 id="4-3解析-Resolution"><a href="#4-3解析-Resolution" class="headerlink" title="4.3解析(Resolution)"></a>4.3解析(Resolution)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程，符号引用在Class文件中它以CONSTANT<span class="hljs-emphasis">_Class_</span>info、CONSTANT<span class="hljs-emphasis">_Fieldref_</span>info等类型的常量出现。<br></code></pre></td></tr></table></figure><h3 id="5-初始化-Initialization"><a href="#5-初始化-Initialization" class="headerlink" title="5.初始化(Initialization)"></a>5.初始化(Initialization)</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户引用程序可以通过自定义类加载参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码。<br><br><span class="hljs-section"># 初始化目的</span><br>执行类的初始化方法: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法</span><br><span class="hljs-bullet">1.</span> 该方法仅能由java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法在Java程序中调用该方法，虽然该方法也是有字节码指令所组成。<br><span class="hljs-bullet">2.</span> 它是由类静态成员的赋值语句以及static语句块合并产生的。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 注意:</span><br>在加载一个类之前，虚拟机总会试图加载该类的父类，因此父类的<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法总是在子类<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法之前被调用<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法的线程安全性</span><br>虚拟机会保证一个类的<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法，其他线程都需要阻塞等待，直到活动线程执行<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">clinit</span>&gt;</span></span>()方法完毕。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 问题:</span><br>类是否初始化?<br>在代码中，有些类初始化了，有些类没有，需要对那些类进行初始化?<br>我们先需要了解主动使用和被动使用<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 主动使用和被动使用</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 主动使用(会发生初始化)</span><br>Class只有在必须要首次使用的时候才会被装载，java虚拟机不会无条件地装载Class类型。<br>java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里的&quot;使用&quot;是指主动使用。<br>主动使用只有下列几种情况:<br><span class="hljs-bullet">1.</span> 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。<br><br><span class="hljs-bullet">2.</span> 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br><br><span class="hljs-bullet">3.</span> 当初始化一个类的时候，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。<br><br><span class="hljs-bullet">4.</span> 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 被动使用(类不会初始化)</span><br><span class="hljs-bullet">1.</span> 通过子类引用父类的静态字段，不会导致子类初始化<br><br><span class="hljs-bullet">2.</span> 通过数组定义类引用类，不会触发此类的初始化<br><br><span class="hljs-bullet">3.</span> 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS问题</title>
    <link href="/2021/02/01/CAS%E9%97%AE%E9%A2%98/"/>
    <url>/2021/02/01/CAS%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h2><h3 id="1、共享资源的访问"><a href="#1、共享资源的访问" class="headerlink" title="1、共享资源的访问"></a>1、共享资源的访问</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-comment">///查询钱</span><br>    Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//取钱</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span>;<br><br>    <span class="hljs-comment">//设置一个静态方法，设置1000个线程  每个线程取钱</span><br>    <span class="hljs-comment">///在控制台打印余额和耗时</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Account account)</span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                account.withDraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(<span class="hljs-string">&quot;余额还有：&quot;</span> + account.getBalance() + <span class="hljs-string">&quot;   cost：&quot;</span> + (end-start)/<span class="hljs-number">1000_100</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1、加锁："><a href="#1、加锁：" class="headerlink" title="1、加锁："></a>1、加锁：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设计一个类，重写接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountSafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span>&#123;<br><span class="hljs-comment">//余额</span><br>    <span class="hljs-keyword">private</span> Integer balance;<br><span class="hljs-comment">//构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountSafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br><span class="hljs-comment">//</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.balance;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//取钱</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-built_in">this</span>.balance -= amount;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoSynchronized</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">accountSafe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountSafe</span>(<span class="hljs-number">10000</span>);<br>        Account.demo(accountSafe);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210508141737.png" alt="加锁保证线程安全"></p><h4 id="2、-CAS-无锁"><a href="#2、-CAS-无锁" class="headerlink" title="2、 CAS(无锁)"></a>2、 CAS(无锁)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountCAS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span>&#123;<br><br>    <span class="hljs-comment">//原子类</span><br>    <span class="hljs-keyword">private</span> AtomicInteger balance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountCAS</span><span class="hljs-params">(<span class="hljs-type">int</span> balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//获得余额的最新值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">//要修改的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br><br>            <span class="hljs-comment">//真正修改balance</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * balance.compareAndSet(prev,next)</span><br><span class="hljs-comment">             * 参数1：最新值</span><br><span class="hljs-comment">             * 参数2：修改后的结果</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next) == <span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCAS</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">accountCAS</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountCAS</span>(<span class="hljs-number">10000</span>);<br>        Account.demo(accountCAS);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210508142847.png" alt="无锁保证线程安全"></p><h3 id="2、CAS工作原理"><a href="#2、CAS工作原理" class="headerlink" title="2、CAS工作原理"></a>2、CAS工作原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-comment">//获得余额的最新值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>        <span class="hljs-comment">//要修改的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br><br>        <span class="hljs-comment">//真正修改balance</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * balance.compareAndSet(prev,next)</span><br><span class="hljs-comment">         * 参数1：最新值</span><br><span class="hljs-comment">         * 参数2：修改后的结果</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next) == <span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过CAS无锁的方式来保证线程安全。其中的关键是CompareAndSet，简称CAS(也可称为Compare And Swap)，它是一个由底层指令实现的原子操作。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">原理：<br>我们得到余额，计算出要修改的值。<br>然后我们在判断余额的最新值和余额是否一致。这一步是原子操作<br>如果是，返回true，并将余额改为要修改的值<br>如果不是，返回false，继续循环<br></code></pre></td></tr></table></figure><h5 id="CAS的工作原理："><a href="#CAS的工作原理：" class="headerlink" title="CAS的工作原理："></a>CAS的工作原理：</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210508143522.png" alt="CAS原理"></p><h5 id="CAS的底层实现"><a href="#CAS的底层实现" class="headerlink" title="CAS的底层实现"></a>CAS的底层实现</h5><blockquote><p>其实CAS的底层是lock cmpxchg指令(X86架构)，在单核CPU和多核CPU下都能够保证CAS的原子性</p></blockquote><h5 id="AtomicInteger原子类"><a href="#AtomicInteger原子类" class="headerlink" title="AtomicInteger原子类"></a>AtomicInteger原子类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查看AtomicInteger 源码</span><br><span class="hljs-comment">//AtomicInteger的值是一个int类型的变量 ，并且由volatile修饰</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;CAS必须要volatile的支持才能实现&#x3D;&#x3D;</p><h3 id="3、理解CAS"><a href="#3、理解CAS" class="headerlink" title="3、理解CAS"></a>3、理解CAS</h3><p>CAS可以无锁保证线程的安全性，但适用于线程数少，多核CPU的场景下。</p><ol><li>CAS是基于乐观锁的思想。最乐观的估计，不怕被其他线程修改，如果被改变了，只要重新修改值。</li><li>synchronized是基于悲观锁的思想：最悲观的估计，要防止其他线程来改变变量。</li><li>CAS体现的是无锁并发，无阻塞并发<ul><li>没有使用synchronized，所以线程不会陷入阻塞</li><li>但如果竞争激烈，重试必然频繁发生，效率会受到影响</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现Mybatis二级缓存</title>
    <link href="/2021/02/01/Redis%E5%AE%9E%E7%8E%B0mybatis%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <url>/2021/02/01/Redis%E5%AE%9E%E7%8E%B0mybatis%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Mybatis中的二级缓存"><a href="#Mybatis中的二级缓存" class="headerlink" title="Mybatis中的二级缓存"></a>Mybatis中的二级缓存</h2><h4 id="Myabtis-的二级缓存是如何实现的"><a href="#Myabtis-的二级缓存是如何实现的" class="headerlink" title="Myabtis 的二级缓存是如何实现的"></a>Myabtis 的二级缓存是如何实现的</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 在Mybatis中开启二级缓存</span><br>在Mapper.xml文件中加标签<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> /&gt;</span></span>  <br>开启二级缓存需要将实体类序列化，否则会出现错误<br><span class="hljs-code">Cause: java.io.NotSerializableException: com.jiang.travels.entity.User</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Mybatis的二级缓存的实现</span><br>mybatis中有一个接口Cache。<br>mybatis二级缓存的实现类是PerpetualCache.java,实现的是接口Cache<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409091451.png" alt="image-20210409091444602"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409091649.png" alt="image-20210409091649035"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们可以通过设置断点来证明PerpetualCache.java是二级缓存的实现类<br>在PerpetualCache.java中的getObject()方法设置一个断点<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409091938.png" alt="image-20210409091938771"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409092142.png" alt="image-20210409092142465"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们发现在程序停在了getObject()方法中。<br>此时我们可以知道key的值，和cacahe的size。<br>因此我们知道了Mybatis的二级缓存的实现类确实是PerpetualCache.java<br></code></pre></td></tr></table></figure><h4 id="解析PerpetualCache-java"><a href="#解析PerpetualCache-java" class="headerlink" title="解析PerpetualCache.java"></a>解析PerpetualCache.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们可以看到PerpetualCache非常的简单，实现的核心就是一个Map的数据结构</span><br><span class="hljs-comment">//但其实每个方法的执行是比较的复杂的，这个暂不分析，我们现在只需了解每个方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerpetualCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cache</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Object, Object&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">PerpetualCache</span><span class="hljs-params">(String id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> cache.size();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>    cache.put(key, value);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">return</span> cache.get(key);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">removeObject</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">return</span> cache.remove(key);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    cache.clear();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (getId() == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheException</span>(<span class="hljs-string">&quot;Cache instances require an ID.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Cache)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">Cache</span> <span class="hljs-variable">otherCache</span> <span class="hljs-operator">=</span> (Cache) o;<br>    <span class="hljs-keyword">return</span> getId().equals(otherCache.getId());<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (getId() == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheException</span>(<span class="hljs-string">&quot;Cache instances require an ID.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> getId().hashCode();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们了解完PerpetualCache.java的实现类，知道了Mybatis的二级缓存的原理。那么我们通过redis来实现Mybatis的二级缓存就很简单了。<br></code></pre></td></tr></table></figure><h2 id="redis实现Mybatis二级缓存"><a href="#redis实现Mybatis二级缓存" class="headerlink" title="redis实现Mybatis二级缓存"></a>redis实现Mybatis二级缓存</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们已经知道了Mybatis二级缓存的原理，实现的是PerpetualCache.java。<br><br>我们可以自己来创建一个类，实现Cache接口。重写put，get方法。<br>但是我们怎么让Mybatis知道? 就像我们如何让Spring容器知道我们注册了一个类。<br><br>我们说过，只有在Mapper.xml文件中添加<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Cache</span> /&gt;</span></span>标签才能使用二级缓存。而在<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Cache</span> /&gt;</span></span>标签中有几个属性<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409094254.png" alt="image-20210409094246879"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mark">其中type属性就是决定实现类。<br>默认    &lt;cache type=&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;/&gt;<br></code></pre></td></tr></table></figure><h4 id="RedisCache"><a href="#RedisCache" class="headerlink" title="RedisCache"></a>RedisCache</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">到现在，我们基本上可以知道RedisCache的原理和实现<br><br><span class="hljs-bullet">1.</span> 创建一个RedisCache类，并implements Cache接口<br><span class="hljs-bullet">2.</span> 实现RedisCache中的方法<br><span class="hljs-bullet">3.</span> 在Mapper.xml文件中 type=&quot;XXXXX.RedisCache&quot;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 自定义Redis缓存的实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cache</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">removeObject</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="id的作用"><a href="#id的作用" class="headerlink" title="id的作用"></a>id的作用</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">RedisCache的基本框架就是这样。<br>我们与PerpetualCache.java进行对比，我们发现少了许多的东西。<br><span class="hljs-bullet">1.</span> private final String id;<br><span class="hljs-bullet">2.</span> private final Map<span class="language-xml">&lt;Object, Object&gt;</span> cache = new HashMap&lt;&gt;();<br><br>对于Map&lt;&gt; cache很容易理解<br>我们来分析id的含义<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># private final String id;</span><br>我们并不知道id的作用是什么，我们首先来使用这个Cache，来判断这个id是否是必须的。<br>注意更改实现类    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.jiang.travels.cache.RedisCache&quot;</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409100123.png" alt="image-20210409100123846"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 出现了错误：</span><br>错误中由这样一句话:<br>Base cache implementations must have a constructor that takes a String id as a parameter.  <br>必须有一个构造器带id。<br>此时我们依旧不知道这个id是什么用。<br>不过，既然出现了错误，我们就改:为RedisCache实现类添加常量id，并添加构造函数<br>private final String id;<br><br>public RedisCache(String id) &#123;<br>   System.out.println(&quot;id = &quot; + id);<br>   this.id = id;<br>&#125;<br><br>@Override<br>public String getId() &#123;<br>   return id;<br>&#125;<br><br>我们打印这个id到底是什么。<br>此时并没有报错，并且数据已经从数据库中查到<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409100752.png" alt="image-20210409100752912"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409100833.png" alt="image-20210409100833215"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们终于知道了这个id 的含义:这就是Mapper.xml文件中的namespace<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409101026.png" alt="image-20210409101026749"></p><h4 id="实现方法get-put"><a href="#实现方法get-put" class="headerlink" title="实现方法get put"></a>实现方法get put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们先来判断这两个方法是否执行</span><br><span class="hljs-comment">//放入</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;key = &quot;</span> + key);<br>    System.out.println(<span class="hljs-string">&quot;value = &quot;</span> + value);<br>&#125;<br><br><span class="hljs-comment">//读取</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object key)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;key = &quot;</span> + key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">同时，我们为了让结果更加的简单明了，我们更改Test方法。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findUser</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    user.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">byUser1</span> <span class="hljs-operator">=</span> userService.findByUser(user);<br>    System.out.println(byUser1);<br>    <br>    System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br><br>    user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    user.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">byUser2</span> <span class="hljs-operator">=</span> userService.findByUser(user);<br>    System.out.println(byUser2);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409102404.png" alt="image-20210409102404794"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">很明显，方法执行了。<br>我们根据方法分析，<br>我们执行了一个方法，userService.findByUser(user);<br>这个方法去读取缓存，即执行getObject()方法。但是缓存为命中。<br>所以执行putObject()方法，放入缓存，因此在日志中才打印出这么多的数据。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># redis实现方法</span><br>我们知道如何通过java来操作redis。<br>--- RedisTemplate<br>如何不了解的可以查看一些文章<br>https://www.cnblogs.com/smartsmile/p/11633844.html<br><br>但是我们需要创建一个工厂，来获取这个redisTRedisTemplate<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用来获取Springboot创建好的工厂</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-comment">//工厂</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-comment">//将创建好的工厂以参数形式传递给这个类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.applicationContext = applicationContext;<br>    &#125;<br><br>    <span class="hljs-comment">//提供在工厂中获取对象的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span>&#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getBean(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># put方法的实现</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//放入</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;key = &quot;</span> + key);<br>    System.out.println(<span class="hljs-string">&quot;value = &quot;</span> + value);<br>    <span class="hljs-comment">//通过application工具类获取redisTemplate</span><br>    <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);<br><br>    redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>    redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br><br>    <span class="hljs-comment">//将redishash类型作为缓存存储模型  key  hashkey  value</span><br>    redisTemplate.opsForHash().put(id.toString(),key.toString(),value);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 写完put方法之后，我们对它进行测试</span><br>首先我们可以看到在redis中我们没有任何数据<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409110353.png" alt="image-20210409110346364"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 执行单元测试</span><br>再次观察redis，我们发现redis中有了数据，并且key为id值，<br>但是我们发现，在日志中，缓存依旧没有命中，这是因为我们没有重写getObject()方法<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409110448.png" alt="image-20210409110448039"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># get方法的实现</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object key)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;key = &quot;</span> + key);<br><br>    <span class="hljs-comment">//通过application工具类获取redisTemplate</span><br>    <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);<br><br>    redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>    redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash().get(id.toString(), key.toString());<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们将redis中的数据删除，重新运行单元测试<br>明显看出，缓存命中了<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409111052.png" alt="image-20210409111052865"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409111119.png" alt="image-20210409111119362"></p><h4 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们都知道缓存会带来一些问题，比如我们修改后，再次查询，我们依旧会查询到redis中的缓存。<br><br>针对这个问题:<br>在redis中的解决方案是从redis中删除掉。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># clear()方法和removeObject()方法</span><br>删除时使用哪一个方法，我们暂时没有对方法进行具体操作。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">removeObject</span><span class="hljs-params">(Object key)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;removeObject ================  key = &quot;</span> + key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;clear ================  &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 同时编写一个修改方法</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">update</span> id=&quot;updata&quot; parameterType=&quot;com.jiang.travels.entity.User&quot;&gt;<br>    <span class="hljs-keyword">update</span> t_user <span class="hljs-keyword">set</span> email = #&#123;email&#125;<br>    <span class="hljs-keyword">where</span> id = #&#123;id&#125;<br>&lt;/<span class="hljs-keyword">update</span>&gt;<br><br>@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> Updata()&#123;<br>    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>();<br>    <span class="hljs-keyword">user</span>.setId(&quot;9&quot;);<br>    <span class="hljs-keyword">user</span>.setEmail(&quot;11111@qq.com&quot;);<br>    userService.updata(<span class="hljs-keyword">user</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409113713.png" alt="image-20210409113712974"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们可以发现最后执行的时clear方法<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写clear方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>   System.out.println(<span class="hljs-string">&quot;clear ================  &quot;</span>);<br>   <span class="hljs-comment">//通过application工具类获取redisTemplate</span><br>   <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);<br><br>   redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>   redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br><br>   redisTemplate.delete(id.toString());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">运行之后，我们再去redis中查看是否还有缓存。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210409114150.png" alt="image-20210409114150467"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">证明redis中的缓存已经被删除了<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="RedisCache-java"><a href="#RedisCache-java" class="headerlink" title="RedisCache.java"></a>RedisCache.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiang.travels.cache;<br><br><span class="hljs-keyword">import</span> com.jiang.travels.utils.ApplicationContextUtils;<br><span class="hljs-keyword">import</span> org.apache.ibatis.cache.Cache;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 自定义Redis缓存的实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cache</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisCache</span><span class="hljs-params">(String id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br><br>    <span class="hljs-comment">//代码冗余</span><br>    <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">getRedisTemplate</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-comment">//通过application工具类获取redisTemplate</span><br>        <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);<br><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br><br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br><br><br>    <span class="hljs-comment">//放入</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;key = &quot;</span> + key);<br>        System.out.println(<span class="hljs-string">&quot;value = &quot;</span> + value);<br><br>        <span class="hljs-comment">//将redishash类型作为缓存存储模型  key  hashkey  value</span><br>        getRedisTemplate().opsForHash().put(id.toString(),key.toString(),value);<br><br>    &#125;<br><br>    <span class="hljs-comment">//读取</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object key)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;key = &quot;</span> + key);<br>        <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().get(id.toString(), key.toString());<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">removeObject</span><span class="hljs-params">(Object key)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;removeObject ================  key = &quot;</span> + key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;clear ================  &quot;</span>);<br>        getRedisTemplate().delete(id.toString());<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//获取hash中key value的数量</span><br>        <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().size(id.toString()).intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ApplicationContextUtils-java"><a href="#ApplicationContextUtils-java" class="headerlink" title="ApplicationContextUtils.java"></a>ApplicationContextUtils.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiang.travels.utils;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">//用来获取Springboot创建好的工厂</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-comment">//工厂</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-comment">//将创建好的工厂以参数形式传递给这个类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.applicationContext = applicationContext;<br>    &#125;<br><br>    <span class="hljs-comment">//提供在工厂中获取对象的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span>&#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getBean(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>参考资料:https://www.bilibili.com/video/BV1jD4y1Q7tU?p=17</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>框架</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="/2021/02/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h3><h4 id="1、什么是持久化"><a href="#1、什么是持久化" class="headerlink" title="1、什么是持久化"></a>1、什么是持久化</h4><p><code>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复</code></p><p>持久化的作用：防止数据的意外丢失，确保数据安全性</p><p>持久化的方式：</p><ol><li>将<strong>当前数据状态进行保存</strong>，快照形式，存储数据结果，存储格式简单。</li><li>将<strong>数据的操作过程进行保存</strong>，日志形式，存储操作过程，存储格式复杂。</li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210525160757.png" alt="image-20210525160750233"></p><h4 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h4><p>RDB就是以<strong>快照的形式</strong>对Redis中的数据进行持久化。</p><p>RDB的启动方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">命令：<br><span class="hljs-code">save</span><br><span class="hljs-code">作用：手动执行一次保存操作</span><br></code></pre></td></tr></table></figure><p>其中保存的数据在dump.rdb文件中。</p><p>我们可以通过Redis的配置文件去修改dump.rdb文件的信息。</p><ul><li><p><code>dbfilename dump.rdb</code></p><p>说明：设置本地数据库文件名，默认是dump.rdb</p></li><li><p><code>rdbcompression  yes</code></p><p>说明：设置存储至本地数据库时是否压缩数据，默认为yes，采用LZE压缩</p></li><li><p><code>rdbchecksum  yes</code></p><p>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</p></li></ul><p>RDB文件如何恢复：</p><p>当我们打开Redis服务器之后，Redis中的数据就会恢复到内存中。</p><p>save指令出现的问题：</p><p>对于单线程来说，当执行save指令时，时间过长，那么会阻塞当前的Redis服务器，直到RDB过程结束。</p><h5 id="如何解决阻塞问题：—-bgsave"><a href="#如何解决阻塞问题：—-bgsave" class="headerlink" title="如何解决阻塞问题：—-bgsave"></a>如何解决阻塞问题：—-bgsave</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">指令：<br><span class="hljs-code">bgsave</span><br><span class="hljs-code">作用：手动启动后台保存操作，但不是立即执行，是在后台执行</span><br></code></pre></td></tr></table></figure><p>bgsave的工作原理：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210525163405.png" alt="image-20210525163405855"></p><p><code>bgsave命令是针对save阻塞问题做出的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">关于bgsave的配置信息：<br>stop-writes-on-bgsave  yes<br>说明：后台存储过程中如果出现错误现象，是否停止保存操作<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">方式</th><th align="center">save</th><th align="center">bgsave</th></tr></thead><tbody><tr><td align="center">读写</td><td align="center">同步</td><td align="center">异步</td></tr><tr><td align="center">阻塞客户端指令</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">额外内存消耗</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">启动新进程</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><h5 id="RDB的自动保存"><a href="#RDB的自动保存" class="headerlink" title="RDB的自动保存"></a>RDB的自动保存</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">配置：在redis配置文件中配置<br>save second changes<br>作用：满足限定时间范围内key的变化数量达到指定数量即进行持久化<br><span class="hljs-bullet"> -</span> second :监控时间范围<br><span class="hljs-bullet"> -</span> changes: 监控key的变化量<br> <br> save 900 1  # 如果在900s内变化了1个key。则执行save<br> save 300 10  # 如果在60s内变化了300个key。则执行save<br></code></pre></td></tr></table></figure><h5 id="RDB的优点和缺点"><a href="#RDB的优点和缺点" class="headerlink" title="RDB的优点和缺点"></a>RDB的优点和缺点</h5><p>优点</p><ul><li><p>RDB是一个紧凑压缩的二进制文件，存储效率较高</p></li><li><p>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 </p></li><li><p>RDB恢复数据的速度要比AOF快很多</p></li><li><p>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</p></li></ul><p>缺点</p><ul><li><p>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</p></li><li><p>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</p></li><li><p>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</p></li></ul><h4 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h4><h5 id="RDB存储的弊端："><a href="#RDB存储的弊端：" class="headerlink" title="RDB存储的弊端："></a>RDB存储的弊端：</h5><ul><li>当数据量巨大时，效率非常低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul><p>这些问题AOF都可以解决：</p><p><strong>AOF(append only file)持久化</strong>：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令</p><p>达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</p><p>作用：解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p><h5 id="AOF写数据的过程"><a href="#AOF写数据的过程" class="headerlink" title="AOF写数据的过程"></a>AOF写数据的过程</h5><p>Redis将指令存储在缓存区中，然后将命令同步到aof文件中。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210525165228.png" alt="image-20210525165228432"></p><h5 id="AOF写数据的三种策略："><a href="#AOF写数据的三种策略：" class="headerlink" title="AOF写数据的三种策略："></a>AOF写数据的三种策略：</h5><ul><li><p>always(每次）</p><p>每次写入操作均同步到AOF文件中，数据零误差，性能较低</p></li><li><p>everysec（每秒）</p><p>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高在系统突然宕机的情况下丢失1秒内的数据</p></li><li><p>no（系统控制）</p><p>由操作系统控制每次同步到AOF文件的周期，整体过程不可控</p></li></ul><p>AOF方式配置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">配置：在Redis配置文件中<br><br><span class="hljs-bullet">1.</span> appendonly  yes<br>是否开启AOF持久化功能。默认不开启<br><br><span class="hljs-bullet">2.</span> appendfsync always|everysec|no<br>AOF写数据策略<br><br><span class="hljs-bullet">3.</span> appendfilename filename<br>AOF持久化文件名，默认文件名未appendonly.aof<br></code></pre></td></tr></table></figure><h5 id="AOF的重写"><a href="#AOF的重写" class="headerlink" title="AOF的重写"></a>AOF的重写</h5><p>如果我们执行以下指令</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">set name zs<br>set name ls<br>set name ww<br></code></pre></td></tr></table></figure><p>对于这样的操作，我们如何把每一个操作都保存下来，是没有意义的。所以需要AOF重写。</p><p>随着命令不断写入AOF，文件会越来越大。</p><p>为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。</p><p>简单说就是将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。</p><p><strong>AOF重写作用</strong></p><ul><li><p>降低磁盘占用量，提高磁盘利用率</p></li><li><p>提高持久化效率，降低持久化写时间，提高IO性能</p></li><li><p>降低数据恢复用时，提高数据恢复效率</p></li></ul><p><strong>AOF重写规则</strong></p><ul><li><p>进程内已超时的数据不再写入文件</p></li><li><p>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令</p><p>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 </p></li><li><p>对同一数据的多条写命令合并为一条命令</p><p>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。</p><p>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</p></li></ul><p>AOF重写方式</p><ul><li><p>手动重写指令</p><p><code>bgrewriteaof</code> </p></li><li><p>自动重写配置</p><p><code>auto-aof-rewrite-min-size </code> size</p><p><code>auto-aof-rewrite-percentage</code> percentage</p></li></ul><p>原理</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210525171340.png" alt="image-20210525171339967"></p><h4 id="4、RDB和AOF对比"><a href="#4、RDB和AOF对比" class="headerlink" title="4、RDB和AOF对比"></a>4、RDB和AOF对比</h4><table><thead><tr><th align="center">持久化方式</th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">占用存储空间</td><td align="center">小（数据级：压缩）</td><td align="center">大（指令级：重写）</td></tr><tr><td align="center">存储速度</td><td align="center">慢</td><td align="center">块</td></tr><tr><td align="center">恢复速度</td><td align="center">块</td><td align="center">慢</td></tr><tr><td align="center">数据安全性</td><td align="center">会丢失数据</td><td align="center">依据策略决定</td></tr><tr><td align="center">资源消耗</td><td align="center">高&#x2F;重量级</td><td align="center">低&#x2F;轻量级</td></tr><tr><td align="center">启动优先级</td><td align="center">低</td><td align="center">高</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot、SpringSecurity、Vue、JWT实现前后端分离的登录功能</title>
    <link href="/2021/02/01/SpringBoot+Vue+SpringSecurity+JWT+Axios%E9%85%8D%E7%BD%AE%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/"/>
    <url>/2021/02/01/SpringBoot+Vue+SpringSecurity+JWT+Axios%E9%85%8D%E7%BD%AE%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>前后端代码：<a href="https://github.com/JZWAkihi/LoginDemo">GitHub地址</a></p><h5 id="Vue-Cli创建前端项目"><a href="#Vue-Cli创建前端项目" class="headerlink" title="Vue-Cli创建前端项目"></a>Vue-Cli创建前端项目</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518083626.png" alt="image-20210518083619085"></p><h5 id="前端项目目录结构"><a href="#前端项目目录结构" class="headerlink" title="前端项目目录结构"></a>前端项目目录结构</h5><p>我们需要Login.vue和Home.vue组件，一个用于登录，一个用于登录成功之后的跳转。</p><p>我们需要封装一些函数，这些函数用于在前后端交互时请求与响应的拦截。定义api.js</p><p>我们还需要删除原有的组件，清除App.vue的内容（不能删除）。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518091931.png" alt="image-20210518091931031"></p><h5 id="引入Element-ui"><a href="#引入Element-ui" class="headerlink" title="引入Element-ui"></a>引入Element-ui</h5><p>参考<a href="https://element.eleme.cn/#/zh-CN/component/installation">element-ui官网</a></p><p>在main.js文件中引入Element-ui</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>)<br></code></pre></td></tr></table></figure><p>在VScode终端输入npm i element-ui -S</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518085600.png" alt="image-20210518085600049"></p><p>在main.js中引入element-ui</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>);<br></code></pre></td></tr></table></figure><p>可以在package.json中查看是否引入成功</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;element-ui&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.15.1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.5.2&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;vue-router&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.0.1&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><h5 id="Login-vue"><a href="#Login-vue" class="headerlink" title="Login.vue"></a>Login.vue</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-form ref=&quot;loginform&quot; :rules=&quot;rules&quot; :model=&quot;loginForm&quot; class=&quot;loginContainer&quot;&gt;<br>      &lt;h3 class=&quot;loginTitle&quot;&gt;系统登录&lt;/h3&gt;<br>      &lt;el-form-item prop=&quot;username&quot;&gt;<br>        &lt;!-- auto-complete=&quot;off&quot;  禁止浏览器表单自动填充 --&gt;<br>        &lt;!-- placeholder  输入框占位文本 --&gt;<br>        &lt;el-input type=&quot;text&quot; auto-complete=&quot;off&quot; v-model=&quot;loginForm.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item prop=&quot;password&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; v-model=&quot;loginForm.password&quot; auto-complete=&quot;off&quot; placeholder=&quot;请输入密码&quot; &gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item prop=&quot;code&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; v-model=&quot;loginForm.code&quot; size=&quot;normal&quot; placeholder=&quot;点击图片更换验证码&quot; auto-complete=&quot;off&quot; style=&quot;width:250px;margin-right:5px&quot;&gt;&lt;/el-input&gt;<br>        &lt;img :src=&quot;captchaUrl&quot; @click=&quot;updataCaptcha&quot;&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-button type=&quot;primary&quot; style=&quot;width:100%&quot; @click=&quot;submitLogin&quot;&gt;登录&lt;/el-button&gt;<br><br>    &lt;/el-form&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;postRequest&#125; from &quot;../utils/api&quot;;<br>export default &#123;<br>  name:&quot;Login&quot;,<br>  data()&#123;<br>    return&#123;<br>      captchaUrl:&#x27;captcha?time&#x27; + new Date(),<br>      loginForm:&#123;<br>        username:&#x27;&#x27;,<br>        password:&#x27;&#x27;,<br>        code:&#x27;&#x27;<br>      &#125;,<br>      // rules  表单的验证  required   message：提示信息<br>      rules:&#123;<br>        username:[&#123;required:true,message:&#x27;请输入用户名&#x27;,trigger:&#x27;blur&#x27;&#125;],<br>        password:[&#123;required:true,message:&#x27;请输入密码&#x27;,trigger:&#x27;blur&#x27;&#125;],<br>        code:[&#123;required:true,message:&#x27;请输入验证码&#x27;,trigger:&#x27;blur&#x27;&#125;]<br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    //点击更新图片<br>    updataCaptcha()&#123;<br>      this.captchaUrl = &#x27;captcha?time=&#x27; + new Date();<br>      &#125;,<br>    <br>    //登录<br>    submitLogin()&#123;<br>      this.$refs.loginForm.validate((valid) =&gt; &#123;<br>        if(valid)&#123;<br>          postRequest(&#x27;/login&#x27;,this.loginForm).then(resp =&gt; &#123;<br>            console.log(resp);<br>            if(resp)&#123;<br>              const token = resp.object.tokenHead + resp.object.token;<br>              window.sessionStorage.setItem(&#x27;tokenStr&#x27;,token)<br>              this.$router.replace(&#x27;/Home&#x27;)<br>            &#125;<br>          &#125;)<br>        &#125;else&#123;<br>          console.log(&#x27;error submit&#x27;);<br>          return false;<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>  .loginContainer&#123;<br>        border-radius: 15px;<br>        background-clip: padding-box;<br>        margin: 180px auto;<br>        width: 350px;<br>        padding: 15px 35px 15px 35px;<br>        background:#fff;<br>        border: 1px solid #eaeaea;<br>        box-shadow: 0 0 25px #cac6c6;<br>  &#125;<br><br>  .loginTitle&#123;<br>        margin: 0px auto 40px auto;<br>        text-align: center;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h5 id="Api-js"><a href="#Api-js" class="headerlink" title="Api.js"></a>Api.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Message</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../router&#x27;</span><br><br><br><span class="hljs-comment">//请求拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;tokenStr&#x27;</span>))&#123;<br>        <span class="hljs-comment">//请求携带token</span><br>        config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;Authorization&#x27;</span>] = <span class="hljs-variable language_">window</span>.<span class="hljs-property">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;tokenStr&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> config<br>&#125;,<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br><br><br><br><span class="hljs-comment">//响应拦截器</span><br><span class="hljs-comment">// success 成功调到后端接口之后，但是接口不允许进行该操作</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">success</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(success.<span class="hljs-property">status</span> &amp;&amp; success.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">if</span>(success.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> == <span class="hljs-number">500</span> || success.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> == <span class="hljs-number">401</span> || success.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> == <span class="hljs-number">403</span>)&#123;<br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(&#123;<span class="hljs-attr">message</span>:success.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>&#125;);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(success.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>)&#123;<br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">success</span>(&#123;<span class="hljs-attr">message</span>:success.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>&#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> success.<span class="hljs-property">data</span>;<br>&#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">//没有访问到接口</span><br>    <span class="hljs-keyword">if</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">code</span> == <span class="hljs-number">504</span> || error.<span class="hljs-property">response</span>.<span class="hljs-property">code</span> == <span class="hljs-number">404</span>)&#123;<br>        <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;服务器崩了&#x27;</span>&#125;);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">code</span> == <span class="hljs-number">403</span>)&#123;<br>        <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;权限不足&#x27;</span>&#125;)<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">code</span> == <span class="hljs-number">401</span>)&#123;<br>        <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;未登录&#x27;</span>&#125;)<br>        router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>)&#123;<br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(&#123;<span class="hljs-attr">message</span>:error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>&#125;)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;未知错误&#x27;</span>&#125;)<br>        &#125;<br>    &#125;<br>&#125;)<br><br><br><br><br><span class="hljs-keyword">let</span> base = <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">postRequest</span> = (<span class="hljs-params">url,params</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;post&#x27;</span>,<br>        <span class="hljs-attr">url</span>:<span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>        <span class="hljs-attr">data</span>:params<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h5><p>在index.js中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">proxyTable</span>: &#123;<br>  <span class="hljs-string">&#x27;/ws&#x27;</span>:&#123;<br>       <span class="hljs-attr">ws</span>:<span class="hljs-literal">true</span>,<br>       <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;ws://localhost:8081&#x27;</span><br>   &#125;,<br>   <span class="hljs-string">&#x27;/&#x27;</span>:&#123;<br>       <span class="hljs-attr">ws</span>: <span class="hljs-literal">false</span>,<br>       <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8081&#x27;</span>,<br>       <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>       <span class="hljs-attr">pathRewrite</span>: &#123;<br>       <span class="hljs-string">&#x27;^/&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后端：</p><blockquote><p>Config</p><p>​CaptchaConfig： 验证码配置文件</p><p>​JwtTokenFilter：JWT过滤器，判断受否拿到JWT，判断JWT是否有效</p><p>​SecurityConfig：SpringSecurity 核心配置文件</p><p>Controller</p><p>​CaptchaController：生成验证码</p><p>​LoginController：登录</p><p>dao</p><p>​AdminMapper：数据库查询</p><p>pojo</p><p>​Admin：实现UserDetails接口</p><p>​LoginAdmin：用于接收前端传来的信息，属性有：用户名，密码，验证码</p><p>service</p><p>​AdminServiceImpl：用于登录的主要逻辑</p><p>utils</p><p>​JWTUtils：生成JWT</p><p>​Respbean：向前端返回结果类</p></blockquote><p>项目框架</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518145514.png" alt="image-20210518145507364"></p><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--lombok 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--mysql 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--   jwt依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--security 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--验证码--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.axet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8081</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># mybatis配置</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/login</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">root</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># mybatis配置文件</span><br><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath*:/Mappers/*.xml</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 日志</span><br><span class="hljs-comment"># logging.level.root=debug</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># Jwt存储的请求头</span><br><span class="hljs-attr">jwt-tokenHeader</span>=<span class="hljs-string">Authorization</span><br><span class="hljs-comment"># Jwt加密秘钥</span><br><span class="hljs-attr">jwt-secret</span>=<span class="hljs-string">yeb-secret</span><br><span class="hljs-comment"># Jwt 的超期限时间（60*60）*24</span><br><span class="hljs-attr">jwt-expiration</span>=<span class="hljs-string">604800</span><br><span class="hljs-comment"># Jwt负载中拿到开头  后端需要用来判断是不是需要的token</span><br><span class="hljs-attr">jwt-tokenHead</span>=<span class="hljs-string">Bearer</span><br></code></pre></td></tr></table></figure><h5 id="LoginController"><a href="#LoginController" class="headerlink" title="LoginController"></a>LoginController</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AdminServiceImpl adminService;<br><br><br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> RespBean <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> LoginAdmin loginAdmin, HttpServletRequest request)</span>&#123;<br>        <span class="hljs-keyword">return</span> adminService.login(loginAdmin.getUsername(),loginAdmin.getPassword(),loginAdmin.getCode(),request);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="LoginServiceImpl"><a href="#LoginServiceImpl" class="headerlink" title="LoginServiceImpl"></a>LoginServiceImpl</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdminService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AdminMapper adminMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JWTUtils jwtUtils;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jwt-tokenHead&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String tokenHead;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Admin <span class="hljs-title function_">selectAdminByName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> adminMapper.selectOne(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RespBean <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password, String code, HttpServletRequest request)</span> &#123;<br><span class="hljs-comment">//验证码验证</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">captcha</span> <span class="hljs-operator">=</span> (String)request.getSession().getAttribute(<span class="hljs-string">&quot;captcha&quot;</span>);<br>        System.out.println(captcha);<br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(code) || !captcha.equalsIgnoreCase(code))&#123;<br>            <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;验证码错误，请重新输入&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//得到用户信息</span><br>        <span class="hljs-type">UserDetails</span> <span class="hljs-variable">userDetails</span> <span class="hljs-operator">=</span> userDetailsService.loadUserByUsername(username);<br>        System.out.println(userDetails);<br>        <span class="hljs-comment">//用户信息为空，且密码不正确 返回错误</span><br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> == userDetails || !passwordEncoder.matches(password,userDetails.getPassword()))&#123;<br>            <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!userDetails.isEnabled())&#123;<br>            <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;账号被禁用,请联系管理员&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//更新security登录用户对象</span><br><br>        <span class="hljs-comment">/***</span><br><span class="hljs-comment">         * 以UsernamePasswordAuthenticationToken实现的带用户名和密码以及权限的Authentication</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">authenticationToken</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(userDetails, <span class="hljs-literal">null</span>, userDetails.getAuthorities());<br><br>        <span class="hljs-comment">//将当前登录的信息设置到Spring Security 上下文</span><br>        SecurityContextHolder.getContext().setAuthentication(authenticationToken);<br><br>        <span class="hljs-comment">//创建token </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> jwtUtils.generateToken(userDetails);<br><br>        <span class="hljs-comment">//将token和tokenHead传入前端</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;token&quot;</span>,token);<br>        map.put(<span class="hljs-string">&quot;tokenHead&quot;</span>,tokenHead);<br><br>        <span class="hljs-keyword">return</span> RespBean.success(<span class="hljs-string">&quot;登录成功&quot;</span>,map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SecurityConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * SpringSecurity  配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AdminServiceImpl adminService;<br><br>    <br>    <span class="hljs-comment">//重写loadUserByUsername()  lambda表达式</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title function_">userDetailsService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> username -&gt; &#123;<br>            <span class="hljs-type">Admin</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> adminService.selectAdminByName(username);<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != admin)&#123;<br>                <span class="hljs-keyword">return</span> admin;<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>        &#125;;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//根据传入的自定义UserDetailsService添加身份验证。</span><br>    <span class="hljs-comment">// 允许自定义身份验证。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        auth.userDetailsService(userDetailsService()).passwordEncoder(passwordEncoder());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> JwtTokenFilter <span class="hljs-title function_">jwtTokenFilter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JwtTokenFilter</span>();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.csrf()<br>                .disable()<br>                <span class="hljs-comment">//基于token 不需要session</span><br>                .sessionManagement()<br>                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)<br>                .and()<br>                .authorizeRequests()<br>                <span class="hljs-comment">//允许登录访问</span><br>                .antMatchers(<span class="hljs-string">&quot;/login&quot;</span>,<span class="hljs-string">&quot;/logout&quot;</span>)<br>                .permitAll()<br>                <span class="hljs-comment">//除了上面，所有请求都要求认证</span><br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .headers()<br>                .cacheControl();<br><br><br>        <span class="hljs-comment">//添加jwt验证过滤器</span><br>        http.addFilterBefore(jwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储引擎和锁</title>
    <link href="/2021/01/20/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E9%94%81/"/>
    <url>/2021/01/20/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1、MySQL存储引擎"><a href="#1、MySQL存储引擎" class="headerlink" title="1、MySQL存储引擎"></a>1、MySQL存储引擎</h2><h3 id="1-1、MySQL的体系结构"><a href="#1-1、MySQL的体系结构" class="headerlink" title="1.1、MySQL的体系结构"></a>1.1、MySQL的体系结构</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/65002c0e177a525b3c71867d26ebee35.png" alt="image-20210314123811353"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># MySQL Server的组成部分</span><br><span class="hljs-bullet">1.</span> Connection Pool      连接池组件<br><span class="hljs-bullet">2.</span> Management Services &amp; Utilities  管理服务和工具组件<br><span class="hljs-bullet">3.</span> SQL Interface                    SQL接口组件<br><span class="hljs-bullet">4.</span> Parser                           查询分析器组件<br><span class="hljs-bullet">5.</span> Optimizer                        优化器组件<br><span class="hljs-bullet">6.</span> Caches &amp; Buffers                 缓冲池组件<br><span class="hljs-bullet">7.</span> Pluggable Storage Engines        文件系统<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 连接层</span><br>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、以及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层可以实现基于SSL的安全连接。服务器也会为安全接入的每个客户端验证她所具有的操作权限<br><br><span class="hljs-section"># 服务层</span><br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行，所有跨存储引擎的功能也在这一层实现。如过程、函数等。<br>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化，比如确定表的查询顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境下能够很好的提升系统的性能。<br><br><span class="hljs-section"># 引擎层</span><br>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API的存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。<br><br><br><span class="hljs-section"># 存储层</span><br>数据存储层，主要是将数据存储在文件系统之上，并完成于存储引擎的交互。<br><br><br><span class="hljs-section"># 总结</span><br>和其他数据库相比，MySQL的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，<span class="hljs-strong">**插件式**</span>式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。<br></code></pre></td></tr></table></figure><h3 id="2-2、存储引擎"><a href="#2-2、存储引擎" class="headerlink" title="2.2、存储引擎"></a>2.2、存储引擎</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 存储引擎概述</span><br>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式。存储引擎式基于表的，而不是基于库的。所以存储引擎也可被称为表类型。<br><br>MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应的引擎，或者编写存储引擎。<br><br>MySQL5.0支持的存储引擎包含:InnoDB、MyISAM、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等。其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。<br><br>创建表时如果不指定存储引擎，那么系统就会使用默认的存储引擎。MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就该为了InnoDB。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># InnoDB和MyISAM的对比</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">特点</th><th align="center">InnoDB</th><th align="center">MyISAM</th></tr></thead><tbody><tr><td align="center">事务安全</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">锁机制</td><td align="center">行锁</td><td align="center">表锁</td></tr><tr><td align="center">支持外键</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># InnoDB</span><br>InnoDB存储引擎提供了提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写操作的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。<br><br><span class="hljs-section"># MyISAM</span><br>MyISAM不支持事务，也不支持外键，其优势是访问速度块，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表。<br></code></pre></td></tr></table></figure><h2 id="2、锁"><a href="#2、锁" class="headerlink" title="2、锁"></a>2、锁</h2><h3 id="2-1、什么是锁"><a href="#2-1、什么是锁" class="headerlink" title="2.1、什么是锁"></a>2.1、什么是锁</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 锁概述</span><br>锁是计算机协调多个进程或线程并发访问的某一资源的机制(避免争抢)<br><br>在数据库中，除传统的计算机资源(如CPU、RAM、I/O....)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题。锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来所，锁对数据库而言显得尤其重要，也更加复杂。<br></code></pre></td></tr></table></figure><h3 id="2-2、锁分类"><a href="#2-2、锁分类" class="headerlink" title="2.2、锁分类"></a>2.2、锁分类</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 按照对数据操作的粒度来分：</span><br><span class="hljs-bullet">1.</span> 表锁   操作时，会锁定整张表<br><span class="hljs-bullet">2.</span> 行锁   操作时，会锁定当前操作的行<br><br><span class="hljs-section"># 按照对数据操作的类型来分：</span><br><span class="hljs-bullet">1.</span> 读锁(共享锁)  针对同一份数据，多个读操作可以同时进行而不会互相影响<br><span class="hljs-bullet">2.</span> 写锁(排他锁)  当前操作没有完成之前，他会阻断其他写锁和读锁<br></code></pre></td></tr></table></figure><h3 id="2-3、MySQL锁"><a href="#2-3、MySQL锁" class="headerlink" title="2.3、MySQL锁"></a>2.3、MySQL锁</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># MySQL这两种锁的特性</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">锁类型</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">表级锁</td><td align="center">偏向MyISAM存储引擎，开销小，不会出现死锁，锁定粒度大，发生锁冲突最高，并发度最低</td></tr><tr><td align="center">行级锁</td><td align="center">偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引</title>
    <link href="/2021/01/20/%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/01/20/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="1、什么是索引"><a href="#1、什么是索引" class="headerlink" title="1、什么是索引"></a>1、什么是索引</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 官方定义:</span><br><span class="hljs-code">一种帮助mysql提高查询效率的数据结构  index</span><br><span class="hljs-code"># 索引的数据结构</span><br><span class="hljs-code">B+树</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 索引的优点</span><br><span class="hljs-code">大大加快了数据的查询速度</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 索引的缺点</span><br><span class="hljs-code">维护索引需要耗费数据库的资源</span><br><span class="hljs-code">索引需要占用磁盘空间</span><br><span class="hljs-code">当对表的数据进行增删改的时候,因为要维护索引,速度会受到影响,因为会对底层结构重排序</span><br></code></pre></td></tr></table></figure><h3 id="2、-索引分类"><a href="#2、-索引分类" class="headerlink" title="2、 索引分类"></a>2、 索引分类</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-- 在InnoDB(支持前四种)<br><span class="hljs-section"># 主键索引</span><br><span class="hljs-code">设定在主键后数据库会自动建立索引，innoDB为聚簇索引</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 单值索引</span><br><span class="hljs-code">即一个索引只包含单个列，一个表可以有多个单列索引</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 唯一索引</span><br><span class="hljs-code">索引列的值必须唯一，但允许有空值，唯一索引索引值可以存在null，但是只能存在一个null</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 复合索引</span><br><span class="hljs-code">即一个索引包含多个列，主键索引列值不能为空</span><br><span class="hljs-code"></span><br><br><br>-- MyISAM支持<br><span class="hljs-section"># Full Text 全文索引  (MySQL 5.7版本之前，只能用于MYISAM引擎)</span><br><span class="hljs-code">全文索引类型为FULLTEXT,在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。</span><br></code></pre></td></tr></table></figure><h3 id="3、-索引使用"><a href="#3、-索引使用" class="headerlink" title="3、 索引使用"></a>3、 索引使用</h3><h4 id="3-1、在Linux系统下创建表"><a href="#3-1、在Linux系统下创建表" class="headerlink" title="3.1、在Linux系统下创建表"></a>3.1、在Linux系统下创建表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs markdown">启动MySQL<br>[root@localhost /]# mysql -u root -p<br>Enter password:<br><br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information<span class="hljs-emphasis">_schema |</span><br><span class="hljs-emphasis">| mysql              |</span><br><span class="hljs-emphasis">| performance_</span>schema |<br>| sys                |<br>+--------------------+<br>4 rows in set (0.00 sec)<br><br><span class="hljs-section"># 创建数据库</span><br>mysql&gt; create database test<span class="hljs-emphasis">_index;</span><br><span class="hljs-emphasis">Query OK, 1 row affected (0.00 sec)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">mysql&gt; show databases;</span><br><span class="hljs-emphasis">+--------------------+</span><br><span class="hljs-emphasis">| Database           |</span><br><span class="hljs-emphasis">+--------------------+</span><br><span class="hljs-emphasis">| information_</span>schema |<br>| mysql              |<br>| performance<span class="hljs-emphasis">_schema |</span><br><span class="hljs-emphasis">| sys                |</span><br><span class="hljs-emphasis">| test_</span>index         |<br>+--------------------+<br>5 rows in set (0.00 sec)<br><br><span class="hljs-section"># 创建表</span><br>mysql&gt; use test<span class="hljs-emphasis">_index;</span><br><span class="hljs-emphasis">Database changed</span><br><span class="hljs-emphasis">mysql&gt; show tables;</span><br><span class="hljs-emphasis">Empty set (0.00 sec)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">mysql&gt; create table t_</span>user(id varchar(20) primary key,name varchar(20));<br>Query OK, 0 rows affected (0.10 sec)<br><br>mysql&gt; show tables;<br>+----------------------+<br>| Tables<span class="hljs-emphasis">_in_</span>test<span class="hljs-emphasis">_index |</span><br><span class="hljs-emphasis">+----------------------+</span><br><span class="hljs-emphasis">| t_</span>user               |<br>+----------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="3-2、索引的使用"><a href="#3-2、索引的使用" class="headerlink" title="3.2、索引的使用"></a>3.2、索引的使用</h4><h5 id="3-2-1、主键索引"><a href="#3-2-1、主键索引" class="headerlink" title="3.2.1、主键索引"></a>3.2.1、主键索引</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 主键索引</span><br>因为在建表时，将id设为主键，那么数据库就会自动设置主键索引<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ccb0871a3bd34148a59fe232816a0112.png" alt="image-20210310100746244"></p><h5 id="3-2-2、普通索引"><a href="#3-2-2、普通索引" class="headerlink" title="3.2.2、普通索引"></a>3.2.2、普通索引</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 普通索引</span><br><span class="hljs-code">建普通索引通常有两种方式</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 建表之后创建</span><br>create index nameindex on t<span class="hljs-emphasis">_user(name);</span><br><span class="hljs-emphasis">语法:create index 索引名 on 表名(列)</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/84c8fbc435dfdb109382198e5a32a121.png" alt="image-20210310101123429"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 建表时创建</span><br><span class="hljs-code">我们删除表，重新为id和name建立索引</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 删除表</span><br>mysql&gt; show tables;<br>+----------------------+<br>| Tables<span class="hljs-emphasis">_in_</span>test<span class="hljs-emphasis">_index |</span><br><span class="hljs-emphasis">+----------------------+</span><br><span class="hljs-emphasis">| t_</span>user               |<br>+----------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; drop table t<span class="hljs-emphasis">_user;</span><br><span class="hljs-emphasis">Query OK, 0 rows affected (0.05 sec)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">mysql&gt; show tables;</span><br><span class="hljs-emphasis">Empty set (0.00 sec)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"># 新建表，且建立索引</span><br><span class="hljs-emphasis">mysql&gt; create table t_</span>user(id varchar(20) primary key,name varchar(20),key(name));<br>Query OK, 0 rows affected (0.02 sec)<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e26d54bb2e01bbd7ab878865673b6f53.png" alt="image-20210310102052880"></p><h5 id="3-2-3、唯一索引"><a href="#3-2-3、唯一索引" class="headerlink" title="3.2.3、唯一索引"></a>3.2.3、唯一索引</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 建表时创建</span><br><span class="hljs-code">create table t_user1(id varchar(20) primary key,name varchar(20),unique(name));</span><br><span class="hljs-code"># 建表之后创建</span><br><span class="hljs-code">create unique index nameindex on t_user(name);</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/da0bb0f888f426919f268a606ed8a7be.png" alt="image-20210310103148683"></p><h5 id="3-2-4、复合索引"><a href="#3-2-4、复合索引" class="headerlink" title="3.2.4、复合索引"></a>3.2.4、复合索引</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 最左前缀原则</span><br><span class="hljs-section"># MySQL 引擎在查询时为了更好的利用索引，在查询过程中会动态调整查询字段顺序以便利用索引</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 建表时创建</span><br><span class="hljs-code">create table t_user2(id varchar(20) primary key,name varchar(20),age int,key(name,age));</span><br><span class="hljs-code"># 建表之后创建</span><br><span class="hljs-code">create index nameageindex on t_user(name,age);</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/4aaf024b435c6045b18555fcdd3ebcec.png" alt="image-20210310103224991"></p><h4 id="3-3、什么情况下无法利用索引"><a href="#3-3、什么情况下无法利用索引" class="headerlink" title="3.3、什么情况下无法利用索引"></a>3.3、什么情况下无法利用索引</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 查询语句中使用Like关键字</span><br><span class="hljs-code">在查询语句中使用Like关键字进行查询时，如果匹配字符串的第一个字符为&quot;%&quot;,索引不会被使用。如果&quot;%&quot;不是在第一个位置，索引就会被使用</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 查询语句中使用多列索引(最左前缀原则)</span><br><span class="hljs-code">多列索引是在表的多个字段上创建索引，只有查询条件中使用了这些字段中的第一个字段，后一个索引才会被使用</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 查询语句中只用OR关键字</span><br><span class="hljs-code">查询语句只有OR关键字时，如果OR前后的两个条件的列都是索引，那么查询中将使用索引。如果OR前后有一个条件的列不是索引，那么查询不会只用索引</span><br></code></pre></td></tr></table></figure><h3 id="4、-索引的底层原理"><a href="#4、-索引的底层原理" class="headerlink" title="4、 索引的底层原理"></a>4、 索引的底层原理</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 删除t<span class="hljs-emphasis">_user索引</span></span><br><span class="hljs-emphasis"><span class="hljs-section">mysql&gt; drop index name on t_</span>user;</span><br>Query OK, 0 rows affected (0.01 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>此时表中只有id 主键索引<br><br><span class="hljs-section"># 我们向表中插入数据</span><br>insert into t<span class="hljs-emphasis">_user values(5,&#x27;f&#x27;);</span><br><span class="hljs-emphasis">insert into t_</span>user values(4,&#x27;e&#x27;);<br>insert into t<span class="hljs-emphasis">_user values(3,&#x27;d&#x27;);</span><br><span class="hljs-emphasis">insert into t_</span>user values(2,&#x27;c&#x27;);<br>insert into t<span class="hljs-emphasis">_user values(1,&#x27;b&#x27;);</span><br><span class="hljs-emphasis">insert into t_</span>user values(0,&#x27;a&#x27;);<br><br><span class="hljs-section"># 查询</span><br>mysql&gt; select * from t<span class="hljs-emphasis">_user;</span><br><span class="hljs-emphasis">+----+------+</span><br><span class="hljs-emphasis">| id | name |</span><br><span class="hljs-emphasis">+----+------+</span><br><span class="hljs-emphasis">| 0  | a    |</span><br><span class="hljs-emphasis">| 1  | b    |</span><br><span class="hljs-emphasis">| 2  | c    |</span><br><span class="hljs-emphasis">| 3  | d    |</span><br><span class="hljs-emphasis">| 4  | e    |</span><br><span class="hljs-emphasis">| 5  | f    |</span><br><span class="hljs-emphasis">+----+------+</span><br><span class="hljs-emphasis">6 rows in set (0.00 sec)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"># 主键索引进行了重排序</span><br><span class="hljs-emphasis">排序是为了快速查询</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"># 为了进一步提高效率mysql索引又进行了优化</span><br><span class="hljs-emphasis">就是基于页的形式进行管理索引</span><br><span class="hljs-emphasis">如:查询id = 4的  直接先比较页目录中找，再去数据目录中找</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8e6b325dc377a3d41d2f7abed8817fcc.png" alt="image-20210310111018251"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 什么是B+树</span><br>B+Tree是在B-Tree(B树)基础上的一种优化，使其更适合实现存储索引结构，InnoDB存储引擎就是其B+Tree实现其索引结构<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 什么是B树</span><br><span class="hljs-code">B树的出现是为了弥合不同的存储级别之间的访问速度的巨大差异，实现高效的I/O。平衡二叉树的查找效率是非常高的，并可以通过降低树的深度来提高查找的效率。但是数据量非常大。树的存储的元素数量是有限的，这样会导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。另外数据量过大会导致内存空间不够容纳平衡二叉树所有结点的情况。B树是解决这个问题的很好的结构。</span><br><span class="hljs-code"></span><br><span class="hljs-code">在计算机科学中，B树是一种自平衡树数据结构，它维护有序数据并允许以对数时间进行搜索，顺序访问，插入和删除。B树是二叉搜索树的一般化，因为节点可以有两个以上的子节点。与其他自平衡二进制搜索树不同，B树非常适合读取和写入相对较大的数据块（如光盘）的存储系统。它通常用于数据库和文件系统。</span><br><span class="hljs-code"></span><br><span class="hljs-section"># B树的定义</span><br>B树是一种平衡的多分树，通常我们说的m阶的B树。他必须满足如下条件<br><span class="hljs-bullet">-</span> 每个节点最多只有m个子节点。<br><span class="hljs-bullet">-</span> 每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。<br><span class="hljs-bullet">-</span> 如果根不是叶节点，则根至少有两个子节点。<br><span class="hljs-bullet">-</span> 具有k个子节点的非叶节点包含k -1个键。<br><span class="hljs-bullet">-</span> 所有叶子都出现在同一水平，没有任何信息（高度一致）。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># B+树</span><br>B+树的特征：<br><br><span class="hljs-bullet">-</span> 有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；<br><span class="hljs-bullet">-</span> 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)；<br><span class="hljs-bullet">-</span> 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息);<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># B树和B+树的区别</span><br>B+树只有叶子节点存储数据，B树 每个节点都存储数据<br>B+Tree非叶子节点只存储键值信息<br>B+Tree所有的叶子节点之间都有一个链指针<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时数据区</title>
    <link href="/2021/01/06/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>/2021/01/06/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="1-什么是运行时数据区"><a href="#1-什么是运行时数据区" class="headerlink" title="1.什么是运行时数据区"></a>1.什么是运行时数据区</h3><blockquote><p>Java虚拟机在执行Java程序的过程中，会涉及的数据划分到不同的内存区域去管理，而这部分区域就是运行时数据区。</p></blockquote><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210427110217.png" alt="image-20210427110217775"></p><p>运行时数据区有5个区域。分别是：方法区，虚拟机栈，本地方法栈，堆，程序计数器。</p><p>其中：这5个区域可以分成两类：线程私有，线程共享</p><ul><li>线程私有：虚拟机栈，本地方法栈，程序计数器</li><li>线程共享：方法区，堆</li></ul><p>线程共享和线程私有的区别是：<strong>线程私有是跟随线程的启动而存在，线程共享是跟随虚拟机的启动而存在</strong></p><blockquote><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</p><p>在Hotspot  JVM里，每个线程都与操作系统的本地线程直接映射。</p><p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</p><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的run()方法</p></blockquote><span id="more"></span><h3 id="2、程序计数器-PC寄存器"><a href="#2、程序计数器-PC寄存器" class="headerlink" title="2、程序计数器(PC寄存器)"></a>2、程序计数器(PC寄存器)</h3><h4 id="2-1、程序计数器概述："><a href="#2-1、程序计数器概述：" class="headerlink" title="2.1、程序计数器概述："></a>2.1、程序计数器概述：</h4><p>JVM中的程序计数器(Program Counter Register)中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器(或指令计数器)会更加贴切，并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。是软件层上的概念</p><h4 id="2-2、程序计数器作用："><a href="#2-2、程序计数器作用：" class="headerlink" title="2.2、程序计数器作用："></a>2.2、程序计数器作用：</h4><p><strong>PC寄存器用来存储指向下一条指令的地址。</strong>也即将要执行的指令代码。又执行引擎读取下一条指令。</p><h4 id="2-3、理解程序计数器："><a href="#2-3、理解程序计数器：" class="headerlink" title="2.3、理解程序计数器："></a>2.3、理解程序计数器：</h4><ol><li><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p></li><li><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的。生命周期与线程的生命周期保持一致。</p></li><li><p>任何时间一个线程都只有一个方法在执行。也就是所谓的当前方法。程序计数器会存储当前线程所执行的Java方法的JVM指令地址。或者，如果是在执行native方法，则是未指定值(Undefined)。</p></li><li><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p></li><li><p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError(内存溢出)情况的区域</p></li></ol><h4 id="2-4、程序计数器举例："><a href="#2-4、程序计数器举例：" class="headerlink" title="2.4、程序计数器举例："></a>2.4、程序计数器举例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>    System.out.println(i);<br>    System.out.println(k);<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译之后：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">([Ljava/lang/String;)V</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_STATIC</span><br>  <span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=5,</span> <span class="hljs-string">args_size=1</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>       <span class="hljs-attr">2:</span> <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">3:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>       <span class="hljs-attr">5:</span> <span class="hljs-string">istore_2</span><br>       <span class="hljs-attr">6:</span> <span class="hljs-string">iload_1</span><br>       <span class="hljs-attr">7:</span> <span class="hljs-string">iload_2</span><br>       <span class="hljs-attr">8:</span> <span class="hljs-string">iadd</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">istore_3</span><br>      <span class="hljs-attr">10:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  </span><br>      <span class="hljs-attr">12:</span> <span class="hljs-string">astore</span>        <span class="hljs-number">4</span><br>      <span class="hljs-attr">14:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#3                  </span><br>      <span class="hljs-attr">17:</span> <span class="hljs-string">iload_1</span><br>      <span class="hljs-attr">18:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#4                  </span><br>      <span class="hljs-attr">21:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#3                  </span><br>      <span class="hljs-attr">24:</span> <span class="hljs-string">iload_3</span><br>      <span class="hljs-attr">25:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#4                  </span><br>      <span class="hljs-attr">28:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210504131040.png" alt="image-20210504131033827"></p><h3 id="3、虚拟机栈"><a href="#3、虚拟机栈" class="headerlink" title="3、虚拟机栈"></a>3、虚拟机栈</h3><h4 id="3-1、虚拟机栈概述："><a href="#3-1、虚拟机栈概述：" class="headerlink" title="3.1、虚拟机栈概述："></a>3.1、虚拟机栈概述：</h4><p><code>栈是运行时的单位，而堆是存储的单位</code></p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放在哪儿。</p><p>Java虚拟机栈(Java Virtual Machine Stack)，早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧(Stack Frame)，对应着一次次的Java方法调用</p><p>虚拟机栈是线程私有的，生命周期和线程一致。</p><p>虚拟机栈的作用：主管Java程序的运行，它保存方法的局部变量，部分结果，并参与方法的调用和返回。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210504134104.png" alt="image-20210504134104516"></p><p>虚拟机栈的特点：</p><blockquote><p>栈是一种快速有效的分配存储方式，访问速度仅此于程序计数器。</p><p>JVM直接对Java栈的操作只有两个：</p><p>​每个方法执行，伴随着进栈(入栈，压栈)</p><p>​执行结束后的出栈工作</p><p>对于栈来说不存在垃圾回收问题，但有内存溢出的问题</p></blockquote><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210504135040.png" alt="image-20210504135040215"></p><h4 id="3-2、虚拟机栈异常："><a href="#3-2、虚拟机栈异常：" class="headerlink" title="3.2、虚拟机栈异常："></a>3.2、虚拟机栈异常：</h4><p>Java虚拟机规范允许Java栈的大小是<strong>动态的或者是固定大小</strong>。</p><ol><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的<strong>栈容量超过Java虚拟机栈允许的最大容量</strong>，Java虚拟机将会抛出一个StackOverflowError异常</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候<strong>无法申请到足够的内存</strong>，或者在创建新的线程是没有足够的内存去创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutofMemoryError异常</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    main(args);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">出现异常：Exception in thread &quot;main&quot; java.lang.StackOverflowError<br></code></pre></td></tr></table></figure><p>设置栈内存大小：使用-Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//下面是在默认Java虚拟机中执行</span><br><span class="hljs-comment">//我们用count来标识函数调用的深度，函数调用时会将栈帧加到虚拟机栈中</span><br><span class="hljs-comment">//一直加入栈帧，会产生StackOverflowError</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackError</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(count);<br>        count++;<br>        main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210504173711.png" alt="image-20210504173704210"></p><p>我们设置虚拟机栈的大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-Xss256k<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210504174250.png" alt="image-20210504174250163"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210504174305.png" alt="image-20210504174305251"></p><p><strong>再次执行之后，我们发现count值变小了，这说明加入虚拟机栈中的栈帧变少了，说明虚拟机栈的大小变小了。</strong></p><h4 id="3-3、虚拟机栈原理"><a href="#3-3、虚拟机栈原理" class="headerlink" title="3.3、虚拟机栈原理"></a>3.3、虚拟机栈原理</h4><blockquote><p>栈中存储什么？</p><p>每个线程都有自己的栈，栈中的数据都是以栈帧(Stack Frame)的格式存在</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p></blockquote><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈。遵循”先进后出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(<strong>栈顶栈帧</strong>)是有效的，这个栈帧被称为当前栈帧(Current Frame)，与当前栈帧相对应的方法就是当前方法(Current Class)。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210505164858.png" alt="image-20210505164850122"></p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常，不管是使用哪种方式，都会导致栈帧被弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过debug查看栈帧</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackError</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodsA</span><span class="hljs-params">()</span>&#123;<br>        methodsB();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodsB</span><span class="hljs-params">()</span>&#123;<br>        methodsC();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodsC</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//依次调用方法</span><br>        methodsA();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506204012.png" alt="image-20210505171837156"></p><h4 id="3-4、虚拟机栈内部结构"><a href="#3-4、虚拟机栈内部结构" class="headerlink" title="3.4、虚拟机栈内部结构"></a>3.4、虚拟机栈内部结构</h4><p>每个栈帧大小取决于内部结构的大小。</p><p>每个栈帧中都存储着：</p><ul><li>&#x3D;&#x3D;局部变量表(Local Variables)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;操作数栈(Operand Stack)    或者表达式栈&#x3D;&#x3D;</li><li>动态链接(Dynamic Linkling)  或者指向运行时常量池的方法引用</li><li>方法返回地址(Return Address)  或者方法正常退出或者异常退出的定义</li><li>一些附加信息</li></ul><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506214951.png" alt="image-20210506214944393"></p><h5 id="3-4-1、局部变量表"><a href="#3-4-1、局部变量表" class="headerlink" title="3.4.1、局部变量表"></a>3.4.1、局部变量表</h5><h6 id="1、局部变量表的理解："><a href="#1、局部变量表的理解：" class="headerlink" title="1、局部变量表的理解："></a>1、局部变量表的理解：</h6><p>局部变量表也称为局部变量数组或本地变量表</p><p>定义为一个一维数字数组，主要用于存储<strong>方法参数</strong>和定义在<strong>方法体内的局部变量</strong></p><p>这个数据类型包括各类基本数据类型，对象引用。以及returnAddress类型(返回值类型)</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全性问题</p><p>局部变量表所需的容量大小是在编译期间确定下来的，并保存在方法Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><h6 id="2、通过字节码指令来理解局部变量表"><a href="#2、通过字节码指令来理解局部变量表" class="headerlink" title="2、通过字节码指令来理解局部变量表"></a>2、通过字节码指令来理解局部变量表</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以查看反编译字节码后的局部变量表</span><br><span class="hljs-comment">//我们可以看到，局部变量表中有四个数据</span><br><span class="hljs-comment">//args 是方法参数     test  num str 是方法体内的局部变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StatckTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StatckTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StatckTest</span>();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jiang&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506221804.png" alt="image-20210506221804808"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506221831.png" alt="image-20210506221831672"></p><p>我们借助jclasslib工具来查看字节码：</p><p>我们可以看到，局部变量表的最大槽数为4</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506225712.png" alt="image-20210506225712654"></p><p>我们这两个表的信息来对局部变量表进行分析：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506223400.png" alt="image-20210506223400172"></p><p>第一个表：LineNumberTable</p><p><img src="C:\Users\JiangZW\AppData\Roaming\Typora\typora-user-images\image-20210506230319259.png" alt="image-20210506230319259"></p><p>第二个表：LocalVariableTable</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506225623.png" alt="image-20210506225623014"></p><p>字节码指令：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506225804.png" alt="image-20210506225804529"></p><p>java代码：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506230502.png" alt="image-20210506230502352"></p><p><strong>分析：</strong></p><p>这两张表都有起始PC，可以通过这个起始PC将这两张表关联起来。</p><p>先看LocalVariableTable这张表：</p><p>起始PC和length需要一起看：我们可以看到起始PC和length相加始终等于<strong>字节码指令的条数</strong>。</p><p>这就是这个变量的<strong>作用域</strong>，而起始PC就是这个变量的作用域的起始地址。这个数字指的是对应的字节码指令。</p><p>我们看第一张表：LineNumberTable</p><p>我们和第二张表结合看：</p><p>起始PC对应的是字节码指令。而行号就是对应的Java源代码的行号</p><h6 id="3、关于Slot-槽-的理解："><a href="#3、关于Slot-槽-的理解：" class="headerlink" title="3、关于Slot(槽)的理解："></a>3、关于Slot(槽)的理解：</h6><p>Slot(变量槽)：局部变量表最基本的<strong>存储单元</strong>。</p><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</p><p> 局部变量表中存放编译期可知的各种基本数据类型，引用数据类型，returnAdderss类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot(包括returnAddress类型)，64位的类型占用两个slot</p><ul><li>byte、short、char、float在存储前被转换为int，boolean也被转换为int  0 表示false   非0表示true</li><li>long 和 double 则占据两个slot</li></ul><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量中指定的局部变量值。(如果是64位变量值时，只需要使用前一个索引即可)</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上。</p><p>如果当前帧是由构造方法或者实例方法(<strong>非静态方法</strong>)创建的，那么该<strong>对象引用this</strong>将会存放在在index为0的slot处，其余的参数按照参数表顺序继续排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是一个实例方法  需要将this 存放在 index0处，也即是序号为0处</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StatckTest</span> &#123;<br>    <span class="hljs-comment">//num需要一个槽  index1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-comment">//i需要一个槽  index2</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//dou需要两个槽  index3</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">dou</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.99</span>;<br>        <span class="hljs-comment">//l需要两个槽   index5</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506234703.png" alt="image-20210506234703569"></p><h6 id="关于slot重复利用的问题"><a href="#关于slot重复利用的问题" class="headerlink" title="关于slot重复利用的问题"></a>关于slot重复利用的问题</h6><p>我们看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        b = a + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量表的长度是多少？</p><p>我们可以看出：代码中定义了3个变量，而且是非静态方法，index0处存放this。需要4个槽？？</p><p>我们反编译字节码：看到只需要3个槽。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506235454.png" alt="image-20210506235454092"></p><p>这就涉及到变量作用域的问题：</p><p>我们看到变量b的起始PC和长度都为4，相加为8，那么它的作用域就是字节码指令是4-8的这一段。</p><p>字节码指令8之后，b被回收，index2就空闲。</p><p>此时c的起始PC是字节码指令12，即c的作用域是字节码指令12之后。那么c正好使用index2</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210506235623.png" alt="image-20210506235623658"></p><h5 id="3-4-2、操作数栈"><a href="#3-4-2、操作数栈" class="headerlink" title="3.4.2、操作数栈"></a>3.4.2、操作数栈</h5><ol><li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以称为表达式栈。</p></li><li><p><strong>操作数栈主要用于：保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p></li><li><p>一个新的栈帧创建出来时，这个方法的操作数栈是空的。</p></li><li><p>每个操作数栈都会拥有一个明确的栈深度用于存储数值。其所需的最大深度在编译器就定义好了。保存在方法的Code属性中，为Max_Stack的值</p></li></ol><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210507220257.png" alt="image-20210507220257550"></p><ol start="5"><li><p>32bit的类型占用一个栈单位深度，64bit的类型占用两个单位</p></li><li><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据。即入栈和出栈。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//举例  Java源代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//字节码指令<br>Code:<br>0 bipush 15         将15压栈<br>2 istore<span class="hljs-emphasis">_1          对应LocalVariableTable序号1</span><br><span class="hljs-emphasis">3 bipush 8          将8压栈</span><br><span class="hljs-emphasis">5 istore_</span>2对应LocalVariableTable序号2<br>6 iload<span class="hljs-emphasis">_1序号1出栈</span><br><span class="hljs-emphasis">7 iload_</span>2序号2出栈<br>8 iadd指令相加<br>9 istore<span class="hljs-emphasis">_3    对应LocalVariableTable序号3</span><br><span class="hljs-emphasis">10 return返回</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210507214424.png" alt="image-20210507214416906"></p><blockquote><ol><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈的栈顶，并更新PC寄存器中的下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</li></ol></blockquote><h5 id="3-4-3、动态链接"><a href="#3-4-3、动态链接" class="headerlink" title="3.4.3、动态链接"></a>3.4.3、动态链接</h5><p>每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接。、</p><h5 id="3-4-4、方法返回地址"><a href="#3-4-4、方法返回地址" class="headerlink" title="3.4.4、方法返回地址"></a>3.4.4、方法返回地址</h5><p>方法执行时由两种退出情况：</p><ol><li>正常退出，即正常执行到任何方法的返回字节码指令，如RETURN、IREURN、ARETURN</li><li>异常退出</li></ol><p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出栈帧，退出可能由三种方式：</p><ol><li>返回值压入上层调用的栈帧</li><li>异常信息抛给能够处理的栈帧</li><li>PC计数器指向方法调用后的下一条指令</li></ol><h3 id="4、本地方法接口和本地方法栈"><a href="#4、本地方法接口和本地方法栈" class="headerlink" title="4、本地方法接口和本地方法栈"></a>4、本地方法接口和本地方法栈</h3><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210508081604.png" alt="image-20210507234041501"></p><h4 id="4-1、本地方法接口-Native-Method-Interface"><a href="#4-1、本地方法接口-Native-Method-Interface" class="headerlink" title="4.1、本地方法接口 (Native Method Interface)"></a>4.1、本地方法接口 (Native Method Interface)</h4><blockquote><p>什么是本地方法接口</p><p>简单来说：一个Native Method就是一个Java调用非Java代码的接口。 </p></blockquote><p>什么是Native方法：该方法的实现由非Java语言实现，比如C、C++。这个特征并非Java所特有的，很多其他的编程语言都有这一机制。</p><p>在定义一个native method时，并不提供实现体，因为其实现体是由非Java语言在外面实现的。</p><p>&#x3D;&#x3D;native 关键字和其余的关键字一起使用，除了abstract关键字&#x3D;&#x3D;</p><h6 id="我们为什么要使用Native-Method"><a href="#我们为什么要使用Native-Method" class="headerlink" title="我们为什么要使用Native Method"></a>我们为什么要使用Native Method</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有的Java应用需要与Java外面的环境交互，我们可以不去关心Java应用之外的细节<br><span class="hljs-bullet">2.</span> Java应用需要与操作系统交互<br><span class="hljs-bullet">3.</span> Sun的解释器是用C实现的，这样Java就可以像普通的C一样与外部交互<br></code></pre></td></tr></table></figure><h4 id="4-2、本地方法栈-Native-Method-Stack"><a href="#4-2、本地方法栈-Native-Method-Stack" class="headerlink" title="4.2、本地方法栈(Native Method Stack)"></a>4.2、本地方法栈(Native Method Stack)</h4><ol><li><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</p></li><li><p>本地方法栈也是线程私有的。</p></li><li><p>允许被实现成固定或者可动态扩展的内存大小，这一点和Java虚拟机栈一样。也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p></li></ol><blockquote><p>线程开始调用本地方法时，会进入 个不再受 JVM 约束的世界。本地方法可以通过 JNI(Java Native Interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和 JVM 相同的能力和权限。 当大量本地方法出现时，势必会削弱 JVM 对系统的控制力，因为它的出错信息都比较黑盒。对内存不足的情况，本地方法栈还是会抛出 nativeheapOutOfMemory。</p></blockquote><h3 id="5、堆"><a href="#5、堆" class="headerlink" title="5、堆"></a>5、堆</h3><h4 id="5-1、堆概述"><a href="#5-1、堆概述" class="headerlink" title="5.1、堆概述"></a>5.1、堆概述</h4><blockquote><ol><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间</li><li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间，但是在逻辑上它应该被视为连续的</li><li>所有的线程共享Java堆，在这里还可以划分为线程私有的缓冲区(Thead Local Allocation Buffer)</li><li>《Java虚拟机规范》中堆Java堆的描述是：几乎所有的对象以及数组都应当在运行时分配在堆上</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</li><li>堆 是GC执行垃圾回收的重点区域</li></ol></blockquote><h4 id="5-2、堆内存细分"><a href="#5-2、堆内存细分" class="headerlink" title="5.2、堆内存细分"></a>5.2、堆内存细分</h4><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间在&#x3D;&#x3D;逻辑&#x3D;&#x3D;上细分为：</p><ul><li>Java7及之前：新生代  +   老年代   +  永久区</li></ul><blockquote><p>Young Generation Space   新生代</p><p>​又分为Eden区和Survivor区</p><p>Tenure generation space  老年代</p><p>Permanent Space              永久区   </p></blockquote><ul><li>Java8及之后： 新生代  +  老年代  +  元空间</li></ul><blockquote><p>Young Generation Space   新生代</p><p>​又分为Eden区和Survivor区</p><p>Tenure generation space  老年代</p><p>Meta Space                        元空间</p></blockquote><p>但是在物理上：<strong>永久代在方法区</strong></p><p>我们为虚拟机添加参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-Xms10m -Xmx10m   -- 表示虚拟机的堆空间<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//让线程睡1000秒</span><br>            <span class="hljs-comment">//因为只有我们在程序运行中才能看到堆空间</span><br>            Thread.sleep(<span class="hljs-number">100000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们打开一个工具：jvisualvm.exe</p><p>安装在jdk&#x2F;bin 目录下。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210510224336.png" alt="image-20210510224328961"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210510224421.png" alt="image-20210510224421848"></p><p>我们看到堆空间的大小，我们还可以看到内存的细节：</p><p>安装插件：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210510224638.png" alt="image-20210510224638115"></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210510224852.png" alt="image-20210510224852323"></p><p>根据图可以看到：</p><p>新生代有3M，老年代有7M。正好是10M。因此我们在虚拟机上设置的堆内存没有包含方法区。</p><h4 id="5-3、堆内存设置和OOM-OutOfMemeoryError"><a href="#5-3、堆内存设置和OOM-OutOfMemeoryError" class="headerlink" title="5.3、堆内存设置和OOM(OutOfMemeoryError)"></a>5.3、堆内存设置和OOM(OutOfMemeoryError)</h4><p>我们可以通过虚拟机参数：<code>-Xms</code>和<code>-Xmx</code>来设置堆大小</p><ul><li><p>Xms 用于表示堆空间初始大小(新生代  +  老年代)，等价于-XX：InitialHeapSize</p></li><li><p>Xmx 用于表示堆区的最大内存(新生代  +  老年代)，等价于-XX：MaxHeapSize</p></li></ul><blockquote><p>-X  表示虚拟机参数</p></blockquote><p>一旦堆区中的内存大小超过 -Xmx 所指定的最大内存时。将会抛出OutOfMemeoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p><p>默认情况下，初始内存大小：物理电脑内存大小  &#x2F;  64  </p><p>​  最大内存大小：物理电脑内存大小 &#x2F; 4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//返回Java虚拟机中堆内存总量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br><br>        <span class="hljs-comment">//返回Java虚拟机试图使用的最大堆内存量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;系统内存大小：&quot;</span> + initialMemory * <span class="hljs-number">64</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;系统内存大小：&quot;</span> + maxMemory * <span class="hljs-number">4</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我的电脑的内存是8G  系统内存大小接近8G</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210510231836.png" alt="image-20210510231744017"></p><p>OOM例子：</p><p>我们将堆空间的大小改小一点：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-Xms100m -Xmx100m<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMError</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//为了在jvisualvm.exe上看到内存情况，让它慢一点执行</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//死循环  在堆上创建新对象</span><br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OOMError</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>出现OOM异常：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210510233854.png" alt="image-20210510233854010"></p><h4 id="5-4、新生代和老年代"><a href="#5-4、新生代和老年代" class="headerlink" title="5.4、新生代和老年代"></a>5.4、新生代和老年代</h4><p>存储在JVM中Java对象可以被划分为两类</p><ul><li>一类生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</li><li>另一类生命周期非常长，在某些极端的情况下还能于JVM的生命周期保持一致。</li></ul><p>Java堆区进一步细分的话，可以划分为新生代和老年代</p><p>其中新生代又可以划分为Eden区、Survivor0区和Survivor1区(也可称为from区、to区)</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210511000332.png" alt="image-20210511000331965"></p><h5 id="如何设置新生代和老年代占堆空间的大小"><a href="#如何设置新生代和老年代占堆空间的大小" class="headerlink" title="如何设置新生代和老年代占堆空间的大小"></a>如何设置新生代和老年代占堆空间的大小</h5><p>默认 ：-XX：NewRatio &#x3D; 2   表示新生代占1，老年代占2  ，新生代占整个堆区的1&#x2F;3</p><p>可以进行修改-XX：NewRatio &#x3D; 4，新生代占整个堆区的1&#x2F;5</p><p>例子：</p><p>配置堆内存大小和新生代老年代占比</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-Xms10m  -Xmx10m  -XX:NewRatio=4<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>几乎所有的Java对象都是在Eden区被new出来的。</p><p>绝大部分的Java对象的销毁都是在新生代进行了</p><blockquote><p>根据IBM公司的专门研究表明，新生代中80%的对象都是”朝生夕死”</p></blockquote><p>可以使用选项”-Xmn”设置新生代最大内存大小 </p><h5 id="如何设置新生代中Eden和Survivor区的占比"><a href="#如何设置新生代中Eden和Survivor区的占比" class="headerlink" title="如何设置新生代中Eden和Survivor区的占比"></a>如何设置新生代中Eden和Survivor区的占比</h5><p>默认：Eden ： Survivor0  :  Survivor1  &#x3D;  8  :  1  :  1</p><p>我们需要设置 <code>+XX:SurvivorRatio = 8</code></p><h3 id="6、方法区"><a href="#6、方法区" class="headerlink" title="6、方法区"></a>6、方法区</h3><h4 id="6-1、方法区概述"><a href="#6-1、方法区概述" class="headerlink" title="6.1、方法区概述"></a>6.1、方法区概述</h4><p>方法区存储的是什么？</p><p>在一个JVM实例的内部，类型信息被存储在一个称为方法区的内存逻辑中。类型信息是由类加载器在类加载时从类文件中提取出来的。类(静态)变量也存储在方法区中。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210511003637.png" alt="image-20210511003637874"></p><p>方法区在什么位置？</p><p>《Java虚拟机规范》中明确说明：”尽管所有的方法区在逻辑上是堆的一部分，但一些简单的实现可能不会选择区进行垃圾收集或者进行压缩”，但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是和堆分开。</p><p>所以，&#x3D;&#x3D;方法区看作是一块独立于Java堆的内存空间&#x3D;&#x3D;。</p><blockquote><ol><li><p>方法区的大小和堆空间一样，可以选择固定大小或者可扩展</p></li><li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误。java.lang.OutOfMemoryError Metaspace</p><p>（加载大量的第三方jar包，Tomcat部署的工程过多，大量的动态生成反射类）</p></li><li><p>关闭JVM会释放这个区域</p></li></ol></blockquote><h4 id="6-2、方法区的演进"><a href="#6-2、方法区的演进" class="headerlink" title="6.2、方法区的演进"></a>6.2、方法区的演进</h4><p>在java1.7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><p>在本质上，方法区和永久代并不等价。我们可以将<strong>元空间和永久代理解为方法区的实现</strong>。</p><p>永久代和元空间的区别：</p><p>&#x3D;&#x3D;永久代占据的是虚拟机的内存&#x3D;&#x3D;</p><p>&#x3D;&#x3D;元空间占据是本地内存&#x3D;&#x3D;</p><p>永久代和元空间的内部结构也有许多的变化，比如字符串常量池、静态变量等。 </p><p>具体版本之间的演进：</p><table><thead><tr><th>版本</th><th>变化</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，静态变量存放咋永久代上</td></tr><tr><td>jdk1.7</td><td>有永久代，字符串常量池、静态变量保存在堆中</td></tr><tr><td>jdk1.8及之后</td><td>无永久代，类型信息，域信息存放在元空间中，字符串常量池和静态变量存放在堆上</td></tr></tbody></table><blockquote><p>hotspot为什么用元空间替代永久代</p><ol><li><p>避免OOM异常</p><p>因为通常使用PermSize和MaxPermSize设置永久代大小就决定了永久代的上限。因此可能会有OOM异常</p><p>元空间存在本地内存中，有系统的实际可用空间来控制，也可以通过虚拟机参数来控制-XX:MaxMetaspaceSize</p></li><li><p>提高GC性能</p><p>永久代的对象在Full GC时进行垃圾收集，也就是和老年代同时垃圾收集</p><p>替换后，简化了Full GC，可以在GC不进行暂停的情况下并发地释放类数据。</p></li><li><p>持久代的问题</p><p>HotSpot的内部类型也是Java对象，他可能会在Full GC中被移动，同时他对应用不透明，且是非强型的，难以跟踪调试。还需要存储元数据的元数据信息。</p></li><li><p>合并HotSpot和JRockit</p><p>合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行新能的问题。</p></li></ol></blockquote><h4 id="6-3、设置方法区的大小"><a href="#6-3、设置方法区的大小" class="headerlink" title="6.3、设置方法区的大小"></a>6.3、设置方法区的大小</h4><p>方法区的大小和堆空间一样，可以选择固定大小、可扩展。</p><p>演示Java7的方法区大小设置：</p><p>通过-XX:PermSize来设置永久代初始化分配空间。默认值是20.75M</p><p>通过-XX:MaxPermSize来设置永久代最大的可分配空间。</p><p>演示Java8的方法区大小设置：</p><p><code>元空间的大小可以使用参数-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize</code>指定。</p><p>元空间的大小默认值依赖与不同的平台：</p><p><strong>在windows下 ，-XX:MetaspaceSize 是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制</strong></p><blockquote><p>MetaspaceSize设置的是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类。即这些类对应的类加载器不在存活。然后这个高水位线将会重置，新的高水位线的值取决于GC后释放了多少空间。</p><p>如果设置的初始的好水位线设置过低，那么这种高水位线的调整会发生很多次。Full GC多次调用。为了避免频繁GC，建议设置一个较高的值。</p></blockquote><h4 id="6-4、OOM"><a href="#6-4、OOM" class="headerlink" title="6.4、OOM"></a>6.4、OOM</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//使用-XX:-UseCompressedOops 关闭指针压缩参数后 出现 java.lang.OutOfMemory：metaspace</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Demo1</span> <span class="hljs-variable">OOMTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo1</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-comment">//创建ClassWriter对象，用于生成类的二进制字节码</span><br>                <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">//指定版本号，修饰符，类名，包名，父类，接口</span><br>                classWriter.visit(Opcodes.V1_8,Opcodes.ACC_PUBLIC,<span class="hljs-string">&quot;Class&quot;</span> + i,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;java/lang/Object&quot;</span>,<span class="hljs-literal">null</span>);<br>                <span class="hljs-comment">//返回byte[]</span><br>                <span class="hljs-type">byte</span>[] code = classWriter.toByteArray();<br>                <span class="hljs-comment">//类的加载</span><br>                OOMTest.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i,code,<span class="hljs-number">0</span>,code.length);<span class="hljs-comment">//Class对象</span><br>                j++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚拟机参数设置为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-XX:-UseCompressedOops -XX:MetaspaceSize=5m -XX:MaxMetaspaceSize=5M <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210511234452.png" alt="image-20210511234444903"></p><blockquote><p>如何解决这些OOM？</p><ol><li>通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置</li><li>如果不存在内存泄漏，也就是说内存中的对象都还存活着。那就应当检查虚拟机的参数（-Xms 和 -Xmx），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol></blockquote><h4 id="6-5、方法区内部结构"><a href="#6-5、方法区内部结构" class="headerlink" title="6.5、方法区内部结构"></a>6.5、方法区内部结构</h4><p>&#x3D;&#x3D;类型信息&#x3D;&#x3D;</p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储一下类型信息：</p><ol><li>这个类型的完整有效名称（包名.类名）</li><li>这个类型直接父类的完整有效名</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型实现接口的一个有序列表</li></ol><p>&#x3D;&#x3D;域信息&#x3D;&#x3D;</p><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符等</p><p>&#x3D;&#x3D;方法信息&#x3D;&#x3D;</p><p>JVM必须在方法区保存所有方法的信息</p><p>方法信息包括：方法名称、方法的返回类型、方法参数的数量和类型、方法修饰符、方法的字节码、异常表（每个异常处理的开始位置、结束位置等）</p><p>&#x3D;&#x3D;no-final&#x3D;&#x3D;</p><p>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。类变量被类的所有实例共享，即使没有类实例时你也可以访问它。</p><p>&#x3D;&#x3D;运行时常量池&#x3D;&#x3D;</p><h4 id="6-6、运行时常量池"><a href="#6-6、运行时常量池" class="headerlink" title="6.6、运行时常量池"></a>6.6、运行时常量池</h4><p>常量池和运行时常量池：</p><p>&#x3D;&#x3D;什么是常量池&#x3D;&#x3D;：</p><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池中，这个字节码包含了指向常量池的引用。在动态链接的时候会用到<strong>运行时常量池</strong>。</p><p>常量池，可以看做是一场表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><br>        <span class="hljs-type">Demo2</span> <span class="hljs-variable">demo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo2</span>();<br>        System.out.println(s);<br>        System.out.println(demo2);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210512151710.png" alt="image-20210512151710672"></p><p>&#x3D;&#x3D;常量池和运行时常量池的对比&#x3D;&#x3D;：</p><blockquote><ol><li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p></li><li><p>常量池（Constant Pool Table）是 Class文件的一部分，<code>用于存放编译期间生成的各种字面量和符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中。</code></p></li><li><p>运行时常量池相对于常量 具备 动态性。</p></li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Volatile</title>
    <link href="/2021/01/03/volatile/"/>
    <url>/2021/01/03/volatile/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p><code>vloatile关键字是Java虚拟机提供的最轻量级的同步机制</code>，本文介绍volatile的作用和底层实现原理。</p><h3 id="1、volatile解决线程安全性问题"><a href="#1、volatile解决线程安全性问题" class="headerlink" title="1、volatile解决线程安全性问题"></a>1、volatile解决线程安全性问题</h3><p>我们说过，在多线程中存在竟态条件，会出现<a href="https://blog.csdn.net/weixin_43203735/article/details/115800950">线程安全性问题</a></p><p><code>volatile关键字作用是保证可见性和有序性，并不会保证原子性。</code></p><h5 id="volatile可以解决可见性问题"><a href="#volatile可以解决可见性问题" class="headerlink" title="volatile可以解决可见性问题"></a>volatile可以解决可见性问题</h5><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        flag = <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">safeVolatileDemo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ThreadDemo1</span> <span class="hljs-variable">threadDemo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo1</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo1);<br>        thread.start();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span> (threadDemo1.flag == <span class="hljs-literal">true</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;ThreadDemo1.flag = true&quot;</span>);<br><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="volatile解决重排序问题"><a href="#volatile解决重排序问题" class="headerlink" title="volatile解决重排序问题"></a>volatile解决重排序问题</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiang.ThreadSafe.safeVolatile;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重排序可能会带来的问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">safeVolatileDemo2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            count++;<br>            x = <span class="hljs-number">0</span>;<br>            y = <span class="hljs-number">0</span>;<br>            i = <span class="hljs-number">0</span>;<br>            j = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    i = <span class="hljs-number">1</span>;<br>                    x = j;<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    j = <span class="hljs-number">1</span>;<br>                    y = i;<br>                &#125;<br>            &#125;);<br>            two.start();<br>            one.start();<br>            one.join();<br>            two.join();<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;第&quot;</span> + count + <span class="hljs-string">&quot;次（&quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(result);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(result);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一直循环</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210419104609.png" alt="image-20210419104609298"></p><h3 id="2、volatile作用"><a href="#2、volatile作用" class="headerlink" title="2、volatile作用"></a>2、volatile作用</h3><p>在Happens-before先行发生原则中，有对volatile字段的描述</p><blockquote><p>对某个volatile字段的写操作happens-before(先行于)每个后续对该volatile字段的读操作</p></blockquote><p>对于一个线程对由volatile字段修饰的变量进行读操作时，直接读取主内存中的数据，进行写操作，直接写到主内存中。</p><p>使用volatile修饰字段之后：</p><ol><li><p>修改的值会立即写回主存</p></li><li><p>修改值之后，其他线程中的工作内存的数据置为无效(在CPU缓存时提到，MESI会将数据设置为四种状态)</p></li><li><p>工作内存中数据无效，会直接读取主内存中的数据</p></li></ol><h3 id="3、volatile原理"><a href="#3、volatile原理" class="headerlink" title="3、volatile原理"></a>3、volatile原理</h3><p><code>加入volatile关键字时，所生成的汇编代码会多出一条lock前缀指令</code></p><p>​这一条指令实际上相当于一个内存屏障(也称为内存栅栏)，内存屏障会提供三个功能：</p><ol><li><p>确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面。即在执行到内存屏障这句指令时，在它前面的操作已经全部完成</p></li><li><p>它会强制将对缓存的修改操作立即写入主存</p></li><li><p>如果是写操作，他会导致其他CPU中的对应的缓存行无效</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程中的几个概念</title>
    <link href="/2020/12/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/12/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h4 id="多线程中的几个概念"><a href="#多线程中的几个概念" class="headerlink" title="多线程中的几个概念"></a>多线程中的几个概念</h4><p>1、 线程的进程的区别</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">每个正在运行系统上运行的程序都是一个进程。每个进程中包含一到多个线程。<br><br>线程是一组指令的集合，或者是程序的特殊段，它可以在程序中独立执行。也可以把它理解为代码运行的上下文。因此线程基本上是轻量级的进程，它负责在单个程序中执行多任务。<br><br>进程是所有线程的集合，每一个线程是进程中的一条执行路径。<br></code></pre></td></tr></table></figure><p>2、 并发(Concurrency)和并行(Parallelism)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">无论是单CPU还是多CPU，操作系统都营造出了同时运行多个程序的假象。实际的过程是CPU的快速切换。<br><br>并发和并行都是多个进程同时运行。<br><br>并发说的是在一个时间段内，多件事情在这个时间段内交替执行。<br>并行说的是多件事情在同一个时刻同事发生。<br></code></pre></td></tr></table></figure><p>3、 同步(Synchronous)和异步(Asynchronous)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">线程同步是多个线程访问同一资源，等待资源访问结束，浪费时间和CPU，效率低。<br><span class="hljs-bullet">-</span> 同步方法调用开始后，调用者必须等到方法调用返回后，才能继续执行之后的方法。<br><br>线程异步是访问资源是在空闲等待是同时访问其他资源<br><span class="hljs-bullet">-</span> 异步方法调用更像是一次消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续执行之后的方法<br></code></pre></td></tr></table></figure><span id="more"></span><p>4、 阻塞和非阻塞</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">阻塞和非阻塞通常用来形容很多线程间的相互影响。<br>一个线程占用了临界区资源，其他需要该资源的线程必须等待，等待会导致线程挂起，这种情况就是阻塞。<br>非阻塞就是没有一个线程可以妨碍其他线程执行，所有的线程都会尝试不断向前执行<br></code></pre></td></tr></table></figure><p>5、 死锁(Deadlock)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 死锁的概念</span><br><span class="hljs-code">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。</span><br><span class="hljs-code">若无外力作用，它们都将无法推进下去。</span><br><span class="hljs-code">此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</span><br><span class="hljs-code"></span><br><br><span class="hljs-section"># 产生的条件</span><br>1、 互斥条件<br>2、 请求和保持条件<br>3、 不剥削条件<br>4、 环路等待条件<br><br>如何避免死锁<br></code></pre></td></tr></table></figure><p> 6、 饥饿(Starvation)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">饥饿是指某一个或者多个线程因为种种原因无法获得所要的资源。<br>比如:线程优先级太低<br></code></pre></td></tr></table></figure><p>7、 活锁(Livelock)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">活锁是主动将资源释放给他人使用，那么久会导致资源不断地在两个线程间跳动，而没有一个线程可以同时拿到所有资源正常执行<br></code></pre></td></tr></table></figure><p>8、 临界区</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">表示一种公共资源或者说共享数据，比如打印机<br></code></pre></td></tr></table></figure><p>9、 用户线程和守护线程</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">用户线程是指一个普通的线程，比如main程序<br>守护线程是指用来服务于用户线程，不需要上层逻辑介入，比如GC<br></code></pre></td></tr></table></figure><p>10、上下文切换</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">CPU通过时间片分配算法来循环任务，当前任务执行一个时间片会切换到下一个任务，但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产者消费者问题</title>
    <link href="/2020/12/05/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <url>/2020/12/05/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p><code>生产者与消费者问题是多线程同步问题的经典案例。也称有限缓冲问题。</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 什么是生产者消费者问题</span><br>该问题描述了共享固定大小缓冲区的线程，生产者的主要作用是生成一定量的数据放到缓冲区，消费者也在缓冲区消耗这些数据。<br>这类问题的关键在于保证生产者不会在缓冲区满时加入数据，消费者也不会下缓冲区空时消耗数据。<br><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 如何解决这类问题</span><br>生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。<br>同样，让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。<br><br>通常采用进程间通信的方法解决该问题，常用的方法有信号灯法等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">桌上有一空盘，最多允许存放一个水果。爸爸可向盘中放一个水果或放一个橘子，儿子专等吃盘中的橘子。女儿专等吃苹果。<br>试用P、V操作和Java程序实现爸爸，儿子，女儿三个并发进程的同步。<br></code></pre></td></tr></table></figure><h4 id="P、V操作"><a href="#P、V操作" class="headerlink" title="P、V操作"></a>P、V操作</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">根据题意，我们知道父亲是生产者，儿子、女儿是消费者。盘中的水果是共享资源。<br>因为盘中最多允许存放一个水果，在生产前需要判断是否为满。<br><br>利用互斥信号量mutex实现互斥，利用empty信号量来判断盘中是否为空。<br>利用or信号量和ap信号量来判断盘中的橘子和苹果的数量。<br>两个函数判断是否是橘子或者苹果。put(or) put(ap)<br><br>设置初始值：<br>mutex = 1  empty = 1  or = 0  ap = 0<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">三个进程<br>父亲：<br>P(empty)<br>if(put(or))<br><span class="hljs-code">V(or)</span><br><span class="hljs-code">else</span><br><span class="hljs-code">V(ap)</span><br><span class="hljs-code"></span><br><br>儿子：<br>P(or)<br>V(empty)<br><br>女儿：<br>P(ap)<br>v(empty)<br></code></pre></td></tr></table></figure><h4 id="java程序"><a href="#java程序" class="headerlink" title="java程序"></a>java程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * empty 的取值有不同的意义：</span><br><span class="hljs-comment">     * 0  表示盘中无水果</span><br><span class="hljs-comment">     * 1  表示盘中的水果是橘子</span><br><span class="hljs-comment">     * 2  表示盘中的水果是苹果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//生产资源，，有生产者线程调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(empty != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;盘中有水果，生产者正在等待&quot;</span>);<br>                wait();<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//此时盘中无水果</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomInt</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>        empty = randomInt;<br>        <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;爸爸放入橘子&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;爸爸放入苹果&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br><br><br>    <span class="hljs-comment">//消耗资源，有消费者线程调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(empty == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;盘中无水果，消费者等待&quot;</span>);<br>                wait();<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//此时盘中有水果</span><br>        empty = <span class="hljs-number">0</span>;<br>        System.out.println(<span class="hljs-string">&quot;盘中无水果&quot;</span>);<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>                    fruit.put();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">daughter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">while</span>(fruit.empty == <span class="hljs-number">2</span>)&#123;<br>                        System.out.println(<span class="hljs-string">&quot;女儿拿到苹果&quot;</span>);<br>                        fruit.get();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">son</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">while</span>(fruit.empty == <span class="hljs-number">1</span>)&#123;<br>                        System.out.println(<span class="hljs-string">&quot;儿子拿到橘子&quot;</span>);<br>                        fruit.get();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        son.start();<br>        daughter.start();<br>        father.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210415095537.png" alt="image-20210415095401843"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建线程的方式</title>
    <link href="/2020/10/05/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/10/05/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><h4 id="1、Thread类构造方法"><a href="#1、Thread类构造方法" class="headerlink" title="1、Thread类构造方法"></a>1、Thread类构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread类源码</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span><br><span class="hljs-params"> <span class="hljs-type">long</span> stackSize, AccessControlContext acc,</span><br><span class="hljs-params"> <span class="hljs-type">boolean</span> inheritThreadLocals)</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">我们解释在初始化方法中的参数：<br>ThreadGroup g           线程组，指定这个线程是在哪个线程组下<br>Runnable    target      指定要执行的任务<br>String      name        线程的名字，多个线程的名字是可以重复的。<br><br>AccessControlContext acc        用于初始化变量inheritedAccessControlContext<br>boolean inheritThreadLocals     可继承的ThreadLocal<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="2、继承Thread"><a href="#2、继承Thread" class="headerlink" title="2、继承Thread"></a>2、继承Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread方法&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread方法&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1、 创建线程</span><br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">threadDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br>        <span class="hljs-comment">//2、 线程开始执行，调用的不是run()方法，而是start()方法</span><br>        <span class="hljs-comment">//如果调用run方法相当于在主线程中执行</span><br>        <span class="hljs-comment">//注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出异常</span><br>        threadDemo.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210410163422.png" alt="20210225161631"></p><h4 id="3、-实现Runnable"><a href="#3、-实现Runnable" class="headerlink" title="3、 实现Runnable"></a>3、 实现Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread方法&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread方法&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadDemo2</span> <span class="hljs-variable">threadDemo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo2);<br><br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、-实现callable"><a href="#4、-实现callable" class="headerlink" title="4、 实现callable"></a>4、 实现callable</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">实现callable接口，重写call()方法，将所要完成的代码写进call()方法中，需要注意的是call()方法有返回值，并且可以抛出异常<br><br>如果想要获取运行该线程后的返回值，需要创建Future接口的实现类的对象，即FutureTask类对象，调用该对象的get()方法可获取call()方法的返回值。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;ThreadDemo3.call&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//创建FutureTask的对象</span><br>        FutureTask&lt;Integer&gt; FutureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo3</span>());<br>        <span class="hljs-comment">//创建Thread类的对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(FutureTask);<br>        <span class="hljs-comment">//线程执行</span><br>        thread.start();<br>        <span class="hljs-comment">//获取返回值</span><br>        System.out.println(FutureTask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210410163448.png" alt="20210225164503"></p><h4 id="5、-通过线程池"><a href="#5、-通过线程池" class="headerlink" title="5、 通过线程池"></a>5、 通过线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在被执行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//实现Runnable接口</span><br>        <span class="hljs-type">ThreadDemo4</span> <span class="hljs-variable">threadDemo4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo4</span>();<br>        <span class="hljs-comment">//创建单线程线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">//线程执行</span><br>            executor.execute(threadDemo4);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210410163507.png"></p><h4 id="6、-继承Thread类和实现Runnable接口的比较"><a href="#6、-继承Thread类和实现Runnable接口的比较" class="headerlink" title="6、 继承Thread类和实现Runnable接口的比较"></a>6、 继承Thread类和实现Runnable接口的比较</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 两者之间没有本质的区别</span><br>唯一的区别就是类和接口的区别<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2020/10/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/10/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象，一个最好的办法就是，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建。并且它可以提供一个访问该实例的方法。</p><p><strong>单例模式使用场景：</strong></p><p>需要频繁的进行创建和销毁对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到对象、工具类对象、频繁访问数据库或文件的对象（比如数据源，session工厂）。</p><p><strong>单例模式的五种方式：</strong></p><h4 id="1、饿汉式"><a href="#1、饿汉式" class="headerlink" title="1、饿汉式"></a>1、饿汉式</h4><h5 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingLeton1</span>&#123;<br>    <span class="hljs-comment">//将构造器私有化，防止用new来创建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingLeton1</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//我们声明一个静态属性SingLeton1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingLeton1</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingLeton1</span>();<br><br>    <span class="hljs-comment">//提供一个静态方法，可以返回SingLeton1的唯一对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingLeton1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//无法直接new</span><br>    <span class="hljs-comment">//SingLeton1 singLeton1 = new SingLeton1();</span><br>    <span class="hljs-type">SingLeton1</span> <span class="hljs-variable">singLeton1</span> <span class="hljs-operator">=</span> SingLeton1.getInstance();<br>    <span class="hljs-type">SingLeton1</span> <span class="hljs-variable">singLeton2</span> <span class="hljs-operator">=</span> SingLeton1.getInstance();<br><br>    System.out.println(singLeton1.hashCode() == singLeton2.hashCode());   <span class="hljs-comment">//true</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingLeton2</span>&#123;<br><br>    <span class="hljs-comment">//将构造器私有化，防止用new来创建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingLeton2</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingLeton2 insance;<br><br>    <span class="hljs-comment">//在静态代码块执行时，常见单例对象</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        insance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingLeton2</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//提供一个静态方法，可以返回SingLeton2的唯一对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingLeton2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> insance;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//无法直接new</span><br>    <span class="hljs-comment">//SingLeton2 singLeton1 = new SingLeton2();</span><br>    <span class="hljs-type">SingLeton2</span> <span class="hljs-variable">singLeton1</span> <span class="hljs-operator">=</span> SingLeton2.getInstance();<br>    <span class="hljs-type">SingLeton2</span> <span class="hljs-variable">singLeton2</span> <span class="hljs-operator">=</span> SingLeton2.getInstance();<br><br>    System.out.println(singLeton1.hashCode() == singLeton2.hashCode());  <span class="hljs-comment">//true</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>静态代码块方法和静态常量方法其实类似，只不过静态代码块方法将类实例化的过程放在了静态代码块中，也是在类加载的时候，就执行静态代码块中的代码。</p><p>分析：</p><p>饿汉式的方式在初始化时就创建好了对象，不管你之后是否用到，都会创建以一个实例。</p><p>因此<strong>它没有线程安全的问题，但是浪费内存空间</strong></p><h5 id="2、懒汉式"><a href="#2、懒汉式" class="headerlink" title="2、懒汉式"></a>2、懒汉式</h5><p>线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton1</span>&#123;<br><br>    <span class="hljs-comment">//构造方法私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton1</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton1 singLeton1;<br><br>    <span class="hljs-comment">//当调用getInstance时，才创建单例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(singLeton1 == <span class="hljs-literal">null</span>)&#123;<br>            singLeton1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton1</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> singLeton1;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Singleton1</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton1.getInstance();<br>    <span class="hljs-type">Singleton1</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton1.getInstance();<br><br>    System.out.println(singleton1.hashCode() == singleton2.hashCode());  <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只能在单线程下使用，</p><p>如果在多线程下，一个线程进入了if(singleton &#x3D;&#x3D; null) 判断语句块中，还未来得及去创建实例对象，另一个线程也通过了这个判断语句，这是便会产生多个实例。所以在多线程环境下不可使用这种方式。</p><p>线程安全，同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton2</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 singleton2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(singleton2 == <span class="hljs-literal">null</span>)&#123;<br>            singleton2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton2</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> singleton2;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Singleton2</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton2.getInstance();<br>    <span class="hljs-type">Singleton2</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton2.getInstance();<br><br>    System.out.println(singleton1.hashCode() == singleton2.hashCode());  <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式<strong>解决了线程不安全问题，但效率太低了</strong>，每个线程在想获取类的实例时，都要进行同步。</p><h5 id="3、双重检查"><a href="#3、双重检查" class="headerlink" title="3、双重检查"></a>3、双重检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-comment">//构造方式私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br><br>    <span class="hljs-comment">//加volatile就可以实现线程安全的延迟初始化,因为被volatile关键字修饰的变量是被禁止重排序的。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(singleton == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(singleton == <span class="hljs-literal">null</span>)&#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><br>    System.out.println(instance == instance1);  <span class="hljs-comment">//true</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>即保证了线程安全，有比直接上锁提高了执行效率，还节省了内存空间</p><h5 id="4、静态内部类"><a href="#4、静态内部类" class="headerlink" title="4、静态内部类"></a>4、静态内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonInstance</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><br><br>    System.out.println(singleton1.hashCode() == singleton2.hashCode());   <span class="hljs-comment">//true</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式采用了类加载的机制来保证初始化时只有一个线程。</p><p>静态内部类方式在Singleton类被加载时并不会立即实例化，而是在需要实例化时，调用getInstance()方法，才会加载SingletonInstance类，从而完成Singleton的实例化。</p><h5 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    INSTANCE<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance1</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br><br>    System.out.println(instance1.hashCode() == instance2.hashCode());  <span class="hljs-comment">//true</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>枚举能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的通信</title>
    <link href="/2020/10/05/%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <url>/2020/10/05/%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="线程的其他方法"><a href="#线程的其他方法" class="headerlink" title="线程的其他方法"></a>线程的其他方法</h2><h3 id="1-终止线程"><a href="#1-终止线程" class="headerlink" title="1. 终止线程"></a>1. 终止线程</h3><p><code>一般来说线程的执行完毕就会结束，无需手动关闭。但当我们需要手动杀死一个正在运行的线程。可以通过一些方法。</code></p><h4 id="stop方法-废弃"><a href="#stop方法-废弃" class="headerlink" title="stop方法(废弃)"></a>stop方法(废弃)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># stop()方法不推荐使用</span><br>因为stop()方法太暴力，会强制杀死线程。<br><br>这就类似于: 你正在写文档，突然停电，文档没有保存。<br>在程序运行过程中，强制杀死线程，线程还没有来得及保存上下文就结束了。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>        System.out.println(<span class="hljs-string">&quot;线程开始执行&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        thread.stop();<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210410174213.png" alt="image-20210410174205954"></p><h3 id="2-中断线程"><a href="#2-中断线程" class="headerlink" title="2.中断线程"></a>2.中断线程</h3><p>​<code>中断在计算机中是一个非常重要的机制。在多线程中，他是一种更好去中止线程的机制。我们可以通过与stop()做对比。stop()是强制杀死线程，不管当前的线程在做什么。而中断机制不会杀死线程，而是给线程发送一个通知，告诉线程，&quot;你可以终止了&quot;。之后，线程在接收到这个通知后如何处理，由线程自己确定。</code></p><h4 id="isInterrupted-方法"><a href="#isInterrupted-方法" class="headerlink" title="isInterrupted()方法"></a>isInterrupted()方法</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">isInterrupted()是一个实例方法，它通过检查中断标志位，判断当前线程是否被中断。<br>当前线程被中断时为true<br></code></pre></td></tr></table></figure><h4 id="interrupted-方法"><a href="#interrupted-方法" class="headerlink" title="interrupted()方法"></a>interrupted()方法</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">interrupted()方法是一个静态方法，返回boolean类型，也是用来判断当前的线程是否被中断，但是同时会清楚当前线程的中断标志位<br></code></pre></td></tr></table></figure><h4 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a>interrupt()方法</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">interrupt()方法是一个实例方法，他通知线程中断，设置中断标志位为true，中断标志位表示当前线程已经被中断了，它不会中断一个正在运行的进程。<br><br>如果线程被Object.wait(),Thread.join(),Thread.sleep()方法阻塞，然后调用interrupt()方法。此时线程在检查中断标识是如果是true，那么该线程将抛出一个InterruptedException中断异常，并且在抛出异常后立即将线程的中断标识位清除，即重新设置为false。该线程必须事先预备好处理这个异常，从而提早地终结被阻塞状态。<br><br><br>抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 注意</span><br>synchronized在获得锁的过程中是不能被中断的。<br>调用interrupt()方法只是在目标线程中设置了中断标志位true。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//终止非阻塞线程，通过中断标志位判断中断线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                System.out.println(Thread.currentThread().isInterrupted());<br>                <span class="hljs-comment">//判断中断标志位</span><br>                <span class="hljs-keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>                    i++;<br>                &#125;<br>                System.out.println(Thread.currentThread().isInterrupted());<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>        <span class="hljs-comment">//在主线程睡0.01秒之后，将thread线程中断</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210410195811.png" alt="image-20210410195811396"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//终止一个阻塞线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        sleep(<span class="hljs-number">5000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                        <span class="hljs-comment">//设置中断标志位true</span><br>                        <span class="hljs-built_in">this</span>.interrupt();<br>                    &#125;<br><br>                    <span class="hljs-comment">//当中断标志位为true时，退出循环</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.isInterrupted())&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>        &#125;;<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread.interrupt();<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210410201531.png" alt="image-20210410201531715"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 注意</span><br>在main方法中调用thread.interrupt()方法，此时thread线程内部的中断标志位会置为true<br>然后会触发run方法内部的InterruptedException异常，所以运行结果中由异常输出，当触发InterruptedException异常时，线程内部的中断标志又会被清除(false)。<br>因此我们在catch()中调用了this.interrupt()；将中断标志位设置为true。然后退出循环。<br></code></pre></td></tr></table></figure><h3 id="3-等待-wait-、通知-notify"><a href="#3-等待-wait-、通知-notify" class="headerlink" title="3.等待(wait)、通知(notify)"></a>3.等待(wait)、通知(notify)</h3><p>​<code>等待wait()和通知notify()这两个方法并不是Thread类中的方法，而是每个Object类中定义的。每一个对象都有这两个方法。</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">public final native void wait(long timeout) throws InterruptedException;<br>public final native void notify();<br>public final native void notifyAll();<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 这两个方法只用于多线程之间的协作。</span><br><br>当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。<br>比如在线程1中调用object.wait()方法，那么线程1就会停止继续执行，转为等待状态。而当线程2调用object.notify()方法后，线程就会继续执行。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitNotifyDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程1开始&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (object)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1得到锁&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;线程1等待并释放锁&quot;</span>);<br>                        object.wait();<br>                        System.out.println(<span class="hljs-string">&quot;线程1等待结束并重新获得锁&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;线程1结束&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (object)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程2开始 得到锁&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;线程2睡眠5秒&quot;</span>);<br>                        Thread.sleep(<span class="hljs-number">5000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;线程2通知线程1结束等待&quot;</span>);<br>                    object.notify();<br>                    System.out.println(<span class="hljs-string">&quot;线程2释放锁&quot;</span>);<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;线程2结束&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        thread1.start();<br>        <span class="hljs-comment">//让主线程睡1秒，保证线程1先获得锁</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210411093935.png" alt="image-20210411093935130"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 对wait和notify的分析</span><br>这两个方法并不能随便使用。它必须包含在对应的synchronize语句中。<br>无论是wait方法还是notify方法都需要获取目标独享的一个监视器。这样做的目的是使得其他等待在object对象的线程不至于因为线程1的休眠而全部无法执行。<br><span class="hljs-section"># wait和sleep方法的对比</span><br>wait方法可以被唤醒，wait会释放目标对象的锁<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">时间</th><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">得到锁</td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center">执行wait</td><td align="center"></td></tr><tr><td align="center">T3</td><td align="center">释放锁</td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center"></td><td align="center">得到锁</td></tr><tr><td align="center">T5</td><td align="center"></td><td align="center">执行notify</td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center">释放锁</td></tr><tr><td align="center">T7</td><td align="center">得到锁</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center">…</td><td align="center"></td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 理解wait和notify</span><br>当一个线程调用了object.wait()方法时，那么他就会进出object对象的等待队列。在这个队列中，可能会有多个线程，因为系统可能运行多个线程等待某一个对象。当object.notify()方法被调用时，他就会从这个队列中随机选择一个线程，并将其唤醒。这个选择是不公平的，随机的，并不会先等待线程就会优先被选择。<br><br><span class="hljs-section"># notifyAll()方法</span><br>这个方法与notify()方法类似。他会唤醒在这个等待队列中所有等待的线程。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  没有拿到锁&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (waitNotifyDemo2.class)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  拿到锁&quot;</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  等待并释放锁&quot;</span>);<br>                waitNotifyDemo2.class.wait();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  重新得到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  释放锁&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">waitNotifyDemo2</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ThreadDemo1</span> <span class="hljs-variable">threadDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo1</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo);<br><br>        t1.start();<br>        <span class="hljs-comment">//先让t1得到锁</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">//t2,t3,t4线程进入等待队列</span><br>        t2.start();<br>        t3.start();<br>        t4.start();<br><br>        <span class="hljs-comment">//让t2,t3,t4有时间进入等待队列</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (waitNotifyDemo2.class)&#123;<br>                    <span class="hljs-comment">//随机唤醒一个</span><br>                    waitNotifyDemo2.class.notify();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">synchronized</span> (waitNotifyDemo2.class)&#123;<br>            waitNotifyDemo2.class.notifyAll();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210411101610.png" alt="image-20210411101610676"></p><h3 id="4-挂起-suspend-和继续执行-resume"><a href="#4-挂起-suspend-和继续执行-resume" class="headerlink" title="4.挂起(suspend)和继续执行(resume)"></a>4.挂起(suspend)和继续执行(resume)</h3><p>​<code>在Thread类中，由两个方法，suspend()线程挂起、resume()线程继续执行。JDK中标注了这两个方法已经过时了，不推荐使用。因为suspend()方法去挂起线程不会释放任何锁资源,直到线程执行了resume方法。而且，对于被挂起的线程，从线程上的状态上看，依旧还是Runnable状态。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//resume()如果在suspend()方法前就被执行了，那么被挂起的线程可能很难有机会被继续执行了。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  挂起&quot;</span>);<br>        Thread.currentThread().suspend();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  继续执行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">suspendResumeDemo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">threadDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadDemo);<br><br>        thread1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread2.start();<br><br>        thread1.resume();<br>        thread2.resume();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210411104919.png" alt="image-20210411104919171"></p><h3 id="5-等待线程结束-join-和谦让-yeild"><a href="#5-等待线程结束-join-和谦让-yeild" class="headerlink" title="5.等待线程结束(join)和谦让(yeild)"></a>5.等待线程结束(join)和谦让(yeild)</h3><p>​<code>有时候，一个线程可能需要等另一个线程结束以后才执行。JDK中提供了join()这个方法来操作。yeild()方法是一个静态方法，一旦执行，它会让出CPU，之后，他会继续和其他线程竞争CPU</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">joinYeildDemo</span> &#123;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">th</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;th线程睡眠5秒&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br><br>        th.start();<br>        th.join();<br><br>        System.out.println(<span class="hljs-string">&quot;等待th线程完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># join源码</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-comment">//将当前线程设置为等待态</span><br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2020/10/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/10/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="1、为什么使用线程池"><a href="#1、为什么使用线程池" class="headerlink" title="1、为什么使用线程池"></a>1、为什么使用线程池</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行的任务的程序都可以使用线程池。</p><p>线程池的使a用能够带来三个好处：</p><ul><li><code>降低资源消耗</code>。通过重复利用已创建的线程降低线程创建和销毁的消耗。</li><li><code>提高响应速度</code>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><code>提高线程的可管理性</code>。线程是稀缺资源，如果无限制的创建，会消耗资源，降低系统的稳定性。</li></ul><h3 id="2、线程池的实现原理"><a href="#2、线程池的实现原理" class="headerlink" title="2、线程池的实现原理"></a>2、线程池的实现原理</h3><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528225001.png" alt="image-20210528224954205"></p><p>当线程池提交一个任务之后，线程池是如何处理这个任务的？</p><p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li><p>线程池判断<code>核心线程池</code>里的线程是否都在执行任务。如果不是，则创建一个新的工作 </p><p>线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。 </p></li><li><p>线程池判断<code>阻塞队列</code>是否已经满。如果阻塞队列没有满，则将新提交的任务存储在这 </p><p>个阻塞队列里。如果阻塞队列满了，则进入下个流程。</p></li><li><p>线程池判断<code>线程池</code>的线程是否都处于工作状态。如果没有，则创建一个新的工作线程 </p><p>来执行任务。如果已经满了，则交给<code>饱和策略</code>来处理这个任务。</p></li></ol><p>对于：ThreadPoolExecutor线程池的原理图如下：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210528230026.png" alt="image-20210528230026717"></p><p>ThreadPoolExecutor执行execute方法分下面4种情况。 </p><ol><li><p>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁）。 </p></li><li><p>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 </p></li><li><p>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 </p></li><li><p>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 </p><p>RejectedExecutionHandler.rejectedExecution()方法</p></li></ol><h3 id="4、自定义线程池"><a href="#4、自定义线程池" class="headerlink" title="4、自定义线程池"></a>4、自定义线程池</h3><h4 id="1、拒绝策略"><a href="#1、拒绝策略" class="headerlink" title="1、拒绝策略"></a>1、拒绝策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 拒绝策略</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt; &#123;<br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、自定义阻塞队列"><a href="#2、自定义阻塞队列" class="headerlink" title="2、自定义阻塞队列"></a>2、自定义阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//阻塞队列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">//1. 任务队列  双向队列   放置未执行的任务</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//2. 锁  多个线程都要想得到任务，但只能有一个线程得到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">//3. 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//4. 消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//5. 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br><br>    <span class="hljs-comment">//阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//如果一直没有任务，消费者阻塞</span><br>            <span class="hljs-keyword">while</span>(queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果有元素</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">removeFirst</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            <span class="hljs-comment">//唤醒</span><br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> removeFirst;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T element)</span>&#123;<br>        lock.lock();<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//此时阻塞队列中已满，生产者阻塞</span><br>            <span class="hljs-keyword">while</span>(queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//如果没有满  放在尾部</span><br>            queue.addLast(element);<br>            <span class="hljs-comment">//唤醒</span><br>            emptyWaitSet.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//带超时的阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>&#123;<br>        lock.lock();<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//将timeout统一转换为纳秒</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br><br>            <span class="hljs-keyword">while</span>(queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos&lt;=<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//带超时的阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task,<span class="hljs-type">long</span> timeout,TimeUnit timeUnit)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br><br>            <span class="hljs-keyword">while</span>(queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br><br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//判断阻塞队列是否满了</span><br>            <span class="hljs-keyword">if</span>(queue.size() == capacity)&#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>,task);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、自定义简单的线程池"><a href="#3、自定义简单的线程池" class="headerlink" title="3、自定义简单的线程池"></a>3、自定义简单的线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程池</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span>&#123;<br>    <span class="hljs-comment">//阻塞队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">//线程集合  正在工作的线程</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br>    <span class="hljs-comment">//设置超时时间，超过时间，线程关闭</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br><br>    <span class="hljs-comment">//时间单位</span><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span>&#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//执行任务</span><br>            <span class="hljs-comment">//1 当task不为空 执行任务</span><br>            <span class="hljs-comment">//2 当task执行完毕 在接着阻塞队列任务并执行</span><br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout,timeUnit)) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    task.run();<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    e.printStackTrace();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">synchronized</span> (workers)&#123;<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize,<span class="hljs-type">long</span> timeout,TimeUnit timeUnit,<span class="hljs-type">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span>&#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br><br>    <span class="hljs-comment">//执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span>&#123;<br>        <span class="hljs-comment">//当任务数没有超过coreSize时，直接交给worker对象执行</span><br>        <span class="hljs-comment">//如果任务数超过了coreSize时，加入阻塞队列</span><br>        <span class="hljs-keyword">synchronized</span> (workers)&#123;<br>            <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize)&#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                taskQueue.tryPut(rejectPolicy,task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、ThreadPoolExecutor"><a href="#3、ThreadPoolExecutor" class="headerlink" title="3、ThreadPoolExecutor"></a>3、ThreadPoolExecutor</h3><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529091606.png" alt="image-20210529091559420"></p><h4 id="1、线程池状态"><a href="#1、线程池状态" class="headerlink" title="1、线程池状态"></a>1、线程池状态</h4><p>ThreadPoolExecutor 使用int的高三位来表示线程池的状态，低29位表示线程数量。</p><table><thead><tr><th align="center">状态名</th><th align="center">高3位</th><th align="center">接受新任务</th><th align="center">处理阻塞队列任务</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">111</td><td align="center">Y</td><td align="center">Y</td><td align="center"></td></tr><tr><td align="center">SHUTDOWN</td><td align="center">000</td><td align="center">N</td><td align="center">Y</td><td align="center">不会接受新任务，但会处理阻塞队列剩余任务</td></tr><tr><td align="center">STOP</td><td align="center">001</td><td align="center">N</td><td align="center">N</td><td align="center">会中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td align="center">TIDYING</td><td align="center">010</td><td align="center">-</td><td align="center">-</td><td align="center">任务全执行完毕，活动线程为0即将进入终结</td></tr><tr><td align="center">TERMINATED</td><td align="center">011</td><td align="center">-</td><td align="center">-</td><td align="center">终结状态</td></tr></tbody></table><p>将这些信息存储在一个原子变量ctl中，目的是将线程池状态与线程个数合二为一，这样就可以用一次CAS操作进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//c 为旧值 ，ctlof返回结果为新值</span><br>ctl <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(c,ctlof(targetState,workerCountof(c)</span>));<br><br><span class="hljs-comment">//rs 为高三位代表线程池状态，wc为低29位代表线程个数。ctl是合并它们</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlof</span><span class="hljs-params">(<span class="hljs-type">int</span> rs,<span class="hljs-type">int</span> wc)</span>&#123;<br><span class="hljs-keyword">return</span> rs | wc;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">         <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">         <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">         TimeUnit unit,</span><br><span class="hljs-params">         BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">         ThreadFactory threadFactory,</span><br><span class="hljs-params">         RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li><p>corePoolSize 核心线程数目 (最多保留的线程数)</p></li><li><p>maximumPoolSize 最大线程数目</p></li><li><p>keepAliveTime 生存时间 - 针对救急线程</p></li><li><p>unit 时间单位 - 针对救急线程</p></li><li><p>workQueue 阻塞队列</p></li><li><p>threadFactory 线程工厂 - 可以为线程创建时起个好名字</p></li><li><p>handler 拒绝策略</p></li></ul><p>线程池中的最大线程数 &#x3D;  核心线程数 + 救急线程数</p><h4 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h4><ol><li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p></li><li><p>当线程数达到 <code>corePoolSize</code> 并没有线程空闲，这时再加入任务，新加的任务会被加入<code>workQueue</code> 队列排队，直到有空闲的线程。</p></li><li><p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 <code>maximumPoolSize - corePoolSize</code> 数目的线程来救急。</p></li><li><p>如果线程到达 <code>maximumPoolSize</code> 仍然有新任务这时会执行拒绝策略。</p></li><li><p>当高峰过去后，超过<code>corePoolSize</code> 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由<code>keepAliveTime</code> 和 <code>unit</code> 来控制。</p></li></ol><h4 id="4、拒绝策略"><a href="#4、拒绝策略" class="headerlink" title="4、拒绝策略"></a>4、拒绝策略</h4><p>拒绝策略 JDK提供了 4 种实现，其它著名框架也提供了实现</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210529095914.png" alt="image-20210529095907639"></p><ul><li><p><code>AbortPolicy</code> 让调用者抛出 <code>RejectedExecutionException</code> 异常，这是默认策略</p></li><li><p><code>CallerRunsPolicy </code>让调用者运行任务</p></li><li><p><code>DiscardPolicy</code> 放弃本次任务</p></li><li><p><code>DiscardOldestPolicy</code> 放弃队列中最早的任务，本任务取而代之</p></li><li><p><code>Dubbo</code> 的实现，在抛出 <code>RejectedExecutionException </code>异常之前会记录日志，并 dump 线程栈信息，方便定位问题</p></li><li><p><code>Netty</code> 的实现，是创建一个新线程来执行任务</p></li><li><p><code>ActiveMQ</code> 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</p></li><li><p><code>PinPoint</code> 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul><h3 id="4、几种常见的线程池"><a href="#4、几种常见的线程池" class="headerlink" title="4、几种常见的线程池"></a>4、几种常见的线程池</h3><h4 id="1、newFixedThreadPool-固定数目线程的线程池"><a href="#1、newFixedThreadPool-固定数目线程的线程池" class="headerlink" title="1、newFixedThreadPool(固定数目线程的线程池)"></a>1、newFixedThreadPool(固定数目线程的线程池)</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(int nThreads) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(nThreads, nThreads,<br>     <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>     <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li><p><strong>核心线程数 等于 最大线程数</strong>    &#x3D;&#x3D;&#x3D;&gt;    没有救急线程被创建，因此也无需超时时间。</p></li><li><p><strong>阻塞队列是无界的</strong>，可以放问题数量的任务</p></li></ul><p><strong>工作机制：</strong></p><ol><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到<code>LinkedBlockingQueue</code>阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ol><blockquote><p>适用于任务量已知，相对耗时的任务</p></blockquote><h4 id="2、newCachedThreadPool-可缓存线程的线程池"><a href="#2、newCachedThreadPool-可缓存线程的线程池" class="headerlink" title="2、newCachedThreadPool(可缓存线程的线程池)"></a>2、newCachedThreadPool(可缓存线程的线程池)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>         <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li><p><code>核心线程数是0</code>，最大线程数是Integer.MAX_VALUE，救急线程的空闲生存时间是60s。</p></li><li><p><code>全部都是救急线程（60s 后可以回收）。救急线程可以无限创建</code></p></li><li><p>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的</p></li></ul><p><strong>工作机制：</strong></p><ol><li>提交任务</li><li>因为没有核心线程，所以任务直接加到<code>SynchronousQueue</code>队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ol><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。</p><p>极端情况下会创建过多的线程，耗尽 CPU 和内存资源。</p><p>由于空闲 60 秒的线程会被终止，长时间保持空闲的 <code>CachedThreadPool</code> 不会占用任何资源。</p><blockquote><p>适合任务数比较密集，但每个任务执行时间较短的情况</p></blockquote><h4 id="3、newSingleThreadExecutor-单线程的线程池"><a href="#3、newSingleThreadExecutor-单线程的线程池" class="headerlink" title="3、newSingleThreadExecutor(单线程的线程池)"></a>3、newSingleThreadExecutor(单线程的线程池)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>         (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>         <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>线程数固定为 1。</li><li>阻塞队列是LinkedBlockingQueue</li><li>keepAliveTime为0</li></ul><p><strong>工作流程：</strong></p><ol><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，将任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一条线程夜以继日地干活。</li></ol><p><code>newSingleThreadExecutor</code>和我们自己创建一个线程的区别：</p><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何<code>补救措施</code>，而线程池还会新建一个线程，保证池的正常工作。</p><p><code>newSingleThreadExecutor</code>和<code>Executors.newFixedThreadPool(1)</code>的区别</p><ul><li><p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改</p></li><li><p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改</p></li></ul><blockquote><p>适合希望多个任务排队执行。</p></blockquote><h4 id="4、newScheduledThreadPool-定时及周期执行的线程池"><a href="#4、newScheduledThreadPool-定时及周期执行的线程池" class="headerlink" title="4、newScheduledThreadPool(定时及周期执行的线程池)"></a>4、newScheduledThreadPool(定时及周期执行的线程池)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>最大线程数为Integer.MAX_VALUE</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><p><strong>工作机制：</strong></p><ol><li><p>提交任务</p></li><li><p>线程池中的线程从 DelayQueue 中取任务</p></li><li><p>线程从 DelayQueue 中获取 time 大于等于当前时间的task</p></li><li><p>执行完后修改这个 task 的 time 为下次被执行的时间</p></li><li><p>这个 task 放回DelayQueue队列中</p></li></ol><blockquote><p>适用于周期性执行任务的场景，需要限制线程数量的场景</p></blockquote><h3 id="5、线程池的工作队列"><a href="#5、线程池的工作队列" class="headerlink" title="5、线程池的工作队列"></a>5、线程池的工作队列</h3><h4 id="1、ArrayBlockingQueue"><a href="#1、ArrayBlockingQueue" class="headerlink" title="1、ArrayBlockingQueue"></a>1、ArrayBlockingQueue</h4><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><h4 id="2、LinkedBlockingQueue"><a href="#2、LinkedBlockingQueue" class="headerlink" title="2、LinkedBlockingQueue"></a>2、LinkedBlockingQueue</h4><p>LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务。</p><p>容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；<code>newFixedThreadPool线程池使用了这个队列</code></p><h4 id="3、DelayQueue"><a href="#3、DelayQueue" class="headerlink" title="3、DelayQueue"></a>3、DelayQueue</h4><p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。<code>newScheduledThreadPool线程池使用了这个队列。</code></p><h4 id="4、PriorityBlockingQueue"><a href="#4、PriorityBlockingQueue" class="headerlink" title="4、PriorityBlockingQueue"></a>4、PriorityBlockingQueue</h4><p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列</p><h4 id="5、SynchronousQueue"><a href="#5、SynchronousQueue" class="headerlink" title="5、SynchronousQueue"></a>5、SynchronousQueue</h4><p>SynchronousQueue（同步队列）<code>一个不存储元素的阻塞队列</code>，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，<code>newCachedThreadPool线程池使用了这个队列。</code></p><h3 id="6、提交任务"><a href="#6、提交任务" class="headerlink" title="6、提交任务"></a>6、提交任务</h3><h4 id="1、execute"><a href="#1、execute" class="headerlink" title="1、execute"></a>1、execute</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">execute</span></span>(<span class="hljs-variable">Runnable</span> <span class="hljs-variable">command</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>pool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2、submit"><a href="#2、submit" class="headerlink" title="2、submit"></a>2、submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>Future&lt;String&gt; future = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="3、invokeAll"><a href="#3、invokeAll" class="headerlink" title="3、invokeAll"></a>3、invokeAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>List&lt;Future&lt;String&gt;&gt; invokeAll = pool.invokeAll(Arrays.asList(<br>        () -&gt; &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;<br>        &#125;<br>));<br><br>invokeAll.forEach(f -&gt; &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>          System.out.println(f.get());<br>     &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>     &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>          e.printStackTrace();<br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="4、invokeAny"><a href="#4、invokeAny" class="headerlink" title="4、invokeAny"></a>4、invokeAny</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">any</span> <span class="hljs-operator">=</span> pool.invokeAny(Arrays.asList(<br>        () -&gt; &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;<br>        &#125;<br>));<br><br>System.out.println(any);   <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="7、关闭线程池"><a href="#7、关闭线程池" class="headerlink" title="7、关闭线程池"></a>7、关闭线程池</h3><h4 id="1、shutdown"><a href="#1、shutdown" class="headerlink" title="1、shutdown"></a>1、shutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 但已提交任务会执行完</span><br><span class="hljs-comment">- 此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>     mainLock.lock();<br>     <span class="hljs-keyword">try</span> &#123;<br>         checkShutdownAccess();<br>         <span class="hljs-comment">// 修改线程池状态</span><br>         advanceRunState(SHUTDOWN);<br>         <span class="hljs-comment">// 仅会打断空闲线程</span><br>         interruptIdleWorkers();<br>         onShutdown(); <span class="hljs-comment">// 扩展点 ScheduledThreadPoolExecutor</span><br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         mainLock.unlock();<br>     &#125;<br>     <span class="hljs-comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span><br>     tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、shutdownNow"><a href="#2、shutdownNow" class="headerlink" title="2、shutdownNow"></a>2、shutdownNow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 STOP</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 会将队列中的任务返回</span><br><span class="hljs-comment">- 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>     List&lt;Runnable&gt; tasks;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>     mainLock.lock();<br>     <span class="hljs-keyword">try</span> &#123;<br>         checkShutdownAccess();<br>         <span class="hljs-comment">// 修改线程池状态</span><br>         advanceRunState(STOP);<br>         <span class="hljs-comment">// 打断所有线程</span><br>         interruptWorkers();<br>         <span class="hljs-comment">// 获取队列中剩余任务</span><br>         tasks = drainQueue();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         mainLock.unlock();<br> &#125;<br>    <br>     <span class="hljs-comment">// 尝试终结</span><br>     tryTerminate();<br>  <span class="hljs-keyword">return</span> tasks; <br> &#125;<br></code></pre></td></tr></table></figure><h4 id="3、其它方法"><a href="#3、其它方法" class="headerlink" title="3、其它方法"></a>3、其它方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，</span><br><span class="hljs-comment">// 因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全问题</title>
    <link href="/2020/10/05/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2020/10/05/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h4 id="1-什么是线程安全"><a href="#1-什么是线程安全" class="headerlink" title="1. 什么是线程安全"></a>1. 什么是线程安全</h4><p><code>要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享(Shared)的、可变(Mutable)的状态的访问。</code></p><p>共享：变量可以由多个线程同时访问。可变：变量的值在其生命周期内可以发生变化。</p><p>一个对象是否是线程安全的，取决于他是否被多个线程同时访问。这指的是程序中访问对象的方式，而不是对想要实现的功能。要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。</p><h4 id="2-竟态条件"><a href="#2-竟态条件" class="headerlink" title="2. 竟态条件"></a>2. 竟态条件</h4><p><code>当某就算的正确性取决于多个线程的交替执行时序时，那么就会发生竟态条件。</code>最常见的竟态条件类型就是“先检查后执行”。即通过一个可能失效的观测结果来决定下一步的动作。</p><span id="more"></span><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 举一个实际生活中的例子</span><br>你和你的朋友约好在某一饭店见面，当你到达那里是，发现这个地方有两个相同的饭店，并且你和你的朋友并不知道是哪一家。<br>于是，你选择先去A饭店去看朋友是否在A饭店，但你并没有发现他。那么你可以等待或者去看看你的朋友是否在饭店B。<br>问题是：当你在街上走时，你的朋友可能已经离开饭店B，从后门进入饭店A了。<br><br>因为要想和朋友会面。必须取决于时间的发生时序(比如，你朋友要在饭店B待多久)。当你走出前门时，你就不知道饭店中是否有你朋友，意思就是，当你离开饭店A之后，你对饭店A的观察结果就无效了。<br></code></pre></td></tr></table></figure><p>上面实际例子就是一种竟态条件，大多数竟态条件的本质是<code>基于一种可能失效的观察结果来做出判断或者某个计算。</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 单例模式中延迟性加载的竟态条件</span><br>单例模式：确保单个对象被创建<br>延迟性加载：将对象的初始化操作推迟到实际被使用时才进行。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyInitRace</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(obj == <span class="hljs-literal">null</span>)<br>            obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在getInstance()方法中存在一个竟态条件，它可能会破坏这个类的正确性。</p><p>假如有两个线程A，B同时需要某一个对象，同时调用getInstance()方法。A看到obj &#x3D;&#x3D; null，因而创建一个新的Object对象，B同样判断obj是否为空。</p><p>但是此时的obj是否为空呢？要去取决于不可预测的时序 ，比如线程的调度方式，以及线程A需要多久来初始化obj。如果当线程B检查时，obj为null，那么就会两次创建对象，就会创建两个不同的对象，这不符合单例模式的规则。</p><p><code>竟态条件并不总是产生错误，还需要某种不恰当的执行时序。</code>如果你去饭店B的时候，你的朋友正好在等你，这样就不会不会出现错误。</p><h4 id="3-复合操作"><a href="#3-复合操作" class="headerlink" title="3.复合操作"></a>3.复合操作</h4><p><code>要避免竟态条件，就必须在某个线程修改该变量的值时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态中。</code></p><p>假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指：<code>对于访问同一个状态的所有操作(包括操作本身)来说，这个操作是一个原子方式执行的操作。</code></p><p>比如，我们说过，最常见的竟态条件就是，先检查后执行，要想保证线程安全性。就必须保证，这个操作必须是原子的。我们将这种操作统称为<code>复合操作</code>。</p><p>比如<code>i++</code>这个操作中，包括三步：读取–修改–写入。这个操作是原子的，称为复合操作。</p><h4 id="4-线程安全问题"><a href="#4-线程安全问题" class="headerlink" title="4. 线程安全问题"></a>4. 线程安全问题</h4><ol><li><h6 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h6></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-comment">//共享变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-comment">//count++非原子性操作</span><br>            count++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;======&quot;</span> + count);<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeDemo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br>        <span class="hljs-comment">//定义100个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable,<span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210417201807.png" alt="image-20210417201800787"></p><ol start="2"><li><h6 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h6></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">//定义一个共享变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">bool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//先让当前线程睡一会，while先进入循环</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        bool = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeDemo2</span> &#123;<br>    <span class="hljs-comment">//第一个线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadDemo2</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo2</span>();<br>        thread.start();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//如果bool为true</span><br>            <span class="hljs-keyword">if</span> (thread.bool == <span class="hljs-literal">true</span>)&#123;<br>                System.out.println(thread.bool + <span class="hljs-string">&quot;变为true&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210417202138.png" alt="image-20210417202138602"></p><ol start="3"><li>重排序问题</li></ol><blockquote><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 为什么指令重排序可以提高性能?</span><br>每个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此产生了流水线技术。它的原理是指令1还没有执行完，就可以开始执行指令2。并不需要等到指令1执行结束后在执行指令2，这样就大大提高了效率<br></code></pre></td></tr></table></figure><p>流水线技术大大提高了程序的效率。但有时会降低效率。比如：流水线技术恢复中断的代价比较大。所以我们会想尽办法不让流水线中断。<strong>指令重排就是减少中断的一种技术。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiang.ThreadSafe.unsafe;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重排序可能会带来的问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeDemo3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            i++;<br>            x = <span class="hljs-number">0</span>;<br>            y = <span class="hljs-number">0</span>;<br>            a = <span class="hljs-number">0</span>;<br>            b = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        latch.countDown();<br>                        latch.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    a = <span class="hljs-number">1</span>;<br>                    x = b;<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        latch.countDown();<br>                        latch.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    b = <span class="hljs-number">1</span>;<br>                    y = a;<br>                &#125;<br>            &#125;);<br>            two.start();<br>            one.start();<br>            latch.countDown();<br>            one.join();<br>            two.join();<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次（&quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span> &amp;&amp; y == <span class="hljs-number">1</span>) &#123;<br>                System.out.println(result);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(result);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210419092753.png" alt="image-20210419092556342"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射和注解</title>
    <link href="/2020/09/20/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"/>
    <url>/2020/09/20/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射机制概述"><a href="#反射机制概述" class="headerlink" title="反射机制概述"></a>反射机制概述</h2><p>反射被视为动态语言的关键，反射机制允许程序在执行期间借助Reflection API 取得任何类的内部信息，并能直接操作任何对象的内部属性和方法。</p><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个对象），这个对象就包含了完整类的结构信息。</p><p>Java反射机制研究及应用：</p><blockquote><p>在运行是判断任何一个对象所属的类</p><p>在运行时构造任意一个类的对象</p><p>在运行时判断任意一个类所具有的成员变量和方法</p><p>在运行时获取泛型信息</p><p>在运行时调用任意一个对象的成员变量和方法</p><p>在运行时处理注解（）</p><p>生成动态代理</p></blockquote><p>反射相关的主要API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.Class:代表一个方法<br>java.lang.reflect.Method:代表类的方法<br>java.lang.reflect.Field:代表类的成员变量<br>java.lang.reflect.Constructor:代表类的构造器<br></code></pre></td></tr></table></figure><h2 id="如何理解Class类"><a href="#如何理解Class类" class="headerlink" title="如何理解Class类"></a>如何理解Class类</h2><p>在Object类中定义了以下的方法，此方法将被所有子类继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Class <span class="hljs-title function_">getClass</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><blockquote><p>以上的方法返回值的类型是一个Class类型，此类是Java反射的源头。</p><p>对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。</p><p>一个 Class 对象包含了特定某个结构(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。 </p><p>Class本身也是一个类</p><p>Class 对象只能由系统建立对象 </p><p>一个加载的类在 JVM 中只会有一个Class实例</p><p>一个Class对象对应的是一个加载到JVM中的一个.class文件</p><p>每个类的实例都会记得自己是由哪个 Class 实例所生成</p><p>通过Class可以完整地得到一个类中的所有被加载的结构</p><p>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</p></blockquote><h2 id="获取Class类的实例"><a href="#获取Class类的实例" class="headerlink" title="获取Class类的实例"></a>获取Class类的实例</h2><p>那些类型可以有Class对象？</p><p>class、interface、数组、enum、annotation、primitive type（基本数据类型）、void</p><p>获取实例的四种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先定义一个类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>方法一：</p><p>已知具体的类，通过类的class属性获取，该方法最安全可靠，程序性能最高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一：</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">class1</span> <span class="hljs-operator">=</span> Person.class;<br>System.out.println(class1);<br></code></pre></td></tr></table></figure><p>方法二：</p><p>已知某个类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法二：</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">class2</span> <span class="hljs-operator">=</span> person.getClass();<br>System.out.println(class2);<br></code></pre></td></tr></table></figure><p>方法三：</p><p>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能会抛出异常ClassNotFoundException（该类为找到）。</p><p>方法三更能体现动态性，因为在运行才会判断类是否存在等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法三：</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">class3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.jiang.Person&quot;</span>);<br>System.out.println(class3);<br></code></pre></td></tr></table></figure><p>方法四：</p><p>通过getClassLoader()得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法四：</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader();<br><span class="hljs-type">Class</span> <span class="hljs-variable">class4</span> <span class="hljs-operator">=</span> classLoader.loadClass(<span class="hljs-string">&quot;com.jiang.Person&quot;</span>);<br>System.out.println(class4);<br></code></pre></td></tr></table></figure><h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><p>创建完Class对象后，我们可以创建类的对象。</p><p>我们调用Class对象的newInstance()，newInstance()方法在jdk1.9之后过时了。</p><p>1、 类必须有一个无参数的构造器</p><p>2、 类的构造器的访问权限需要足够</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">class3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.jiang.Person&quot;</span>);<br><span class="hljs-comment">//得到运行时类对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) class3.newInstance();<br>System.out.println(person);<br></code></pre></td></tr></table></figure><p>我们也可以使用带参数的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用指定参数结构的构造器，生成Constructor的实例</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> class1.getConstructor(String.class, String.class);<br><span class="hljs-comment">//通过生成Constructor的实例创建对应类的对象，并初始化类属性</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> (Person)con.newInstance(<span class="hljs-string">&quot;jiang&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>System.out.println(person2);<br></code></pre></td></tr></table></figure><p>Dame:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String classPath)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">class1</span> <span class="hljs-operator">=</span> Class.forName(classPath);<br>        <span class="hljs-keyword">return</span> class1.newInstance();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (num)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                classPath = <span class="hljs-string">&quot;com.jzw.Person&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                classPath = <span class="hljs-string">&quot;java.util.Date&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> getInstance(classPath);<br>        System.out.println(instance);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><p>先定义一个复杂的类。</p><p>创建一个注解：<br><strong>只能RetentionPolicy.RUNTIME,才能通过反射得到注解。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(value = &#123;ElementType.METHOD, ElementType.TYPE, ElementType.LOCAL_VARIABLE,ElementType.CONSTRUCTOR&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AnnotationDemo &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decsription</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span>  <span class="hljs-string">&quot;no decsription&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建一个父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AnnotationDemo(id = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> gender;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> weight;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;生物呼吸&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;生物吃东西&quot;</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AnnotationDemo(id = 0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Creature</span>&lt;String&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;String&gt;,MyInterface &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@AnnotationDemo(id = 2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-meta">@AnnotationDemo(id = 2)</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getNation</span><span class="hljs-params">(String nation)</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我的国籍是:&quot;</span> + nation);<br>        <span class="hljs-keyword">return</span> nation;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.eat();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一个人&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AnnotationDemo(id = 0)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, weight=&quot;</span> + weight +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是一个静态方法&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="获取属性结构"><a href="#获取属性结构" class="headerlink" title="获取属性结构"></a>获取属性结构</h4><p>获取当前运行时类及其父类中声明为public的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拿到运行时类</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">class1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.jiang.Person&quot;</span>);<br><br><span class="hljs-comment">//getFields()方法拿到当前运行时类以及父类权限为public的属性</span><br>Field[] fields = class1.getFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>     System.out.println(field);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到当前运行时类的所有权限的属性，但不包括父类的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//getDeclaredFields()方法得到当前运行时类的所有权限的属性，但不包括父类的属性</span><br>Field[] declaredFields = class1.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field declaredField : declaredFields) &#123;<br>       System.out.println(declaredField);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取属性的具体结构</p><p>权限修饰符    getModifiers()</p><p>数据类型       getType()</p><p>变量名           getName()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] declaredFields1 = class1.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field declaredField : declaredFields1) &#123;<br>      <span class="hljs-comment">//获取权限修饰符</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> declaredField.getModifiers();<br>      System.out.print(Modifier.toString(modifiers) + <span class="hljs-string">&quot;\t&quot;</span>);<br>      <span class="hljs-comment">//获取数据类型</span><br>      <span class="hljs-type">Class</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> declaredField.getType();<br>      System.out.print(type.getName() + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>      <span class="hljs-comment">//获取变量名</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> declaredField.getName();<br>      System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取方法结构"><a href="#获取方法结构" class="headerlink" title="获取方法结构"></a>获取方法结构</h4><p>获取当前运行时类及其父类中声明为public的方法getMethods();</p><p>得到当前运行时类的所有权限的方法，但不包括父类的方法getDeclaredMethods();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Method[] methods = class1.getMethods();<br><span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>     System.out.println(method);<br>&#125;<br><br>System.out.println();<br><br>Method[] declaredMethods = class1.getDeclaredMethods();<br><span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>    System.out.println(declaredMethod);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取方法的具体结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">Method[] declaredMethods = class1.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>            <span class="hljs-comment">//1、获取注解</span><br>            Annotation[] annotations = declaredMethod.getAnnotations();<br>            <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>                System.out.println(annotation);<br>            &#125;<br><br>            <span class="hljs-comment">//2、获取权限修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> declaredMethod.getModifiers();<br>            System.out.print(Modifier.toString(modifiers) + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>            <span class="hljs-comment">//3、返回值类型</span><br>            System.out.print(declaredMethod.getReturnType().getName() + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>            <span class="hljs-comment">//4、方法名</span><br>            System.out.print(declaredMethod.getName());<br><br>            <span class="hljs-comment">//5、形参列表</span><br>            System.out.print(<span class="hljs-string">&quot;(&quot;</span>);<br>            Class[] parameterTypes = declaredMethod.getParameterTypes();<br>            <span class="hljs-keyword">if</span>(parameterTypes.length != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameterTypes.length; i++) &#123;<br>                    <span class="hljs-keyword">if</span>(i == parameterTypes.length - <span class="hljs-number">1</span>)<br>                    &#123;<br>                        System.out.print(parameterTypes[i].getName() + <span class="hljs-string">&quot;_args&quot;</span> + i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.print(parameterTypes[i].getName() + <span class="hljs-string">&quot;_args&quot;</span> + i + <span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>            &#125;<br>            System.out.print(<span class="hljs-string">&quot;)&quot;</span>);<br><br><br>            <span class="hljs-comment">// 6、抛出异常</span><br>            Class[] exceptionTypes = declaredMethod.getExceptionTypes();<br><br>            <span class="hljs-keyword">if</span>(exceptionTypes.length != <span class="hljs-number">0</span>)<br>            &#123;<br>                System.out.print(<span class="hljs-string">&quot;throws&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; exceptionTypes.length; i++) &#123;<br>                    <span class="hljs-keyword">if</span>(i == exceptionTypes.length - <span class="hljs-number">1</span>)<br>                    &#123;<br>                        System.out.print(exceptionTypes[i].getName());<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.print(exceptionTypes[i].getName() + <span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>            &#125;<br><br><br>            System.out.println();<br>            System.out.println();<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="获取当前运行时类的构造器"><a href="#获取当前运行时类的构造器" class="headerlink" title="获取当前运行时类的构造器"></a>获取当前运行时类的构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取当前权限修饰符为public的构造器</span><br>Constructor[] constructor = class1.getConstructors();<br><span class="hljs-keyword">for</span> (Constructor constructor1 : constructor) &#123;<br>    System.out.println(constructor1);<br>&#125;<br><span class="hljs-comment">//获取全部权限的构造器</span><br>Constructor[] declaredConstructor = class1.getDeclaredConstructors();<br><span class="hljs-keyword">for</span> (Constructor constructor1 : declaredConstructor) &#123;<br>    System.out.println(constructor1);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取父类的泛型"><a href="#获取父类的泛型" class="headerlink" title="获取父类的泛型"></a>获取父类的泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取带泛型的父类</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> class1.getGenericSuperclass();<br>System.out.println(genericSuperclass);<br><br><br><span class="hljs-comment">//获取带泛型的父类的泛型</span><br><span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">genericSuperclass1</span> <span class="hljs-operator">=</span> (ParameterizedType) genericSuperclass;<br>Type[] actualTypeArguments = genericSuperclass1.getActualTypeArguments();<br><span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>    System.out.println(actualTypeArgument);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取运行时类的注解、所在的包、接口"><a href="#获取运行时类的注解、所在的包、接口" class="headerlink" title="获取运行时类的注解、所在的包、接口"></a>获取运行时类的注解、所在的包、接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取运行时类的接口</span><br>Class[] interfaces = class1.getInterfaces();<br><br><span class="hljs-keyword">for</span> (Class anInterface : interfaces) &#123;<br>    System.out.println(anInterface);<br>&#125;<br><br>System.out.println();<br><span class="hljs-comment">//获取运行时类父类的接口</span><br>Class[] interfaces1 = class1.getSuperclass().getInterfaces();<br><span class="hljs-keyword">for</span> (Class aClass : interfaces1) &#123;<br>    System.out.println(aClass);<br>&#125;<br><br><br>System.out.println();<br><span class="hljs-comment">//获取运行时类所在是包</span><br><span class="hljs-type">Package</span> <span class="hljs-variable">aPackage</span> <span class="hljs-operator">=</span> class1.getPackage();<br>System.out.println(aPackage);<br><br><br>System.out.println();<br><span class="hljs-comment">//获取类声明的注解</span><br>Annotation[] annotations = class1.getAnnotations();<br><span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>    System.out.println(annotation);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调用运行时类指定的结构"><a href="#调用运行时类指定的结构" class="headerlink" title="调用运行时类指定的结构"></a>调用运行时类指定的结构</h2><h4 id="调用属性"><a href="#调用属性" class="headerlink" title="调用属性"></a>调用属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拿到运行时类</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">class1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.jiang.Person&quot;</span>);<br><span class="hljs-comment">//创建运行时类对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person)class1.newInstance();<br><br><span class="hljs-comment">//1、获取指定属性 要求权限为public  一般不用</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> class1.getField(<span class="hljs-string">&quot;id&quot;</span>);<br>id.set(person,<span class="hljs-number">4</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">ids</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)id.get(person);<br>System.out.println(ids);<br><br><span class="hljs-comment">//2、任何权限都可以拿到</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> class1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">//保证当前属性是可访问的</span><br>name.setAccessible(<span class="hljs-literal">true</span>);<br>name.set(person,<span class="hljs-string">&quot;jiang&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> (String)name.get(person);<br>System.out.println(name1);<br></code></pre></td></tr></table></figure><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、获取指定方法</span><br><span class="hljs-comment">//参数1:方法名，参数2：形参列表</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">getNation</span> <span class="hljs-operator">=</span> class1.getDeclaredMethod(<span class="hljs-string">&quot;getNation&quot;</span>, String.class);<br><br>getNation.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//invoke的返回值就是当前方法的返回值</span><br>getNation.invoke(person, <span class="hljs-string">&quot;CHINA&quot;</span>);<br><br><span class="hljs-comment">//2、任何调用静态方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> class1.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>);<br>show.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//因为是一个静态方法，可以传递一个空对象</span><br>show.invoke(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h4 id="调用构造器"><a href="#调用构造器" class="headerlink" title="调用构造器"></a>调用构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> class1.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br><br>declaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-type">Person</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Person)declaredConstructor.newInstance(<span class="hljs-string">&quot;jiang&quot;</span>, <span class="hljs-number">1</span>);<br><br>System.out.println(o);<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>描述一下JVM加载class文件的原理机制?</strong><br>答：JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader<br>是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h2><blockquote><p><strong>注解（也称元数据）</strong>为我们在代码中<strong>添加信息提供了一种形式化的方法</strong>，使我们可以在之后的某个时刻非常方便地这些数据。</p></blockquote><p>这些定义太过抽象，简单来说就是注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。注解就是<strong>代码的标签，注解起到标识做用。</strong></p><h2 id="三种标准注解"><a href="#三种标准注解" class="headerlink" title="三种标准注解"></a>三种标准注解</h2><p><strong>@override</strong></p><p><strong>表示当前的方法定义将覆盖超类中的方法</strong>。如果不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span>  <span class="hljs-comment">//只能用在方法上</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="hljs-comment">//在编译器处理完之后，注解失效</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>@Deprecated</strong></p><p><strong>所修饰的元素已经过时</strong>，但为了项目的维护，不可以删除。如果程序员使用了注解为他的元素，那么编译器会发出警告信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the version in which the annotated element became deprecated.</span><br><span class="hljs-comment">     * The version string is in the same format and namespace as the value of</span><br><span class="hljs-comment">     * the &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@since</span>&#125; javadoc tag. The default value is the empty</span><br><span class="hljs-comment">     * string.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the version string</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 9</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">since</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Indicates whether the annotated element is subject to removal in a</span><br><span class="hljs-comment">     * future version. The default value is &#123;<span class="hljs-doctag">@code</span> false&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> whether the element is subject to removal</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 9</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">forRemoval</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@SuppressWarnings</strong></p><p><strong>关闭不当的编译器警告信息，</strong>当代码出现一些警告时，比如变量为使用，泛型等。使用注解可以将警告关闭。注解在使用需要添加参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The set of warnings that are to be suppressed by the compiler in the</span><br><span class="hljs-comment">     * annotated element.  Duplicate names are permitted.  The second and</span><br><span class="hljs-comment">     * successive occurrences of a name are ignored.  The presence of</span><br><span class="hljs-comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span><br><span class="hljs-comment">     * ignore any warning names they do not recognize.  They are, however,</span><br><span class="hljs-comment">     * free to emit a warning if an annotation contains an unrecognized</span><br><span class="hljs-comment">     * warning name.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; The string &#123;<span class="hljs-doctag">@code</span> &quot;unchecked&quot;&#125; is used to suppress</span><br><span class="hljs-comment">     * unchecked warnings. Compiler vendors should document the</span><br><span class="hljs-comment">     * additional warning names they support in conjunction with this</span><br><span class="hljs-comment">     * annotation type. They are encouraged to cooperate to ensure</span><br><span class="hljs-comment">     * that the same names work across multiple compilers.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the set of warnings to be suppressed</span><br><span class="hljs-comment">     */</span><br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p><strong>元注解专门负责新注解的创建。</strong>注解其他的注解。</p><p><strong>@Target</strong></p><p><strong>表示注解可以用在什么地方</strong>，可能的ElementType参数包括：</p><p>一个注解有多个参数。</p><table><thead><tr><th align="center">参数</th><th align="center">注解使用具体元素</th></tr></thead><tbody><tr><td align="center">CONSTRUCTOR</td><td align="center">构造器的声明</td></tr><tr><td align="center">FIELD</td><td align="center">域声明（包括enum实例）</td></tr><tr><td align="center">LOCAL_VARIABLE</td><td align="center">局部变量声明</td></tr><tr><td align="center">METHOD</td><td align="center">方法声明</td></tr><tr><td align="center">PACKAGE</td><td align="center">包声明</td></tr><tr><td align="center">PARAMETER</td><td align="center">参数声明</td></tr><tr><td align="center">TYPE</td><td align="center">类、接口（包括注解类型）或enum声明</td></tr><tr><td align="center">ANNOTATION_TYPE</td><td align="center">注解声明</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns an array of the kinds of elements an annotation type</span><br><span class="hljs-comment">     * can be applied to.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an array of the kinds of elements an annotation type</span><br><span class="hljs-comment">     * can be applied to</span><br><span class="hljs-comment">     */</span><br>    ElementType[] value();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>@Retention</strong></p><p>表示需要在什么级别保存该注解信息，一个注解中有唯一的@Retention，默认参数是CLASS 。</p><p>参数有：</p><blockquote><p>SOURCE：  注解将被编译器丢弃</p><p>CLASS ：     注解在class文件中可用，但会被JVM丢弃。</p><p><strong>RUNTIME：</strong> JVM将在运行 期也保留注解，因此<strong>可以通过反射机制读取注解信息。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Retention &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the retention policy.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the retention policy</span><br><span class="hljs-comment">     */</span><br>    RetentionPolicy <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>@Documented</strong></p><p><strong>它的作用是能够将注解中的元素包含到 Javadoc 中去。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Documented &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>@Inherited</strong></p><p>允许子类继承父类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Inherited &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>类，接口，注解是同一级别的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE,ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AnnotationDemo &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decsription</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span>  <span class="hljs-string">&quot;no decsription&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationTest</span> &#123;<br>    <span class="hljs-meta">@AnnotationDemo(id = 47,decsription = &quot;Password must contain at least one numeric&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validatePassword</span><span class="hljs-params">(String password)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (password.matches(<span class="hljs-string">&quot;\\w*\\d\\w*&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-meta">@AnnotationDemo(id = 48)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encryptPassword</span><span class="hljs-params">(String password)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(password).reverse().toString();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务</title>
    <link href="/2020/09/06/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/09/06/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">保证业务操作完整性的一种数据库机制<br></code></pre></td></tr></table></figure><h4 id="事务-ACID"><a href="#事务-ACID" class="headerlink" title="事务(ACID)"></a>事务(ACID)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 事务四大特性(ACID)</span><br><br><span class="hljs-section">## 原子性(Atomicity)</span><br><span class="hljs-code">原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。</span><br><span class="hljs-code">因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</span><br><span class="hljs-code"></span><br><span class="hljs-section">## 一致性(Consistency)</span><br><span class="hljs-code">事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到</span><br><span class="hljs-code"></span><br><span class="hljs-code">## 隔离性(lsolation)</span><br><span class="hljs-code">隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</span><br><span class="hljs-code">同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</span><br><span class="hljs-code"></span><br><span class="hljs-code">## 持久性</span><br><span class="hljs-code">持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><h4 id="如何控制事务"><a href="#如何控制事务" class="headerlink" title="如何控制事务"></a>如何控制事务</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">JDBC:<br><span class="hljs-code">Connection.setAutoCommit(false);    //开启</span><br><span class="hljs-code">Connection.commit();                //提交</span><br><span class="hljs-code">Connection.rollback();//回滚</span><br><span class="hljs-code"></span><br>Mybatis: (sqlSeesion在底层封装了Connection)<br><span class="hljs-code">Mybatis自动开启事务//开启</span><br><span class="hljs-code">sqlSession.commit();//提交</span><br><span class="hljs-code">sqlSession.rollback();//回滚</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 小结</span><br><span class="hljs-code">对于事务，有三个操作，开启、提交、回滚</span><br><span class="hljs-code">控制事务的底层 都是Connection对象完成的</span><br></code></pre></td></tr></table></figure><h4 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">事务属性:描述事务特征的一系列值<br><span class="hljs-bullet">1.</span> 隔离属性<br><span class="hljs-bullet">2.</span> 传播属性<br><span class="hljs-bullet">3.</span> 只读属性<br><span class="hljs-bullet">4.</span> 超时属性<br><span class="hljs-bullet">5.</span> 异常属性<br></code></pre></td></tr></table></figure><h4 id="如何添加事务的属性"><a href="#如何添加事务的属性" class="headerlink" title="如何添加事务的属性"></a>如何添加事务的属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Transactional &#123;<br> <br><span class="hljs-meta">@AliasFor(&quot;transactionManager&quot;)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;   <span class="hljs-comment">//给该事务指定别名</span><br> <br><span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>String <span class="hljs-title function_">transactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//指定事务管理器，不指定时使用配置文件中指定的事务管理器</span><br> <br>Propagation <span class="hljs-title function_">propagation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Propagation.REQUIRED; <span class="hljs-comment">//事务传播属性</span><br> <br>Isolation <span class="hljs-title function_">isolation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Isolation.DEFAULT; <span class="hljs-comment">//事务隔离级别</span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT;<span class="hljs-comment">//事务超时机制</span><br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">readOnly</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//事务是否只读</span><br> <br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] rollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-comment">//事务回滚规则</span><br> <br>String[] rollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-comment">//事务回滚规则</span><br> <br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] noRollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-comment">//事务回滚规则</span><br> <br>String[] noRollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-comment">//事务回滚规则</span><br> <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionDefinition</span> &#123; <span class="hljs-comment">//事务属性设置</span><br> <br><span class="hljs-comment">//传播属性设置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_SUPPORTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_MANDATORY</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRES_NEW</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NOT_SUPPORTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NEVER</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NESTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br> <br><span class="hljs-comment">//隔离级别属性设置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_UNCOMMITTED</span> <span class="hljs-operator">=</span> Connection.TRANSACTION_READ_UNCOMMITTED;<br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_COMMITTED</span> <span class="hljs-operator">=</span> Connection.TRANSACTION_READ_COMMITTED;<br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_REPEATABLE_READ</span> <span class="hljs-operator">=</span> Connection.TRANSACTION_REPEATABLE_READ;<br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_SERIALIZABLE</span> <span class="hljs-operator">=</span> Connection.TRANSACTION_SERIALIZABLE;<br> <br><span class="hljs-comment">//超时机制设置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">TIMEOUT_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">getPropagationBehavior</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getIsolationLevel</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getTimeout</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">//是否只读属性</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span>;<br>String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="隔离属性"><a href="#隔离属性" class="headerlink" title="隔离属性"></a>隔离属性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 隔离属性</span><br><span class="hljs-code">他描述了事务解决并发问题的特征</span><br><span class="hljs-code"># 什么是并发</span><br><span class="hljs-code">多个事务(用户)在同一时间，访问操作了相同的数据</span><br><span class="hljs-code"># 如何解决并发</span><br><span class="hljs-code">通过隔离属性解决，隔离属性中设置不同的值，解决并发处理过程中的问题</span><br></code></pre></td></tr></table></figure><h4 id="并发产生的问题"><a href="#并发产生的问题" class="headerlink" title="并发产生的问题"></a>并发产生的问题</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 脏读</span><br><span class="hljs-code">事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到数据时脏数据</span><br><span class="hljs-code">解决方案 @Transational(isolation=Isolation.READ_COMMITED)</span><br><span class="hljs-code"># 不可重复读</span><br><span class="hljs-code">事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后读到的数据结果会不一致。</span><br><span class="hljs-code">解决方案 @Transational(isolation=Isolation.REPEATABLE_READ)</span><br><span class="hljs-code">本质:一把行锁</span><br><span class="hljs-code"># 幻读</span><br><span class="hljs-code">一个事务中，多次对整张表进行查询统计，但是结果不一样，会在本事务中产生数据不一致的问题</span><br><span class="hljs-code">例如：事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这 时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且 提交给数据库。 而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还 有跟没有修改一样，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这 就是发生了幻读。</span><br><span class="hljs-code">解决方案 @Transational(isolation=Isolation.SERIALIZABLE)</span><br><span class="hljs-code">本质:一把表锁</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 小结</span><br><span class="hljs-code">不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</span><br></code></pre></td></tr></table></figure><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><table><thead><tr><th align="center">事务隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交 read - uncommitted</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">不可重复读 read - committed</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">可重复读 repeatable - read</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">串行化 serializable</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 读未提交</span><br><span class="hljs-code">另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 不可重复读</span><br><span class="hljs-code">事务A多次读取同一数据，事务B在事务A多次读取的过程中。对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 可重复读</span><br><span class="hljs-code">在同一事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的，但是会有幻读的现象</span><br><span class="hljs-code"></span><br><span class="hljs-section"># 串行化</span><br><span class="hljs-code">最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样。</span><br></code></pre></td></tr></table></figure><h4 id="MySQL默认的事务隔离级别"><a href="#MySQL默认的事务隔离级别" class="headerlink" title="MySQL默认的事务隔离级别"></a>MySQL默认的事务隔离级别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">MySQL默认的事务隔离级别  -- 可重复读 (repeatable - read)<br></code></pre></td></tr></table></figure><h4 id="传播属性"><a href="#传播属性" class="headerlink" title="传播属性"></a>传播属性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 传播属性</span><br><span class="hljs-code">他描述了事务解决嵌套问题的特征</span><br><span class="hljs-code"># 在开发中出现的场景</span><br><span class="hljs-code">在开发中，我们通常是service调用DAO，并且在业务中绝大部分都满足这种</span><br><span class="hljs-code">但会出现service调用service，这是就有事务的嵌套了</span><br><span class="hljs-code"># 出现的问题</span><br><span class="hljs-code">在AService()中调用了两个BService()和CService()</span><br><span class="hljs-code">如果在执行过程中，BService()正常执行，且已提交。但在CService()执行过程中出现错误，需要回滚，但BService()已经提交，无法回滚</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a0b15ffdbf024a2291c34d374bd44192.png" alt="image-20210308104857566"></p><h4 id="传播属性级别"><a href="#传播属性级别" class="headerlink" title="传播属性级别"></a>传播属性级别</h4><table><thead><tr><th>传播属性的值</th><th>外部不存在事务</th><th>外部存在事务</th></tr></thead><tbody><tr><td>REQUIRED(增删改)</td><td>开启新的事务</td><td>融合到外部事务中</td></tr><tr><td>SUPPORTS(查询)</td><td>不开启新的事务</td><td>融合到外部事物中</td></tr></tbody></table><h4 id="只读属性-readOnly"><a href="#只读属性-readOnly" class="headerlink" title="只读属性(readOnly)"></a>只读属性(readOnly)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 只读属性</span><br><span class="hljs-code">针对只进行查询操作的业务方法，可以加入只读属性，提供运行效率</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 默认值</span><br><span class="hljs-code">false</span><br></code></pre></td></tr></table></figure><h4 id="超时属性-timeout"><a href="#超时属性-timeout" class="headerlink" title="超时属性(timeout)"></a>超时属性(timeout)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 超时属性</span><br><span class="hljs-code">指定了事务等待的最长时间</span><br><span class="hljs-code"># 为什么事务进行等待</span><br><span class="hljs-code">当前事务访问数据是，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待</span><br><span class="hljs-code"># 运用</span><br><span class="hljs-code">@Transactional(timeout = )</span><br><span class="hljs-code"># 默认值</span><br><span class="hljs-code">-1(最终有对应的数据库来指定)</span><br></code></pre></td></tr></table></figure><h4 id="异常属性"><a href="#异常属性" class="headerlink" title="异常属性"></a>异常属性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在Spring事务处理过程中<br>默认 对于RuntimeException及其子类  采用的是回滚的策略<br>默认 对于Exception及其子类  采用的是提交的策略<br><br>rollbackFor = &#123;java.lang.Exception,...&#125;    Exception设置为回滚<br>noRollbackFor = &#123;java.lang.RuntimeException,...&#125;   RuntimeException设置为提交<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的实现和遍历</title>
    <link href="/2020/08/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <url>/2020/08/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树(Tree)形结构是一种重要的非线性结构。树形结构反映了数据元素之间的层次关系和分支关系。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><blockquote><p>​        一个结点的子树个数称为该结点的度(degree)，一棵树中结点度的最大值称为该树的度。度为0的结点称为叶子结点或者终端结点。</p><p>​树中结点的后继结点称为儿子结点，结点的前趋结点称为儿子的父亲结点。</p><p>​结点的层数使从根开始算起的。设根节点的层数为1，其他结点的层数等于父亲结点的层数加1.</p><p>​若把树中每个结点的各子树看成从左到右有次序的(即不可互换的)，则称该树使有序树。</p><p>​树中任一结点都可以有零个或者多个后继结点。但至多有一个前趋结点。树中只有根节点无前趋结点，叶子结点无后继结点。</p></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是由n结点组成的有限集合。此集合或者为空，或者有一个根节点加上两颗左右子树。</p><p>二叉树的性质：</p><p>1、二叉树第i(i&gt;0)层上的结点最多为<br>$$<br>2^{i-1}<br>$$<br>2、高度为k的二叉树最多有的节点数<br>$$<br>2^k-1<br>$$<br>3、对任何二叉树T，n0 ，n1 ，n2 分别表示度数为0、1、2的结点个数。则n0 &#x3D;n2 +1；</p><p>4、具有n个结点的完全二叉树(包括满二叉树)的高度为<br>$$<br>\lfloor  \log n  \rfloor + 1  或者 \lceil \log （n+1） \rceil<br>$$<br>5、满二叉树原理:非空满二叉树的叶结点数等于其分支结点数加1</p><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>通过链表来实现二叉树</p><p><img src="https://img-blog.csdnimg.cn/20200908171622935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义结点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-comment">//结点值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br>    <span class="hljs-comment">//结点名字</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//左节点</span><br>    <span class="hljs-keyword">private</span> Node left;<br>    <span class="hljs-comment">//右节点</span><br>    <span class="hljs-keyword">private</span> Node right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, Node left, Node right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(Node left)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(Node right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&#123;<br>    <span class="hljs-comment">//根结点</span><br>    <span class="hljs-keyword">private</span> Node root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryTree</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryTree</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">//创建一颗树</span><br>    <span class="hljs-type">BinaryTree</span> <span class="hljs-variable">binaryTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>();<br><br>    <span class="hljs-comment">//定义结点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;1&quot;</span>, node3, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0&quot;</span>, node1, node2);<br><br>    binaryTree.setRoot(root);<br><br>    System.out.println(root.getLeft().getLeft().getName());  <span class="hljs-comment">//&quot;3&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建树的结构：<br><img src="https://img-blog.csdnimg.cn/20200908171704214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历分成前序，中序，后序和层次遍历。</p><p>前序，中序，后序遍历需要用到递归的思想；</p><p>而层次遍历，需要借助队列来实现；类似图的广度优先遍历算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义结点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-comment">//结点值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br>    <span class="hljs-comment">//结点名字</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//左节点</span><br>    <span class="hljs-keyword">private</span> Node left;<br>    <span class="hljs-comment">//右节点</span><br>    <span class="hljs-keyword">private</span> Node right;<br><br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderNode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//遍历</span><br>        System.out.println(<span class="hljs-string">&quot;结点名字是&quot;</span> + <span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;,值是&quot;</span> + <span class="hljs-built_in">this</span>.getNo());<br>        <span class="hljs-comment">//查看它的左节点能否遍历</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.preOrderNode();<br>        &#125;<br>        <span class="hljs-comment">//查看它的右节点能否遍历</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.preOrderNode();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">//中序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrderNode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.infixOrderNode();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;结点名字是&quot;</span> + <span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;,值是&quot;</span> + <span class="hljs-built_in">this</span>.getNo());<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.infixOrderNode();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//后序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrderNode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.postOrderNode();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.postOrderNode();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;结点名字是&quot;</span> + <span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;,值是&quot;</span> + <span class="hljs-built_in">this</span>.getNo());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&#123;<br>    <span class="hljs-comment">//根结点</span><br>    <span class="hljs-keyword">private</span> Node root;<br><br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.root.preOrderNode();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.root.infixOrderNode();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.root.postOrderNode();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//层次遍历</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">LevelOrder</span><span class="hljs-params">()</span>&#123;<br>        ArrayQueue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayQueue</span>&lt;Node&gt;(<span class="hljs-number">10</span>);<br><br>        queue.add(root);<br><br>        <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.remove(<span class="hljs-number">0</span>);<br>            System.out.println(<span class="hljs-string">&quot;结点名字是&quot;</span> + node.getName() + <span class="hljs-string">&quot;,值是&quot;</span> + node.getNo());<br><br>            <span class="hljs-keyword">if</span>(node.getLeft() != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(node.getLeft());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(node.getRight());<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">//创建一颗树</span><br>    <span class="hljs-type">BinaryTree</span> <span class="hljs-variable">binaryTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>();<br><br>    <span class="hljs-comment">//定义结点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;1&quot;</span>, node3, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0&quot;</span>, node1, node2);<br><br>    binaryTree.setRoot(root);<br><br>    binaryTree.preOrder();<br>    System.out.println(<span class="hljs-string">&quot;********************************************************&quot;</span>);<br><br>    binaryTree.infixOrder();<br><br>    System.out.println(<span class="hljs-string">&quot;********************************************************&quot;</span>);<br><br>    binaryTree.postOrder();<br><br>    System.out.println(<span class="hljs-string">&quot;********************************************************&quot;</span>);<br><br>    binaryTree.LevelOrder();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">结点名字是<span class="hljs-number">0</span>,值是<span class="hljs-number">0</span><br>结点名字是<span class="hljs-number">1</span>,值是<span class="hljs-number">1</span><br>结点名字是<span class="hljs-number">3</span>,值是<span class="hljs-number">3</span><br>结点名字是<span class="hljs-number">2</span>,值是<span class="hljs-number">2</span><br>********************************************************<br>结点名字是<span class="hljs-number">3</span>,值是<span class="hljs-number">3</span><br>结点名字是<span class="hljs-number">1</span>,值是<span class="hljs-number">1</span><br>结点名字是<span class="hljs-number">0</span>,值是<span class="hljs-number">0</span><br>结点名字是<span class="hljs-number">2</span>,值是<span class="hljs-number">2</span><br>********************************************************<br>结点名字是<span class="hljs-number">3</span>,值是<span class="hljs-number">3</span><br>结点名字是<span class="hljs-number">1</span>,值是<span class="hljs-number">1</span><br>结点名字是<span class="hljs-number">2</span>,值是<span class="hljs-number">2</span><br>结点名字是<span class="hljs-number">0</span>,值是<span class="hljs-number">0</span><br>********************************************************<br>结点名字是<span class="hljs-number">0</span>,值是<span class="hljs-number">0</span><br>结点名字是<span class="hljs-number">1</span>,值是<span class="hljs-number">1</span><br>结点名字是<span class="hljs-number">2</span>,值是<span class="hljs-number">2</span><br>结点名字是<span class="hljs-number">3</span>,值是<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/07/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Git 配置</span><br>git config                                  查看git配置<br><br>git config -- global user.name  &quot;&quot;<br><br>git config -- global user.email &quot;&quot;<br><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 查看当前状态</span><br>git status<br><br>可以根据文件的颜色来判断当前的状态<br><span class="hljs-bullet">-</span> 红色  文件在工作区修改，还未添加到暂存区和本地库<br><span class="hljs-bullet">-</span> 绿色  文件添加到暂存区，但还未添加到本地库<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 初始化版本库</span><br>git init                            会在根目录下新建一个名为.git的文件夹<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 添加文件到暂存区</span><br>git add file.txt                   将file.txt文件上传到暂存区<br><br>git add  <span class="hljs-emphasis">*.txt   将所有的txt文件上传到暂存区</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">git add  .   将所有文件上传到暂存区，包括子目录，但不包括空目录</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 提交到本地仓库</span><br>git commit -m&quot;&quot; file.txt   将file.txt文件上传到本地库<br><br>git commit -m&quot;&quot;                    将暂存区的所有文件上传到本地库<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 查看git的日志</span><br>git log<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 版本回退</span><br>git reset -- hard  版本id<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 仓库撤销修改</span><br><span class="hljs-bullet">-</span> 撤销工作区的修改   git checkout -- file.txt<br><br><span class="hljs-bullet">-</span> 撤销暂存区的修改   <br><span class="hljs-code">要先在暂存区中撤销   git reset head file.txt</span><br><span class="hljs-code">然后在工作区中撤销git checkout -- file.txt</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 分支</span><br>git branch                           查看当前分支<br><br>git branch -a                        查看所有分支<br><br>git branch <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span>              创建新的分支<br><br>git checkout <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span>            切换分支<br><br>git checkout -b  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span>        创建新的分支并切换到当前分支<br><br>git branch -d <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span>           删除分支<br><br>git merge <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">branchName</span>&gt;</span></span>               合并分支<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 远程仓库</span><br>git remote add origin https://github.../XXX.git 将本地的git添加到远程库,仓库名origin<br><br>git remote rm origin                             将origin的远程仓库删除<br><br>git clone <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">URL</span>&gt;</span></span>                        从远程仓库下载<br><br>git push (-u) origin master               将master分支推向origin远程库<br><span class="hljs-code">  (第一次需要加-u)</span><br><span class="hljs-code">  </span><br><span class="hljs-code">git pull  将远程仓库拉到本地库</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码</title>
    <link href="/2020/03/08/HashMap%E6%BA%90%E7%A0%81/"/>
    <url>/2020/03/08/HashMap%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h2><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">HashMap是基于哈希表的Map接口的实现，是以key-value存储形式存在，即主要用来存放键值对，HashMap的实现不是同步的，这意味着它不是线程安全的，它的key、value都可以为null<br>HashMap中的映射下不是有序的。<br><br>java1.8之前的HashMap由数组-链表组成的，数组是HashMap主体，链表则是主要为了解决哈希冲突(两个对象调用 hashcode方法计算的哈希码值一致导致计算的数组索引相同)而存在的。<br>java1.8以后在解决哈希冲突上有了变化，当链表长度大于阈值(或者红黑树的边界值，默认为8)并且当前的数组的长度大于64时。此时此索引位置的所有数据改为使用红黑树存储。<br><br><span class="hljs-bullet">-</span> 补充<br><span class="hljs-code">将链表转换为红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树，而选择进行数组扩容</span><br><span class="hljs-code">这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述，为了提高性能和减少搜索速度，底层在阈值大于8并且数组长度大于64，链表才转换成红黑树。</span><br><span class="hljs-code">具体方法treeifyBin()方法。</span><br><span class="hljs-code"></span><br><br>特点：<br><span class="hljs-bullet">1.</span> 存取无序的<br><span class="hljs-bullet">2.</span> 键和值位置可以是null，但是键的位置只能有一个是null<br><span class="hljs-bullet">3.</span> 键位置是唯一的，底层的数据结构控制键<br><span class="hljs-bullet">4.</span> java 1.8前数据结构是数组+链表   java 1.8后数据结构是数组+链表+红黑树<br><span class="hljs-bullet">5.</span> 阈值 &gt; 8 并且数组长度大于64，才能将链表转换为红黑树，变为红黑树是为了高效查询<br></code></pre></td></tr></table></figure><h4 id="2、-HashMap底层数据结构"><a href="#2、-HashMap底层数据结构" class="headerlink" title="2、 HashMap底层数据结构"></a>2、 HashMap底层数据结构</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">HashMap存储方法<br><br>当创建HashMap集合对象的时候，在jdk1.8前构造方法中创建一个一个长度是16的Entry[] table用来存储键值对数据的。jdk1.8后是在第一次调用put方法是创建的数组Node[] table。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-string">&quot;t1&quot;</span>,<span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;t2&quot;</span>,<span class="hljs-number">2</span>);<br>map.put(<span class="hljs-string">&quot;t3&quot;</span>,<span class="hljs-number">3</span>);<br>map.put(<span class="hljs-string">&quot;t4&quot;</span>,<span class="hljs-number">4</span>);<br><br>System.out.println(map);<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">上述代码中创建了一个HashMap(),根据key(&quot;T1,T2,T3,T4&quot;)调用String类中重写的hashcode()方法计算出值，结合数组长度采用某种算法计算出向Node数组中存储数据的空间索引值。如果计算出索引空间中没有数据，则直接将key对象的value存储到数组中。<br><br><span class="hljs-bullet">-</span> 哈希表底层采用何种算法计算hash值?还有哪些算法可以计算出hash值?<br>底层采用的key的hashcode方法的值结合数组长度进行无符号右移(&gt;&gt;)，按位异或(^)，按位与(&amp;)计算出索引。<br><br>还可以采用：平方取中法、取余数、伪随机数法<br>而最后采用位运算是因为位运算效率高。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">再向map中put数据<br>map.put(&quot;t5&quot;,5);<br>假如计算出的hashCode方法结合数组长度计算出的索引值和&quot;T1&quot;的索引值一致。那么当前索引的数组空间不是null，此时底层会比较&quot;T1&quot;,&quot;T5&quot;的hash值是否一致。<br>如果不一致，则在此空间上划出一个节点来存储&quot;T5&quot;。<br><br>如果一致。此时发生了哈希冲突。那么底层会调用String类中的equals方法比较两个内容知否相等。<br><span class="hljs-bullet">-</span> 相等：则将后添加的数据的value覆盖之前的value<br><span class="hljs-bullet">-</span> 不相等：那么继续向下和其他的数据key进行比较，如果都不相等，则划出一个节点存储数据<br></code></pre></td></tr></table></figure><h4 id="3、HashMap的继承关系"><a href="#3、HashMap的继承关系" class="headerlink" title="3、HashMap的继承关系"></a>3、HashMap的继承关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;k,v&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;k,v&gt;<br>implement Map&lt;k,v&gt;,Cloneable,Serializable&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以看出HashMap继承了AbstractMap类，实现了Map、Cloneable、Serializable<br><br>Cloneable是标记接口，表示可克隆<br>Serializable是用于序列化，表示对象可以被序列化和反序列化<br>AbstractMap提供Map实现接口。以最大限度地减少实现此接口所需的工作。<br></code></pre></td></tr></table></figure><h4 id="4、HashMap集合类的成员变量"><a href="#4、HashMap集合类的成员变量" class="headerlink" title="4、HashMap集合类的成员变量"></a>4、HashMap集合类的成员变量</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1、序列化版本号<br>private static final long serialVersionUID = 362498820763181265L;<br><br>2、集合的初始化容量(必须是二的n此幂)<br><span class="hljs-bullet">-</span> 默认的初始化容量是16<br>static final int DEFAULT<span class="hljs-emphasis">_INITIAL_</span>CAPACITY = 1 &lt;&lt; 4; <br><br><span class="hljs-bullet">-</span> 问题1：为什么必须是2的n次幂?如果不是，会怎样<br>当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置.HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。<br>这个算法就是取模。hash%length,计算机中直接求余效率不如位运算，所以在源码中做了优化，使用hash&amp;(length - 1)，而实际上hash%length等于hash&amp;(length - 1)的前提是length是2的n次幂。<br><br><span class="hljs-bullet">-</span> 问题2：为什么这样可以减少冲突?<br>要想冲突尽量少，就使用取模的方式，取模可以是元素分布的更加均匀。<br>但是在计算机中，取模运算太慢了，所以用模运算提升效率。<br>因此我们原本的运算时hash%length 可以转变为运算hash&amp;(length - 1)<br>但是前提是必须是2的n次幂。<br><br><br><br><span class="hljs-bullet">-</span> 问题3：在初始化构造函数时，可以指定容量，如果指定的容量不是2的n次幂，会怎么处理?<br>在构造函数时详细讲解。<br><br><br>3、集合最大容量 2^30<br>static final int MAXIMUM<span class="hljs-emphasis">_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">4、默认的负载因子，默认值是0.75</span><br><span class="hljs-emphasis">static final float DEFAULT_</span>LOAD<span class="hljs-emphasis">_FACTOR = 0.75f;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">5、当链表的值超过8则会转为红黑树</span><br><span class="hljs-emphasis">static final int TREEIFY_</span>THRESHOLD = 8;<br><br><span class="hljs-bullet">-</span> 为什么节点超过8才转为红黑树<br>在注释中有这样一段话：<br>因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当它们变得太小时，就是转换为链表。在理想的情况下，在随机哈希码下，箱子中节点的频率服从泊松分布。<br><br>6、节点小于6时，转换为链表<br>static final int UNTREEIFY<span class="hljs-emphasis">_THRESHOLD = 6;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">7、当Map里面的数量超过这个值时，表中的桶才能树形化，否则是扩容</span><br><span class="hljs-emphasis">static final int MIN_</span>TREEIFY<span class="hljs-emphasis">_CAPACITY = 64;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">8、table用来初始化</span><br><span class="hljs-emphasis">transient Node<span class="language-xml">&lt;k,v&gt;</span>[] table;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">9、用来存放缓存  存放具体的元素集合</span><br><span class="hljs-emphasis">transient Set<span class="language-xml">&lt;Map.Entry&lt;k,v&gt;</span>&gt; entrySet;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">10、HashMap中存放元素个数 不等于数组的长度</span><br><span class="hljs-emphasis">transient int size;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">11、用来记录HashMap的修改次数 每次扩容和更改map结构的计数器</span><br><span class="hljs-emphasis">transient int modCount;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">12、用来调整大小下一个容量的值    计算方式为(容量 X 负载因子)</span><br><span class="hljs-emphasis">- 临界值  当实际大小(容量 X 负载因子)超过临界值时，会进行扩容</span><br><span class="hljs-emphasis">int threshold;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">13、哈希表的加载因子</span><br><span class="hljs-emphasis">final float loadFactor;</span><br><span class="hljs-emphasis">- 加载因子说明</span><br><span class="hljs-emphasis">loadFactor 是用来衡量HashMap满的程度，表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率。计算HashMap的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。capacity是桶的数量，也就是table的长度length。</span><br><span class="hljs-emphasis">loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。</span><br><span class="hljs-emphasis">当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及rehash、复制数据等操作。非常消耗性能。所以开发中尽量减少扩容的次数。</span><br></code></pre></td></tr></table></figure><h4 id="5、HashMap集合类的成员方法"><a href="#5、HashMap集合类的成员方法" class="headerlink" title="5、HashMap集合类的成员方法"></a>5、HashMap集合类的成员方法</h4><h5 id="5-1、构造方法"><a href="#5-1、构造方法" class="headerlink" title="5.1、构造方法"></a>5.1、构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、 无参构造、默认初始容量(<span class="hljs-number">16</span>)和默认负载因子(<span class="hljs-number">0.75</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>&#125;<br><br><span class="hljs-number">2</span>、 构造一个具有指定的初始化容量和默认负载因子(<span class="hljs-number">0.75</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-number">3</span>、 构造方法<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-comment">//判断初始化容量是否小于0</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>    <span class="hljs-comment">//判断初始化容量是否大于集合的最大容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <br>    <span class="hljs-comment">//判断加载因子是否小于等于0或者是否等于loadFactor</span><br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <br>    <span class="hljs-comment">//Returns a power of two size for the given target capacity.</span><br>    <span class="hljs-comment">//获取比传入参数大的最小的2的N次幂。</span><br>    <span class="hljs-comment">//在讲解成员变量时，我们说过数组容量必须是2的n次幂。就是通过这个方法来约束的。</span><br>    <span class="hljs-comment">//需要注意的是：threshold是边界值，不是直接等于数组长度，还需要乘以加载因子。这是因为在jdk1.8之后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到put方法中了。</span><br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><br><span class="hljs-number">4</span>、 包含Map的构造函数<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;    <br><span class="hljs-comment">//调用的putMapEntries()方法</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">//获取Map的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ((ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY) ?<br>                     (<span class="hljs-type">int</span>)ft : MAXIMUM_CAPACITY);<br>             <span class="hljs-keyword">if</span> (t &gt; threshold)<span class="hljs-comment">//得到数组长度</span><br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">//如果大于边界值，扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">//放进新的集合中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet()) &#123;<br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-2、put-方法"><a href="#5-2、put-方法" class="headerlink" title="5.2、put()方法"></a>5.2、put()方法</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">put方法比较复杂，实现步骤大致如下:<br>1、 先通过hash值计算出key映射到哪个桶。<br>2、 如果桶上没有碰撞冲突，则直接插入。<br>3、 如果出现碰撞冲突，则需要处理冲突<br><span class="hljs-bullet">-</span> 如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据<br><span class="hljs-bullet">-</span> 如果是链表，则需要判断链表长度是否达到临界值。<br>4、 如果桶中存在重复的键，则为该键替换新值value。<br>5、 如果size大于阈值threshold，则进行扩容<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//put()源码</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//hash(key)方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *   如果key等于null，hash值返回0</span><br><span class="hljs-comment">    *   如果key不等于null，</span><br><span class="hljs-comment">    *首先计算出key的hashCode赋值给h，然后与h无符号右移16位后的二进制按异或得到最后的hash值</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><span class="hljs-comment">//为什么要右移16位?</span><br>如果当n很小，假设是<span class="hljs-number">16</span>的话，那么n-<span class="hljs-number">1</span>即为---&gt;<span class="hljs-number">1111</span>，这样的值和hashcode()直接做按位与操作，实际上只使用了哈希值的后<span class="hljs-number">4</span>位。如果当哈希值的高位变化很大，地位变化很小，这样很容易造成哈希冲突。所以这里把高低位都利用起来，从而解决这个问题。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//putVal()方法</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,<span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <br>    Node&lt;K,V&gt;[] tab; <span class="hljs-comment">//在put方法是创建数组</span><br>    Node&lt;K,V&gt; p;  <span class="hljs-comment">//索引指向的节点</span><br>    <span class="hljs-type">int</span> n, i; <span class="hljs-comment">//n 数组长度  i 索引</span><br>    <br>    <span class="hljs-comment">//将tab赋值给table，，并且判断table是否是空</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//如果空，扩容</span><br>        n = (tab = resize()).length;<br>    <br>    <span class="hljs-comment">//计算索引，如果索引所指向是节点是空</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">//新建节点</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//如果有节点</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//判断hash值，key值是否相同，如果相同，节点直接替换</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">//hash不同，判断是否是树节点，如果是，直接调用树节点类中的方法</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果不是树节点  尾插法</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">//判断是否过临界值</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <br>                        <span class="hljs-comment">//转换为红黑树</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//遍历链表的过程中，查找到hash。key相同的</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//是在for循环中查找到hash，key相同的，才执行下面的</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//修改次数+1</span><br>    ++modCount;<br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-3、treeifyBin-方法"><a href="#5-3、treeifyBin-方法" class="headerlink" title="5.3、treeifyBin()方法"></a>5.3、treeifyBin()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//替换指定哈希表的索引处桶中的所有链接节点，除非表太小，否则将修改大小</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*tab  数组</span><br><span class="hljs-comment">*hash 当前这个桶的hash值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">//如果空，或者小于最小的转换红黑树的临界值64，即不需要转换为红黑树</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        <span class="hljs-comment">//扩容</span><br>        resize();<br>    <span class="hljs-comment">//e是的当前索引指向的节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//将链表节点替换为树节点</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p; <br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//连接节点</span><br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//将上面的双向链表转变为红黑树</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-4、resize-方法"><a href="#5-4、resize-方法" class="headerlink" title="5.4、resize()方法"></a>5.4、resize()方法</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">扩容机制:<br>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize()<br>HashMap在进行扩容时，使用的rehash()方式非常巧妙，因为每次扩容都是翻倍，与原来计算的(n-1)&amp;hash的结果相比，只是多一个bit位，所以节点要么就是原来的位置，要么就被分配到&quot;原索引+旧数组长度&quot;这个位置。<br><br>原数组长度：16 n = 16 n-1 --&gt;15<br>0000 0000 0000 0000 0000 0000 0000 1111   15<br><br>第一个hash值<br>hash1 = 1111 1111 1111 1111 0000 1111 0000 0101<br>(n-1)&amp;hash = 5<br><br>第二个hash值<br>hash2 = 1111 1111 1111 1111 0000 1111 0001 0101<br>(n-1)&amp;hash = 5<br><br><br>数组长度扩容：32 n = 32 n-1 --&gt; 31<br>0000 0000 0000 0000 0000 0000 0001 1111   31<br>第一个hash值<br>hash1 = 1111 1111 1111 1111 0000 1111 0000 0101<br>(n-1)&amp;hash = 5<br><br>第二个hash值<br>hash2 = 1111 1111 1111 1111 0000 1111 0001 0101<br>(n-1)&amp;hash = 21 = 16 + 5<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">//原的数组赋值</span><br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">//原数组的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-comment">//原数组的临界值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>   <span class="hljs-comment">//新数组的长度和临界值</span><br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">//新数组长度左移一位后判断是否超过最大的数组容量，并且判断原数组长度是否大于默认长度</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">//边界值左移一位</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <span class="hljs-comment">//创建新的数组，长度是NewCap</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//开始循环，将老数组的数据放进新数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-comment">//得到当前索引指向的节点</span><br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">//只有一个节点，就直接放进新数组中</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">//红黑树</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">//链表</span><br>                <span class="hljs-keyword">else</span> &#123; <br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-5、remove-方法"><a href="#5-5、remove-方法" class="headerlink" title="5.5、remove()方法"></a>5.5、remove()方法</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">删除方法就是首先找到元素的位置，如果是链表就直接删除，如果是红黑树还需要判断是否是小于6转换为链表<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) == <span class="hljs-literal">null</span> ?<br>        <span class="hljs-literal">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//核心算法</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, index;<br>    <span class="hljs-comment">//table长度大于0，并且索引指向的数组元素不为null</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-literal">null</span>, e; K k; V v;<br>        <span class="hljs-comment">//如果需要删除索引指向的节点</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-comment">//如果不是，且有下一个节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//判断是否是树节点</span><br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-comment">//链表节点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//循环，直到找到key为止</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//找到节点，node 如果是null则没有</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-comment">//如果是树节点直接调用方法</span><br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-built_in">this</span>, tab, movable);<br>            <span class="hljs-comment">//判断是否是第一个元素</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                tab[index] = node.next;<br>            <span class="hljs-comment">//如果不是</span><br>            <span class="hljs-keyword">else</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-6、get-方法"><a href="#5-6、get-方法" class="headerlink" title="5.6、get()方法"></a>5.6、get()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//先检查第一个节点</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<span class="hljs-comment">//返回节点</span><br>        <br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//树节点</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">//链表节点</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-7、遍历HashMap"><a href="#5-7、遍历HashMap" class="headerlink" title="5.7、遍历HashMap"></a>5.7、遍历HashMap</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1、 遍历key和values<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-string">&quot;t1&quot;</span>,<span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;t2&quot;</span>,<span class="hljs-number">2</span>);<br>map.put(<span class="hljs-string">&quot;t3&quot;</span>,<span class="hljs-number">3</span>);<br>map.put(<span class="hljs-string">&quot;t4&quot;</span>,<span class="hljs-number">4</span>);<br>map.put(<span class="hljs-string">&quot;t5&quot;</span>,<span class="hljs-number">5</span>);<br><br>System.out.println(map.keySet());<br>System.out.println(map.values());<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2、 使用iterator迭代器迭代<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (HashMap.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, Value = &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>容器</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码</title>
    <link href="/2020/02/08/ArrayList%E6%BA%90%E7%A0%81/"/>
    <url>/2020/02/08/ArrayList%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1、ArrayList的底层-–-数组"><a href="#1、ArrayList的底层-–-数组" class="headerlink" title="1、ArrayList的底层 – 数组"></a>1、ArrayList的底层 – 数组</h3><blockquote><p>数组结构的优缺点：</p><p>数组查询块，根据地址和索引直接获取元素</p><p>数组增删改慢，每次都需要创建新数组。且移动元素位置</p></blockquote><h3 id="2、ArrayList继承关系"><a href="#2、ArrayList继承关系" class="headerlink" title="2、ArrayList继承关系"></a>2、ArrayList继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1、Serializable标记性接口"><a href="#2-1、Serializable标记性接口" class="headerlink" title="2.1、Serializable标记性接口"></a>2.1、Serializable标记性接口</h4><p>1、介绍</p><p>类的序列化有实现java.io.Serializable接口的类启用。不实现此接口的类将不会使任何状态序列化或反序列化。可序列化类的所有子类型都是可序列化的。序列化接口没有方法或字段，仅用于标识可串行化的语义。</p><p>序列化：将对象的数据写入到文件。</p><p>反序列化：将文件中对象的数据读取出来。</p><p>2、java.io.Serializable源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、 Serializable的使用：</p><p>创建一个Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, Integer age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-comment">//调用方法</span><br>    writeObject();<br><br>    readObject();<br>&#125;<br><br><span class="hljs-comment">//定义一个方法，将对象写入文件中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//创建对象操作流---&gt; 序列化，将对象写入文件</span><br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;obj.txt&quot;</span>));<br>    <span class="hljs-comment">//创建需要写入的对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-comment">//调用对象操作流写对象的方法。</span><br>    objectOutputStream.writeObject(student1);<br>    <span class="hljs-comment">//关闭流</span><br>    objectOutputStream.close();<br>&#125;<br><span class="hljs-comment">//定义一个方法，将文件中的数据读取出来</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> IOException,ClassNotFoundException&#123;<br>    <span class="hljs-comment">//创建对象操作流----&gt;反序列化，将数据从文件中读取出来</span><br>    <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">objectInput</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;obj.txt&quot;</span>));<br>    <span class="hljs-comment">//调用方法读取对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Student)objectInput.readObject();<br>    <span class="hljs-comment">//关闭流</span><br>    objectInput.close();<br>    <span class="hljs-comment">//打印对象</span><br>    System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p>在控制台中打印出对象<br><img src="https://img-blog.csdnimg.cn/20200919161607291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="反序列化结果"></p><p>我们可以测试，如果Student对象不继承Serializable接口，结果会怎样。</p><p>明显看出：NotSerializableException，没有序列化接口<br><img src="https://img-blog.csdnimg.cn/20200919161551541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="NotSerializableException异常"></p><h4 id="2-2、Cloneable标记性接口"><a href="#2-2、Cloneable标记性接口" class="headerlink" title="2.2、Cloneable标记性接口"></a>2.2、Cloneable标记性接口</h4><p>1、介绍</p><p>一个类实现Cloneable接口来指示Object.clone()方法。该方法对于该类的实例进行字段的复制时合法的。</p><p>在不实现Cloneable接口的实例上调用对象的克隆方法会导致异常CloneNotSupportedException。</p><p>克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝</p><p>2、Cloneable源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、克隆的前提条件</p><ul><li>被克隆对象所在的类必须实现Cloneable接口</li><li>必须重写clone方法</li></ul><p>4、clone的基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>    ArrayList&lt;String&gt; strings1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    strings1.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    strings1.add(<span class="hljs-string">&quot;2&quot;</span>);<br>    strings1.add(<span class="hljs-string">&quot;3&quot;</span>);<br>    strings1.add(<span class="hljs-string">&quot;4&quot;</span>);<br>    strings1.add(<span class="hljs-string">&quot;5&quot;</span>);<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">strings2</span> <span class="hljs-operator">=</span> strings1.clone();<br><br>    System.out.println(strings1 == strings2);   <span class="hljs-comment">//false</span><br>    System.out.println(strings1);   <span class="hljs-comment">//[1, 2, 3, 4, 5]</span><br>    System.out.println(strings2);   <span class="hljs-comment">//[1, 2, 3, 4, 5]</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>5、clone底层实现</p><p>在ArrayList中克隆函数的重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-built_in">super</span>.clone();<br>        v.elementData = Arrays.copyOf(elementData, size);<br>        v.modCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-comment">// this shouldn&#x27;t happen, since we are Cloneable</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  ArrayList继承AbstractList，但super.clone()；并不是AbstractList类中的，他是Object中的克隆方法，而这个方法的底层时通过C来写的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p>下面这句是克隆的主体：copyof是Arrays中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">v.elementData = Arrays.copyOf(elementData, size);<br></code></pre></td></tr></table></figure><p>我们具体来看copyof()方法：它返回了一个数组，调用重载函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-type">int</span> newLength) &#123;<br>    <span class="hljs-keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());<br>&#125;<br></code></pre></td></tr></table></figure><p>copyof()的重载函数：</p><p>如果(Object)newType &#x3D;&#x3D; (Object)Object[].class  为 true，直接创建一个数组，如果不为真，调用</p><p>Array.newInstance()方法创建具有指定组件类型和尺寸的新数组。</p><p>System.arraycopy()方法：将指定源数组中的数组从指定位置复制到目标数组位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-type">int</span> newLength, Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>[]&gt; newType) &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    T[] copy = ((Object)newType == (Object)Object[].class)<br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newLength]<br>        : (T[]) Array.newInstance(newType.getComponentType(), newLength);<br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                     Math.min(original.length, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><p>6、案例：学生1姓名A，年龄18，将该对象的数据复制到另一个对象学生2中，并且此后学生1，2两个对象的数据不会互相影响。</p><p>方法一：浅拷贝：</p><p>在Student类中重写clone方法</p><p>注意：需要将权限修饰符改为public，将返回对象改为Student</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-keyword">return</span> (Student) <span class="hljs-built_in">super</span>.clone();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-comment">//创建一个对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">18</span>);<br>    <span class="hljs-comment">//克隆</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> student.clone();<br>    <span class="hljs-comment">//比较两个学生的地址是否一项</span><br>    System.out.println(student.hashCode() == student1.hashCode());   <span class="hljs-comment">//false</span><br>    <span class="hljs-comment">//比较两个学生的数据是否一样</span><br>    System.out.println(student);      <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18&#125;</span><br>    System.out.println(student1);     <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18&#125;</span><br>    <span class="hljs-comment">//改变一个学生数据，看是否影响另一个学生</span><br>    student1.setName(<span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(student);      <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18&#125;</span><br>    System.out.println(student1);     <span class="hljs-comment">//Student&#123;name=&#x27;C&#x27;, age=18&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>浅拷贝的局限性：</p><p>基本数据类型可以达到完全复制，而引用数据类型不可以</p><p>原因：在学生对象student被克隆的时候，引用数据类型仅仅是拷贝了一份引用，因此当克隆对象引用数据类型的值发生改变时，被克隆对象student的引用数据类型的值也会跟随改变。</p><p>也就是说，浅拷贝只是克隆了引用数据类型的地址。</p><p>我们新写一个类：Book类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>&#123;<br>    <span class="hljs-keyword">private</span> String bookName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String bookName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookName = bookName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBookName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bookName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookName</span><span class="hljs-params">(String bookName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookName = bookName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;bookName=&#x27;&quot;</span> + bookName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Student类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Book book;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, Integer age, Book book)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.book = book;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, book=&quot;</span> + book +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (Student) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br></code></pre></td></tr></table></figure><p>测试：我们发现修改Book的名称，两个学生的Book数据都会改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">chineseBook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;Chinese&quot;</span>);<br>    <span class="hljs-comment">//创建一个对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">18</span>,chineseBook);<br>    <span class="hljs-comment">//克隆</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> student.clone();<br>    <span class="hljs-comment">//比较两个学生的地址是否一项</span><br>    System.out.println(student.hashCode() == student1.hashCode());   <span class="hljs-comment">//false</span><br>    <span class="hljs-comment">//比较两个学生的数据是否一样</span><br>    System.out.println(student);      <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese&#x27;&#125;&#125;</span><br>    System.out.println(student1);     <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese&#x27;&#125;&#125;</span><br>    <span class="hljs-comment">//改变一个学生数据，看是否影响另一个学生</span><br>    chineseBook.setBookName(<span class="hljs-string">&quot;Chinese1&quot;</span>);<br>    System.out.println(student);      <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese1&#x27;&#125;&#125;</span><br>    System.out.println(student1);     <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese1&#x27;&#125;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：深拷贝：重写clone()方法</p><p>在Book中继承Cloneable接口：在Book类中重写clone方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>在Student类中重写Clone方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br><span class="hljs-comment">//        return (Student) super.clone();</span><br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> (Student) <span class="hljs-built_in">super</span>.clone();<br><br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Book)<span class="hljs-built_in">this</span>.book.clone();<br><br>        stu.setBook(book);<br><br>        <span class="hljs-keyword">return</span> stu;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>测试：同样一段代码：student的Book数据改变，但student1没有改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">chineseBook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;Chinese&quot;</span>);<br>    <span class="hljs-comment">//创建一个对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">18</span>,chineseBook);<br>    <span class="hljs-comment">//克隆</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> student.clone();<br>    <span class="hljs-comment">//比较两个学生的地址是否一项</span><br>    System.out.println(student.hashCode() == student1.hashCode());   <span class="hljs-comment">//false</span><br>    <span class="hljs-comment">//比较两个学生的数据是否一样</span><br>    System.out.println(student);      <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese&#x27;&#125;&#125;</span><br>    System.out.println(student1);     <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese&#x27;&#125;&#125;</span><br>    <span class="hljs-comment">//改变一个学生数据，看是否影响另一个学生</span><br>    chineseBook.setBookName(<span class="hljs-string">&quot;Chinese1&quot;</span>);<br>    System.out.println(student);      <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese1&#x27;&#125;&#125;</span><br>    System.out.println(student1);     <br>    <span class="hljs-comment">//Student&#123;name=&#x27;A&#x27;, age=18, book=Book&#123;bookName=&#x27;Chinese&#x27;&#125;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3、RandomAccess标记接口"><a href="#2-3、RandomAccess标记接口" class="headerlink" title="2.3、RandomAccess标记接口"></a>2.3、RandomAccess标记接口</h4><p>标记接口有List实现，以表明它们支持快速（通常为恒定时间）随机访问。</p><p>此接口的主要目的时允许通用算法更改其行为，以便应用于随机访问列表或顺序访问列表时提供良好的性能。</p><h4 id="2-4、AbstractList类"><a href="#2-4、AbstractList类" class="headerlink" title="2.4、AbstractList类"></a>2.4、AbstractList类</h4><p>该类提供的骨干实现的List接口以最小化来实现该接口由一个“随机访问”数据存储备份所需的工作。</p><h3 id="3、ArrayList源码"><a href="#3、ArrayList源码" class="headerlink" title="3、ArrayList源码"></a>3、ArrayList源码</h3><h4 id="3-1、构造函数"><a href="#3-1、构造函数" class="headerlink" title="3.1、构造函数"></a>3.1、构造函数</h4><p>1、空参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//elementData    集合真正存储数据的容器</span><br><span class="hljs-comment">//DEFAULTCAPACITY_EMPTY_ELEMENTDATA;   默认空容量的数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、构造具有指定初始容量的空列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-comment">//如果大于0，创建指定长度的数组</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果等于0，不需要创建新数组，ArrayList提供了一个空数组</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//如果小于0，异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">//将参数中的集合转变为数组，并赋值给数组a</span><br>    Object[] a = c.toArray();<br>    <span class="hljs-comment">//判断，</span><br>    <span class="hljs-keyword">if</span> ((size = a.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//判断类型</span><br>        <span class="hljs-keyword">if</span> (c.getClass() == ArrayList.class) &#123;<br>            <span class="hljs-comment">//赋值给ArrayList中的数组</span><br>            elementData = a;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则复制指定的数组，并传入ArrayList中的数组中</span><br>            elementData = Arrays.copyOf(a, size, Object[].class);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.替代为一个空数组</span><br>        elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2、add方法"><a href="#3-2、add方法" class="headerlink" title="3.2、add方法"></a>3.2、add方法</h4><p>1、将指定的元素追加到此列表的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">5</span>);<br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//数组是否需要扩容，</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ensureCapacityInternal()方法</span><br><span class="hljs-comment">//elementData是当前ArrayList中元素</span><br><span class="hljs-comment">//minCapacity是当前ArrayList中最少的空间</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用calculateCapacity()方法</span><br><span class="hljs-comment">//得到当前的最小的空间。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;  <span class="hljs-comment">//记录着集合的修改次数</span><br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-comment">//如果需要的最小空间比当前空间大，需要扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//minCapacity是当前需要的最小空间</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-comment">//得到原来的arrayList的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">//一个新的长度，是原数组长度的1.5倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//如果新数组的长度比需要的最小长度还要小，则直接将最小长度赋值给新数组的长度</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    <br>    <span class="hljs-comment">//将数组复制到arrayList中的数组</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在回到add()方法的源码中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//arrayList中数组的长度为10</span><br>    <span class="hljs-comment">//Size是数组中元素的个数</span><br>    <span class="hljs-comment">//size++：元素个数加1</span><br>    <span class="hljs-comment">//将数据存储到小标为size的位置</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在此列表的指定位置插入指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-comment">//在位置1插入D   1是指数组的下标</span><br>str.add(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;D&quot;</span>);<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">//检查是否越界</span><br>    rangeCheckForAdd(index);<br><span class="hljs-comment">//判断是否需要扩容，上文以详细介绍</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//没有元素都向后移动一位</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    <span class="hljs-comment">//将下标为index的位置赋值为element</span><br>    elementData[index] = element;<br>    <span class="hljs-comment">//数组元素个数加1</span><br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>关于System.arraycopy()方法，我们无法读到源码，但我们可以写一些例子来了解这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>System.arraycopy(ints,<span class="hljs-number">1</span>,ints,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>    System.out.print(anInt + <span class="hljs-string">&quot;\t&quot;</span>);  <span class="hljs-comment">//122300</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3、按指定集合的Iterator返回的顺序将指定集合中的元素追加到此列表的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>ArrayList&lt;String&gt; str1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str1.add(<span class="hljs-string">&quot;D&quot;</span>);<br>str1.add(<span class="hljs-string">&quot;E&quot;</span>);<br>str1.add(<span class="hljs-string">&quot;F&quot;</span>);<br><br>str.addAll(str1);<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">//将需要添加的集合转变成数组</span><br>    Object[] a = c.toArray();<br>    <span class="hljs-comment">//得到该数组的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>    <span class="hljs-comment">//将a中的元素从0开始赋值给elementData中，且elementData是从size开始。</span><br>    <span class="hljs-comment">//共赋值numNew次</span><br>    System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>    size += numNew;<br>    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、将指定集合中的元素插入此列表中，从指定的位置开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>ArrayList&lt;String&gt; str1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str1.add(<span class="hljs-string">&quot;D&quot;</span>);<br>str1.add(<span class="hljs-string">&quot;E&quot;</span>);<br>str1.add(<span class="hljs-string">&quot;F&quot;</span>);<br><br>str.addAll(<span class="hljs-number">1</span>,str1);<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">//检查是否越界</span><br>    rangeCheckForAdd(index);<br><span class="hljs-comment">//转变为数组</span><br>    Object[] a = c.toArray();<br>    <span class="hljs-comment">//该数组的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><span class="hljs-comment">//需要移动的次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;<br>    <span class="hljs-comment">//将arrayList中的数据，从第index个开始，向后移动numNew个位置</span><br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index, elementData, index + numNew,<br>                         numMoved);<br><span class="hljs-comment">//将需要添加的元素赋给arrayList中的数组</span><br>    System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>    size += numNew;<br>    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3、set方法"><a href="#3-3、set方法" class="headerlink" title="3.3、set方法"></a>3.3、set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;D&quot;</span>);<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">//检查是否越界</span><br>    rangeCheck(index);<br><span class="hljs-comment">//得到下标为index的元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <br>   <span class="hljs-comment">//下标为index处赋新值</span><br>    elementData[index] = element;<br>    <span class="hljs-comment">//返回原来的元素</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4、get方法"><a href="#3-4、get方法" class="headerlink" title="3.4、get方法"></a>3.4、get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    rangeCheck(index);<br><br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5、toString方法"><a href="#3-5、toString方法" class="headerlink" title="3.5、toString方法"></a>3.5、toString方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str.toString();<br></code></pre></td></tr></table></figure><p>toString()方法是AbstractCollection类中的方法，它是AbstractList是父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取迭代器</span><br>    Iterator&lt;E&gt; it = iterator();<br>    <span class="hljs-comment">//如果迭代器为空，直接返回[]</span><br>    <span class="hljs-keyword">if</span> (! it.hasNext())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br><br>    <span class="hljs-comment">//创建StringBuilder</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-comment">//先添加一个[</span><br>    sb.append(<span class="hljs-string">&#x27;[&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> it.next();<br>        sb.append(e == <span class="hljs-built_in">this</span> ? <span class="hljs-string">&quot;(this Collection)&quot;</span> : e);<br>        <span class="hljs-comment">//没有元素了，就不再添加‘，’,直接返回</span><br>        <span class="hljs-keyword">if</span> (! it.hasNext())<br>            <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&#x27;]&#x27;</span>).toString();<br>        sb.append(<span class="hljs-string">&#x27;,&#x27;</span>).append(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-6、迭代器"><a href="#3-6、迭代器" class="headerlink" title="3.6、迭代器"></a>3.6、迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>Iterator&lt;String&gt; it = str.iterator();<br><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    System.out.println(it.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//返回一个Itr()对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//arrayList中的内部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//光标，默认为0</span><br>    <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-comment">//最后一次移动的光标的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-comment">//将集合实际修改的次数赋值给预期修改的次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    Itr() &#123;&#125;<br><span class="hljs-comment">//判断当前光标与arrayList中元素个数</span><br>    <span class="hljs-comment">//如果相等，返回false，如果不等返回true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        <span class="hljs-comment">//光标向下移动。</span><br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br></code></pre></td></tr></table></figure><p>在迭代器中checkForComodification();方法有什么用呢？</p><p>下面举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>Iterator&lt;String&gt; it = str.iterator();<br><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>    <span class="hljs-comment">//当等于A是，删除这个元素</span><br>    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;A&quot;</span>))&#123;<br>        str.remove(<span class="hljs-string">&quot;A&quot;</span>);<br>    &#125;<br>&#125;<br><br>System.out.println(str);<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200919161459628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="ConcurrentModificationException"></p><p>我们在api文档中查看这个异常：</p><p><strong>当不允许这样的修改时，可以通过检测到对象的并发修改的方法来抛出此异常。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在进入迭代器之前，expectedModCount就被赋值为modCount，</span><br><span class="hljs-comment">//我们直到，modCount是指修改的次数，调用remove方法，modCount就会改变</span><br><span class="hljs-comment">//判断，如果两个不等，返回ConcurrentModificationException</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//remove方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">//如果删除元素为空</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//调用fastMove方法</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//否则，遍历整个arrayList，找到o</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                <span class="hljs-comment">//调用fastMove方法</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">//修改次数加1</span><br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//上文已经介绍，前移一位</span><br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    <span class="hljs-comment">//arrayList中元素个数减1</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是：值得注意的是，如果我们删除的是倒数第二个元素：不会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>Iterator&lt;String&gt; it = str.iterator();<br><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;B&quot;</span>))&#123;<br>            str.remove(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>&#125;<br><br>System.out.println(str);   <span class="hljs-comment">//[A, C]</span><br></code></pre></td></tr></table></figure><p>这是因为在删除完后，arrayList中的长度变为了：2，在进行下一次迭代时，需要判断size和光标的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此时光标为2，size也为2，返回false，因此不会循环了</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> cursor != size;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果删除元素？</p><p>迭代器为我们提供了一个方法：remove()：</p><p>从底层集合删除此迭代器返回的最后一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//最后一次迭代的下标</span><br>    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>    <span class="hljs-comment">//上文已介绍</span><br>    checkForComodification();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//删除上一个迭代的元素</span><br>        ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>        cursor = lastRet;<br>        lastRet = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">////////*********将实际修改的次数赋给预期修改次数</span><br>        <span class="hljs-comment">//我们发现，迭代器中的删除元素的方法实际上还是arrayList中的方法</span><br>        <span class="hljs-comment">//但是这一步保证了程序不会出现异常</span><br>        expectedModCount = modCount;<br>    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-7、clear方法"><a href="#3-7、clear方法" class="headerlink" title="3.7、clear方法"></a>3.7、clear方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str.clear();<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//修改次数加1</span><br>    modCount++;<br><br>    <span class="hljs-comment">// clear to let GC do its work</span><br>    <span class="hljs-comment">//将所有元素置为null</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>        elementData[i] = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//将size置为0</span><br>    size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-8、contains方法"><a href="#3-8、contains方法" class="headerlink" title="3.8、contains方法"></a>3.8、contains方法</h4><p>如果此列表包含指定元素，则返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str.contains(<span class="hljs-string">&quot;A&quot;</span>);<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用indexof()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//遍历找到o</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-9、isEmpty方法"><a href="#3-9、isEmpty方法" class="headerlink" title="3.9、isEmpty方法"></a>3.9、isEmpty方法</h4><p>如果此列表不包含元素，返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>str.add(<span class="hljs-string">&quot;A&quot;</span>);<br>str.add(<span class="hljs-string">&quot;B&quot;</span>);<br>str.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>str.isEmpty();<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果arrayList中数组长度为空，返回true</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>容器</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet 编程</title>
    <link href="/2020/02/08/Servlet/"/>
    <url>/2020/02/08/Servlet/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 >Servlet 编程基础</h2><p>Servlet 是连接 Web 服务器与服务端 Java 程序的协议，是一种通信规范。这个规范是以一套接口的形式体现的。</p><blockquote><p>Servlet 规范中包含一套接口。而 Servlet 接口仅仅是其中之一。</p></blockquote><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210526101351.png" alt="image-20210526101344544"></p><p>微观地讲，Servlet 是 Servlet 接口实现类的一个实例对象，是运行在服务器上的一段 Java小程序，即 Server Applet，也就是 Servlet 这个单词的来历。<strong>Servlet 的主要功能是根据客户端提交的请求，调用服务器端相关 Java 代码，完成对请求的处理与运算。</strong></p><h4 id="1-1、Servlet生命周期"><a href="#1-1、Servlet生命周期" class="headerlink" title="1.1、Servlet生命周期"></a>1.1、Servlet生命周期</h4><p>Servlt 生命周期是指，Servlet 对象的创建、Servlet 对象的初始化、Servlet 对象服务的执行，及最终 Servlet 对象被销毁的整个过程。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210526101539.png" alt="image-20210526101539889"></p><p>Servlet 的整个生命周期过程的执行，均由 Web 服务器负责管理。即 <strong>Servlet 从创建到服务到销毁的整个过程中方法的调用，都是由 Web 服务器负责调用执行，程序员无法控制其执行流程。</strong></p><p>但程序员可以获取到 Servlet 的这些生命周期时间点，并可以指定让 Servlet 做一些具体业务相关的事情。</p><h5 id="1-1-1、-生命周期方法执行流程"><a href="#1-1-1、-生命周期方法执行流程" class="headerlink" title="1.1.1、 生命周期方法执行流程"></a>1.1.1、 生命周期方法执行流程</h5><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210526101707.png" alt="image-20210526101707654"></p><p>Servlet 生命周期方法的执行流程：</p><ol><li><p>当请求发送到 Web 容器后，Web 容器会解析请求 URL，并从中分离出 Servlet 对应的URI。 </p></li><li><p>根据分离出的 URI，通过 web.xml 中配置的 URI 与 Servlet 的映射关系，找到要执行的Servlet，即找到用于处理该请求的 Servlet。 </p></li><li><p>若该 Servlet 不存在，则调用该 Servlet 的无参构造器、init()方法，实例化该 Servlet。然后执行 service()方法。</p></li><li><p>若该 Servlet 已经被创建，则直接调用 service()方法。</p></li><li><p>当 Web 容器被关闭，或该应用被关闭，则调用执行 destroy()方法，销毁 Servlet 实例。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloServlet</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;实例化&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化&quot;</span>);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest request,ServletResponse response)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务&quot;</span>);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destory</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;销毁&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-1-2、Servlet特征"><a href="#1-1-2、Servlet特征" class="headerlink" title="1.1.2、Servlet特征"></a>1.1.2、Servlet特征</h5><ol><li><p>Servlet 是单例多线程的。 </p></li><li><p>一个 Servlet 实例只会执行一次无参构造器与 init()方法，并且是在第一次访问时执行。</p></li><li><p>用户每提交一次对当前 Servlet 的请求，就会执行一次 service()方法。</p></li><li><p>一个 Servlet 实例只会执行一次 destroy()方法，在应用停止时执行。</p></li><li><p>由于 Servlet 是单例多线程的，所以为了保证其线程安全性，一般情况下是不为 Servlet类定义可修改的成员变量的。因为每个线程均可修改这个成员变量，会出现线程安全问题。</p></li><li><p>默认情况下，Servlet 在 Web 容器启动时是不会被实例化的。</p></li></ol><h5 id="1-1-3、Web-容器启动时创建-Servlet-实例"><a href="#1-1-3、Web-容器启动时创建-Servlet-实例" class="headerlink" title="1.1.3、Web 容器启动时创建 Servlet 实例"></a>1.1.3、Web 容器启动时创建 <strong>Servlet</strong> 实例</h5><p>在默认的情况下，Servlet在Web容器启动时不会被实例化</p><p>修改配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.jiang.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<servlet/>中添加<load-on-startup/>的作用是，<strong>标记是否在Web服务器（这里是Tomcat）启动时创建并初始化这个 Servlet 实例</strong>，即是否在 Web 服务器启动时调用执行该 Servlet 的无参构造器方法与 init()方法，而不是在真正访问时才创建。</p><ul><li><p>它的值必须是一个整数。</p></li><li><p>当值大于等于 0 时，表示容器在启动时就加载并初始化这个 Servlet，数值越小，该 Servlet的优先级就越高，其被创建的也就越早；</p></li><li><p>当值小于 0 或者没有指定时，则表示该 Servlet 在真正被使用时才会去创建。 </p></li><li><p>当值相同时，容器会自己选择创建顺序。</p></li></ul><h5 id="1-1-4、getServletInfo-方法"><a href="#1-1-4、getServletInfo-方法" class="headerlink" title="1.1.4、getServletInfo()方法"></a>1.1.4、getServletInfo()方法</h5><p>Servlet 接口中的方法 getServletInfo()，是由程序没自己定义的有关当前 Servlet 的一些基本信息，不属于 Servlet 生命周期中的方法。</p><h4 id="1-2、SerlvetConfig"><a href="#1-2、SerlvetConfig" class="headerlink" title="1.2、SerlvetConfig"></a>1.2、SerlvetConfig</h4><h5 id="1-2-1、什么是ServletConfig"><a href="#1-2-1、什么是ServletConfig" class="headerlink" title="1.2.1、什么是ServletConfig"></a>1.2.1、什么是ServletConfig</h5><p>在 Servlet 接口的 init()方法中具有唯一的一个参数 <strong>ServletConfig</strong>。</p><p>ServletConfig 是个接口，顾名思义，就是 Servlet 配置，<strong>即在 web.xml 中对当前 Servlet 类的配置信息。</strong>Servlet 规范将Servlet 的配置信息全部封装到了 ServletConfig 接口对象中。</p><p>在 Web 容器调用 init()方法时，Web 容器首先会将 web.xml 中当前 Servlet 类的配置信息封装为一个对象。这个对象的类型实现了 ServletConfig 接口，Web 容器会将这个对象传递给init()方法中的 ServletConfig 参数。</p><h5 id="1-2-2、获取ServletConfig"><a href="#1-2-2、获取ServletConfig" class="headerlink" title="1.2.2、获取ServletConfig"></a>1.2.2、获取ServletConfig</h5><p><strong>由于 ServletConfig 对象是 Web 容器通过 init()方法传递给当前 Servlet 类的</strong>，而 init()方法只会在 Servlet 对象初始化时调用一次。所以，需要在 init()方法中将 ServletConfig 对象传递给 Servlet 的 ServletConfig 成员变量，这样 service()方法即可使用 ServletConfig 对象了。也就是说，我们需要在 Servlet 中声明一个ServletConfig 成员变量。</p><p>声明了成员变量之后，会不会存在线程安全问题？</p><p>ServletConfig变量的赋值是在init()方法进行赋值，对于所有线程来说，SerlvetConfig对象是可读的，但不能修改。</p><h5 id="1-2-3、ServletConfig-中的方法"><a href="#1-2-3、ServletConfig-中的方法" class="headerlink" title="1.2.3、ServletConfig 中的方法"></a>1.2.3、ServletConfig 中的方法</h5><p>在Java帮助文档中，可以看到接口的四个方法：</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210526103836.png" alt="image-20210526103836257"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.jiang.helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置初始化参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>myName<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>JiangZW<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>myAge<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>getInitParameter()</code>：获取指定名称的初始化参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getInitParameter(<span class="hljs-string">&quot;myName&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>getInitParameterNames()</code>：获取当前 Servlet 所有的初始化参数名称。其返回值为枚举类型 Enumeration<String>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getInitParameterNames()<br></code></pre></td></tr></table></figure></li><li><p><code>getServletName()</code>：获取当前 Servlet 的<servlet-name></servlet-name>中指定的 Servlet 名称。如上图中的 ServletName 为”hello-servlet”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getServletName()<br></code></pre></td></tr></table></figure></li><li><p><code>getServletContext()</code>：获取到当前 Servlet 的上下文对象 ServletContext。这是个非常重要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getServletContext()<br></code></pre></td></tr></table></figure></li></ul><h5 id="1-2-4、ServletConfig的特点"><a href="#1-2-4、ServletConfig的特点" class="headerlink" title="1.2.4、ServletConfig的特点"></a>1.2.4、ServletConfig的特点</h5><p>对于不同的Servlet，Tomcat会为其创建不同的ServletConfig，用于封装各自的配置信息。也就是说，<strong>一个 Servlet 就会有其对应的一个 ServletConfig 对象。</strong></p><h4 id="1-3、ServletContext"><a href="#1-3、ServletContext" class="headerlink" title="1.3、ServletContext"></a>1.3、ServletContext</h4><h5 id="1-3-1、什么是ServletContext"><a href="#1-3-1、什么是ServletContext" class="headerlink" title="1.3.1、什么是ServletContext"></a>1.3.1、什么是ServletContext</h5><p>ServletContext，即 <strong>Servlet 上下文环境</strong>，是个接口，是 <strong>Web 应用中所有 Servlet 在 Web 容器中的运行时环境</strong>。</p><p><strong>这个运行时环境随着 Web 应用的启动而创建，随着 Web 应用的关闭而销毁。也就是说，一个 Web 应用，就一个 Servlet 运行时环境，即一个ServletContext 对象。</strong></p><p>ServletContext运行环境中有哪些具体的内容？</p><ul><li><p>web.xml 文件中的配置信息</p></li><li><p>Servlet之间 可以共享的数据</p></li></ul><p>可以这么说，ServeltContext 可以代表整个Web应用。所以，ServletConetxt有另外一个名称：<code>application</code>。</p><h5 id="1-3-2、ServletContext中的方法"><a href="#1-3-2、ServletContext中的方法" class="headerlink" title="1.3.2、ServletContext中的方法"></a>1.3.2、ServletContext中的方法</h5><p>查看 Java的帮助文档，可以看到 <code>javax.servlet.ServletContext </code>接口中包含很多方法。</p><p>下面我们介绍几个常用的重要方法。</p><p>在 web.xml 中通过<context-param/>可以进行上下文参数的配置。</p><blockquote><p>上下文参数<context-param/>与初始化参数<init-param/>是不同的：</p><p>​上下文参数是当前 Web 应用中所有 Servlet 共享的参数，每个 Servlet 均可获取到.</p><p>​Servlet 初始化参数则是只有当前Servlet 可以获取到的参数。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>myName<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>JiangZW<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>myAge<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">serlvet-class</span>&gt;</span>com.jiang.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">serlvet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><p>方法：</p><ul><li><p><code>String getInitParameter ()</code></p><p>获 取 web.xml 文 件 的 <context-param/> 中 指 定 名 称 的 上 下 文 参 数 值 。 </p></li><li><p><code>Enumeration getInitParameterNames()</code></p><p>获取 web.xml 文件的<context-param/>中的所有的上下文参数名称。</p></li><li><p><code>void setAttribute(String name, Object object)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">setAttribute(<span class="hljs-string">&quot;User&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br></code></pre></td></tr></table></figure><p>在 ServletContext 的公共数据空间中，也称为域属性空间，放入数据。</p><p><strong>这些数据对于 Web应用来说，是全局性的，与整个应用的生命周期相同。</strong></p></li><li><p><code>Object getAttribute(String name)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)getAttribute(<span class="hljs-string">&quot;User&quot;</span>);<br></code></pre></td></tr></table></figure><p>从 ServletContext 的域属性空间中获取指定名称的数据。</p></li><li><p><code>void removeAttribute(String name)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">removeAttribute(<span class="hljs-string">&quot;User&quot;</span>)<br></code></pre></td></tr></table></figure><p>从 ServletContext 的域属性空间中删除指定名称的数据。</p></li><li><p><code>String getRealPath(String path)</code></p><p>获取当前 Web 应用中指定文件或目录在本地文件系统中的路径，是基于盘符的路径。绝对路径。</p></li><li><p><code>String getContextPath()</code></p><p>获取当前应用在 Web 容器中的名称。</p></li></ul><h4 id="1-4、欢迎页面设置"><a href="#1-4、欢迎页面设置" class="headerlink" title="1.4、欢迎页面设置"></a>1.4、欢迎页面设置</h4><h5 id="1-4-1、欢迎页面设置"><a href="#1-4-1、欢迎页面设置" class="headerlink" title="1.4.1、欢迎页面设置"></a>1.4.1、欢迎页面设置</h5><p>欢迎页面，是指当在浏览器地址栏中直接通过项目名称访问时，默认显示的页面，即默认访问的路径，可以是个.html、.jsp 等页面，也可以是 Servlet 的访问路径等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 web.xml 中有一个<welcome-file-list/>标签，用于指定当前应用的欢迎页面。</p><h5 id="1-4-2、指定多个欢迎页面"><a href="#1-4-2、指定多个欢迎页面" class="headerlink" title="1.4.2、指定多个欢迎页面"></a>1.4.2、指定多个欢迎页面</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index1.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index2.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index3.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以为应用指定多个欢迎页面，但只会有一个起作用。系统加载这些欢迎页面的顺序与其注册顺序相同，即由上到下逐个查找。一旦找到，则马上显示，不会再向下查找</p><h4 id="1-5、的设置与匹配"><a href="#1-5、的设置与匹配" class="headerlink" title="1.5、的设置与匹配"></a>1.5、<url-pattern/>的设置与匹配</h4><p><url-pattern/>标签用于对请求进行筛选匹配，对当前注册的 Servlet 所要处理的请求类型进行筛选。</p><p>对于<url-pattern/>中路径的写法，有多种不同模式，表示不同的意义。</p><h5 id="1-5-1、精确路径模式"><a href="#1-5-1、精确路径模式" class="headerlink" title="1.5.1、精确路径模式"></a>1.5.1、精确路径模式</h5><p>请求路径必须与<url-pattern/>的值完全相同才可被当前 Servlet 处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>someServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/some<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/s1/s2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-5-2、通配符路径模式"><a href="#1-5-2、通配符路径模式" class="headerlink" title="1.5.2、通配符路径模式"></a>1.5.2、通配符路径模式</h5><p>该模式中的路径由两部分组成：精确路径部分与通配符部分。</p><p>请求路径中只有携带了<url-pattern/>值中指定的精确路径部分才可被当前 Servlet 处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>someServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/some/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-5-3、全路径模式"><a href="#1-5-3、全路径模式" class="headerlink" title="1.5.3、全路径模式"></a>1.5.3、全路径模式</h5><p>提交的所有请求全部可被当前的 Servlet 处理。其值可以指定为&#x2F;*，也可指定为&#x2F;。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>someServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>someServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>&#x2F;*与&#x2F;表示所有请求均会被当前 Servlet 所处理。这两个路径的不同之处是：</p><ol><li>使用&#x2F;*，表示当前的 Servlet 会拦截用户对于静态资源（.css、.js、.html、.jpg、.png…..）与动态资源（.jsp）的请求。即用户不会直接获取到这些资源文件，而是将请求交给当前 Servlet</li></ol><p>来处理了。</p><ol start="2"><li>使用&#x2F;，表示当前的 Servlet 会拦截用户对于静态资源（.css、.js、.html、.jpg、.png…..），但对于动态资源的请求，是不进行拦截的。即用户请求的静态资源文件是不能直接获取到的。</li></ol></blockquote><h5 id="1-5-4、后缀名模式"><a href="#1-5-4、后缀名模式" class="headerlink" title="1.5.4、后缀名模式"></a>1.5.4、后缀名模式</h5><p>请求路径最后的资源名称必须携带<url-pattern/>中指定的后辍名，其请求才可被当前Servlet 处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>someServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie和Session</title>
    <link href="/2020/02/08/cookie%E3%80%81session/"/>
    <url>/2020/02/08/cookie%E3%80%81session/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1、Cookie"><a href="#1、Cookie" class="headerlink" title="1、Cookie"></a>1、Cookie</h2><h3 id="1-1、Cookie概述"><a href="#1-1、Cookie概述" class="headerlink" title="1.1、Cookie概述"></a>1.1、Cookie概述</h3><p>我们打开163邮箱官方。<a href="https://mail.163.com/">https://mail.163.com/</a></p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210517104232.png" alt="163邮箱"></p><p>输入账号和密码，并且点击<strong>十天内免登录</strong>。进入邮箱。</p><p>当我们关闭浏览器或关闭电脑之后，我们再次进入邮箱。<a href="https://mail.163.com/">https://mail.163.com/</a></p><p>此时我们不需要输入用户名和密码。说明：我们的账号和密码是保存在客户端，并且是在客户端的硬盘上，而不是内存中。</p><p>客户端电脑中用于保存这些会话状态的资源，称为Cookie。</p><blockquote><p>Cookie是1993由网景公司（Netscape）前雇员发明的一种进行<strong>网络会话状态跟踪的技术</strong>。</p></blockquote><p><code>会话是由一组请求与响应组成</code>，是围绕着一件相关的事情所进行的请求与响应。所以在请求与响应之间需要有数据传递的。即是需要进行会话状态跟踪的。</p><p>但是<strong>HTTP是无状态的协议</strong>，所谓的无状态，是指：请求之间无法进行数据的传递的。也就是说，HTTP是无法直到上一次的请求是什么。</p><p>因此cookie就是这种进行请求间的数据传递会话跟踪技术。</p><p>Cookie是由服务器生成，保存在客户端的一种信息载体。这个载体中存放着用户访问该站点的会话状态信息。只要cookie没有被清空或者失效，那么，保存在其中的会话状态就有效。</p><p>用户在第一次请求后，有服务器生成cookie，并将其封装到响应头中，以响应的形式发送给客户端。客户端接受到这个响应后，将Cookie保存在客户端。当客户端再次发送同类请求后，在请求中会携带保存在客户端的Cookie数据，发送到服务端，由服务端对会话进行跟踪。</p><h3 id="1-2、服务端生成Cooike"><a href="#1-2、服务端生成Cooike" class="headerlink" title="1.2、服务端生成Cooike"></a>1.2、服务端生成Cooike</h3><h4 id="cookie的生成和获取"><a href="#cookie的生成和获取" class="headerlink" title="cookie的生成和获取"></a>cookie的生成和获取</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                  http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>Demo1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.jiang.SomeServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>Demo1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/demo1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>&lt;/web-app &gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//创建两个cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;JiangZW&quot;</span>);<br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br><br>        <span class="hljs-comment">//向响应中添加cookie</span><br>        resp.addCookie(cookie1);<br>        resp.addCookie(cookie2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到在响应头中，有从服务端返回的Cookie</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518182351.png" alt="生成cookie"></p><p>我们说过，cookie是用来请求之间的数据传递的。</p><p>如果我们发送同类请求，Cookie是否会发送？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OtherServlet</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>Demo2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.jiang.OtherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>Demo2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/demo2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以看到，我们访问localhost:8080&#x2F;demo2，请求头上cookie携带上一次请求的数据。并将它传递给服务端。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518182820.png" alt="携带cookie"></p><p>我们可以在服务端接受前端传来的cookie数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OtherServlet</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        Cookie[] cookies = req.getCookies();<br><br>        <span class="hljs-keyword">for</span> (Cookie cookie:cookies) &#123;<br>            System.out.println(cookie.getName() + <span class="hljs-string">&quot;   &quot;</span> + cookie.getValue() + <span class="hljs-string">&quot;    &quot;</span> + cookie.getPath());<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518183201.png" alt="服务端得到cookie"></p><h4 id="设置有效期"><a href="#设置有效期" class="headerlink" title="设置有效期"></a>设置有效期</h4><p>在默认的情况下，Cookie是保存在浏览器的缓存中，浏览器关闭，缓存消失，Cookie消失。通过Cookie设置有效时长，可以将Cookie写入客户端硬盘文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        <span class="hljs-comment">//创建两个cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;JiangZW&quot;</span>);<br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br><br>        <span class="hljs-comment">//设置有效期</span><br>        cookie1.setMaxAge(<span class="hljs-number">100</span>);<br>        cookie2.setMaxAge(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//向响应中添加cookie</span><br>        resp.addCookie(cookie1);<br>        resp.addCookie(cookie2);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="绑定路径"><a href="#绑定路径" class="headerlink" title="绑定路径"></a>绑定路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        <span class="hljs-comment">//创建两个cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;JiangZW&quot;</span>);<br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br><br>        <span class="hljs-comment">//指定cookie绑定路径</span><br>        cookie1.setPath(req.getContextPath() + <span class="hljs-string">&quot;/xxx/demo1&quot;</span>);<br>        cookie2.setPath(req.getContextPath() + <span class="hljs-string">&quot;/xxx/demo2&quot;</span>);<br>        <span class="hljs-comment">//向响应中添加cookie</span><br>        resp.addCookie(cookie1);<br>        resp.addCookie(cookie2);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3、Cookie禁用"><a href="#1-3、Cookie禁用" class="headerlink" title="1.3、Cookie禁用"></a>1.3、Cookie禁用</h3><p>浏览器是可以禁用 Cookie 的。所谓禁用 Cookie 是指客户端浏览器不接收服务器发送来</p><p>的 Cookie。不过，现在的很多网站，若浏览器禁用了 Cookie，则将无法访问。例如，163邮</p><p>箱就要求浏览器不能禁用 Cookie。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518184140.png" alt="cookie禁用后登录邮箱"></p><h2 id="2、Session"><a href="#2、Session" class="headerlink" title="2、Session"></a>2、Session</h2><p>Session，即会话，是 <strong>Web 开发中的一种会话状态跟踪技术</strong>。前面所说的 Cookie也是一种会话跟踪技术。<strong>不同的是 Cookie 是将会话状态保存在了客户端而， Session 则是将会话状态保存在了服务器端</strong>。</p><p>什么是会话：</p><p>对于用户来说：当用户打开浏览器，从发出第一次请求开始，一直到最终关闭浏览器，就表示一次会话的完成。</p><h3 id="2-1、Session的使用"><a href="#2-1、Session的使用" class="headerlink" title="2.1、Session的使用"></a>2.1、Session的使用</h3><p>若要对 Session 进行操作，则可以通过 HttpServletRequest 的 getSession()方法获取。该方法具有两个重载的方法。</p><ul><li><p>public HttpSession getSession(boolean create)</p><p>用于创建 Session。若参数 create 为 true，则表示若当前没有 Session，则新建一</p><p>个 Session，若当前存在 Session 则使用当前的 Session。若参数 create 为 false 表示若当前没</p><p>有 Session，则直接返回 null。 </p></li><li><p>public HttpSession getSession()</p><p>该方法用于创建 Session。相当于 getSession(true)，即没有 Session 则创建新的 Session。</p></li></ul><h4 id="对Session域属性空间操作"><a href="#对Session域属性空间操作" class="headerlink" title="对Session域属性空间操作"></a>对Session域属性空间操作</h4><p>Session 是一个专门用于存放数据的集合，我们一般称这个用于存放数据的内存空间为域属性空间，简称域。HttpSession 中具有三个方法，是专门用于对该域属性空间中数据进行写、读操作的。</p><ul><li><p>public void setAttribute(String name, Object value)</p><p>该方法用于向 Session 的域属性空间中放入指定名称、指定值的域属性。</p></li><li><p>public Object getAttribute(String name)</p><p>该方法用于从 Session 的域属性空间中读取指定名称为域属性值。</p></li><li><p>public void removeAttribute(String name)</p><p>该方法用于从 Session 的域属性空间中删除指定名称的域属性。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        <span class="hljs-comment">//创建session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br><br>        session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jzw&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OtherServlet</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String)session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;name ====== &quot;</span> + name);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518185341.png" alt="session域的使用"></p><p>可以通过removeAttribute移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">session.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518185845.png" alt="session移除"></p><h3 id="2-2、Session原理"><a href="#2-2、Session原理" class="headerlink" title="2.2、Session原理"></a>2.2、Session原理</h3><p>多个用户均在自己的电脑上访问当前应用，发现不同用户从 Session 中读取到的都是自己所提交的参数值，并没有读取到别人的参数，并没有发生“错乱”现象。这是为什么呢？</p><p>Web开发中的Session机制，为每个用户都分配了一个Session。即一个用户一个Session，确切地说，是一次会话一个 Session 对象。同一用户可以发出多个会话，即会产生多个 Session。</p><p>在服务器中系统会为每个会话维护一个Session。不同的会话，对应不同的Session。</p><p>不同的会话，对应不同的 Session。那么，系统是如何识别各个 Session 对象的？即是如何做到在同一会话过程中，一直使用的是同一个 Session 对象呢？</p><h3 id="Session的工作流程"><a href="#Session的工作流程" class="headerlink" title="Session的工作流程"></a>Session的工作流程</h3><h4 id="生成Session列表"><a href="#生成Session列表" class="headerlink" title="生成Session列表"></a>生成Session列表</h4><p>服务器对当前应用中的 Session 是以 Map 的形式进行管理的，这个 Map 称为 Session 列 表。该 Map 的 key 为一个 32 位长度的随机串，这个随机串称为 JSessionID，value 则为 Session对象的引用。</p><p>当用户第一次提交请求时，服务端 Servlet 中执行到 request.getSession()方法后，会自动生成一个 Map.Entry 对象，key 为一个根据某种算法新生成的 JSessionID，value 则为新创建的 HttpSession 对象。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518190522.png" alt="session原理"></p><h4 id="服务器生成并发送Cookie"><a href="#服务器生成并发送Cookie" class="headerlink" title="服务器生成并发送Cookie"></a>服务器生成并发送Cookie</h4><p>在将 Session 信息写入 Session 列表后，系统还会自动将“JSESSIONID”作为 name，这 个 32 位长度的随机串作为 value，以 Cookie 的形式存放到响应报头中，并随着响应，将该Cookie 发送到客户端。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518191001.png" alt="cookie中携带sessionID"></p><h4 id="客户端接收并发送Cookie"><a href="#客户端接收并发送Cookie" class="headerlink" title="客户端接收并发送Cookie"></a>客户端接收并发送Cookie</h4><p>客户端接收到这个 Cookie 后会将其存放到浏览器的缓存中。即，只要客户端浏览器不关闭，浏览器缓存中的 Cookie 就不会消失。当用户提交第二次请求时，会将缓存中的这个 Cookie，伴随着请求的头部信息，一块发送到服务端。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518191059.png" alt="向服务端发送cookie中携带sessionID"></p><h4 id="从-Session-列表中查找"><a href="#从-Session-列表中查找" class="headerlink" title="从 Session 列表中查找"></a>从 <strong>Session</strong> 列表中查找</h4><p>服务端从请求中读取到客户端发送来的 Cookie，并根据 Cookie 的 JSSESSIONID 的值，从</p><p>Map 中查找相应 key 所对应的 value，即 Session 对象。然后，对该 Session 对象的域属性进</p><p>行读写操作。</p><h3 id="2-3、Session失效"><a href="#2-3、Session失效" class="headerlink" title="2.3、Session失效"></a>2.3、Session失效</h3><p>Web 开发中引入的 Session 超时的概念，Session 的失效就是指 Session 的超时。若某个Session 在指定的时间范围内一直未被访问，那么 Session 将超时，即将失效。</p><p>在 web.xml 中可以通过<session-config/>标签设置 Session 的超时时间，单位为分钟。默认 Session 的超时时间为 30 分钟。需要再次强调的是，这个时间并不是从 Session 被创建开始计时的生命周期时长，而是从最后一次被访问开始计时，在指定的时长内一直未被访问的时长。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们也可以通过代码失效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">session.invalidate();<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518191411.png" alt="session失效"></p><h3 id="2-4、禁用cookie后的session"><a href="#2-4、禁用cookie后的session" class="headerlink" title="2.4、禁用cookie后的session"></a>2.4、禁用cookie后的session</h3><p>当我们在客户端禁用cookie之后，在服务端不会受到影响。依旧会创建cookie和session。并通过响应返回给客户端。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518192708.png" alt="服务端依旧会生成session  并传递给客户端"></p><p>我们不关闭浏览器，再次访问localhost:8080&#x2F;demo1。</p><p>发现出现的JSESSIONID不是原来的值了。</p><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210518192835.png" alt="session值"></p><p>我们没有关闭浏览器，这是一次会话，但出现的session不同。</p><p>若客户端浏览器禁用了 Cookie，会发现向服务器所提交的每一次请求，服务器在给出的响应中都会包含名称为 JSESSIONID 的 Cookie，只不过这个 Cookie 的值每一次都不同。也就是说，只要客户端浏览器所提交的请求中没有包含 JSESSIONID，服务器就会认为这是一次新的会话的开始，就会为其生成一个 Map.Entry 对象，key 为新的 32 位长度的随机串，value为新创建的 Session 会话引用。这样的话，也就无法实现会话跟踪了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于位图的优先级算法</title>
    <link href="/2020/02/05/%E5%9F%BA%E4%BA%8E%E4%BD%8D%E5%9B%BE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
    <url>/2020/02/05/%E5%9F%BA%E4%BA%8E%E4%BD%8D%E5%9B%BE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs markdown">要求写就绪表，获取最高优先级怎样让任务进入退出就绪.<br><br>6对应二进制为：000110<br><br>高3位：000=0通过OSMapTbl映射后：OSMapTbl[prio&gt;&gt;3]=OSMapTbl[0]=00000001<br><br>低3位：110=6通过OSMapTbl映射后: OSRdyTbl[prio&gt;&gt;3]=OSRdyTbl[0]=010<span class="hljs-strong">****</span><span class="hljs-strong">***</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">10对应二进制为：001010</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">高三位：001=1通过OSMapTbl映射后 OSMapTbl[prio&gt;&gt;3]=OSMapTbl[1]=00000010</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">低3位： 010=2通过OSMapTbl映射后 OSRdyTbl[prio&gt;&gt;3]=OSRdyTbl[1]=00000100</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">11对应二进制为：001011</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">高三位：001=1通过OSMapTbl映射后 OSMapTbl[prio&gt;&gt;3]=OSMapTbl[1]=00000010</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">低三位：011=3通过OsMapTbl映射后 OSRdyTbl[prio&gt;&gt;3]=OSRdyTbl[1]=00001000</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">17对应二进制为：010001</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">高三位：010=2经过OsMapTbl映射后 OsMapTbl[prio&gt;&gt;3]=OsMapTbl[2]=00000100</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">低三位：001=1经过OsMapTbl映射后 OsRdyTbl[prio&gt;&gt;3]=OsRdyTbl[2]=00000010</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">**</span><span class="hljs-emphasis">*通过就绪任务算法：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OSRdyGrp|=OSMapTbl[prio&gt;&gt;3] //获取就绪表中的行</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OsRdyTbl[prio&gt;&gt;3]|=OSMapTbl[prio&amp;0x07]//获取就绪表中的列</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">最后OSRdyGrp的值就是将所有OsMapTbl[prio&gt;&gt;3]进行位或运算</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OSRdyGrp=00000001|00000010|00000010|00000100</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">=00000111=0x07</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OSRdyTbl[0]=01000000</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OSRdyTbl[1]=00000100|00001000=00001100 相同的行列要进行或运算</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OSRdyTbl[2]=00000010</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">然后查询优先级判定表OSUnMapTbl[]</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OSRdyGrp=0x07</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Y=OSUnMapTbl[0x07]=0说明最高优先级在第0组</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">OSRdyTbl[0]=01000000=0x40</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">X=OSUnMapTbl[0x40]=6</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">最高优先级为：prio=y*</span>8+x=6<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉排序树</title>
    <link href="/2020/01/08/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <url>/2020/01/08/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>在线性表中，我们可以通过数组和链表对数据进行查询、添加、删除。</p><p>在数组中查询的时间复杂度为O(1)  , 添加删除的操作时间复杂度为O(n)</p><p>在链表中查询的时间复杂度为O(n) ，添加删除的操作时间复杂度为O(1)  【且当前已找到需要删除的数据】</p><p>因此我们<strong>通过二叉树来存储数据，以及与数据的一些处理。</strong></p><h3 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h3><p>二叉排序树(BST)，又称二叉查找树、二叉搜索树。</p><p><strong>对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点比当前节点的值大。</strong></p><p>特别说明，如果有相同的值，可以将该节点放在左子节点或右子节点。</p><p>比如对下面的一组数据（7，3，10，8，5，15，1），二叉排序树为：<br><img src="https://img-blog.csdnimg.cn/20200917110300538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>验证是否为二叉树：<br><img src="https://img-blog.csdnimg.cn/20200917110313952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>同样我们也可以进行中序遍历来验证</strong></p><h3 id="二叉排序树的创建和遍历"><a href="#二叉排序树的创建和遍历" class="headerlink" title="二叉排序树的创建和遍历"></a>二叉排序树的创建和遍历</h3><p>创建</p><p><img src="https://img-blog.csdnimg.cn/20200917110406899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200917110419469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>之后的节点添加都类似。<br>最后添加完成</p><p><img src="https://img-blog.csdnimg.cn/20200917110452388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">public</span> Node leftNode;<br>    <span class="hljs-keyword">public</span> Node rightNode;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = i;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.leftNode != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.leftNode.infixOrder();<br>        &#125;<br><br>        System.out.print(<span class="hljs-built_in">this</span>.val + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.rightNode != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.rightNode.infixOrder();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//如果新添加节点小于当前节点</span><br>        <span class="hljs-keyword">if</span>(node.val &lt; <span class="hljs-built_in">this</span>.val)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.leftNode == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-built_in">this</span>.leftNode = node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.leftNode.add(node);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果新添加节点大于等于当前节点</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.rightNode == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-built_in">this</span>.rightNode = node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.rightNode.add(node);<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.root.infixOrder();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;二叉排序树为空&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//二叉排序树添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            root = node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            root.add(node);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySortTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">7</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">8</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">15</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>();<br><br>        tree.add(node1);<br>        tree.add(node2);<br>        tree.add(node3);<br>        tree.add(node4);<br>        tree.add(node5);<br>        tree.add(node6);<br>        tree.add(node7);<br><br>        tree.infixOrder();   <span class="hljs-comment">//1 3  5 7 8 10 15</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><p>二叉排序树的删除需要考虑三种情况：</p><p>1、删除叶子节点</p><p>2、删除只有一个子树的节点</p><p>3、删除有两颗子树的节点</p><p>我们重新创建一个二叉排序树，节点值为：【7，3，10，12，5，1，9，2】</p><p>二叉排序树为：<br><img src="https://img-blog.csdnimg.cn/2020091711052189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>第一种情况：删除节点2、5、9、12</p><p>1、找到需要删除的节点</p><p>2、找到需要删除节点的父节点</p><p>3、判断需要删除节点是父节点的左子节点或右子节点</p><p>4、如果为左子节点，parent.leftNode &#x3D; null，如果为右子节点，parent.rightNode &#x3D; null</p><p>删除节点2之后：<br><img src="https://img-blog.csdnimg.cn/20200917110534228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>第二种情况：删除节点1</p><p>1、找到需要删除的节点targetNode</p><p>2、找到targetNode的父节点parent</p><p>3、确定targetNode的子结点是左子结点还是右子节点</p><p>4、确定targetNode是parent的左子节点还是右子节点。</p><p>5、如果targetNode有左子节点</p><p>​                  5.1、如果targetNode是parent的左子节点   parent.leftNode &#x3D; targetNode.left;</p><p>​  5.2、如果targetNode是parent的右子节点   parent.rightNode &#x3D; targetNode.left;</p><p>6、如果targetNode有右子节点</p><p>​                  5.1、如果targetNode是parent的左子节点   parent.leftNode &#x3D; targetNode.right;</p><p>​  5.2、如果targetNode是parent的右子节点   parent.rightNode &#x3D; targetNode.right;</p><p>删除节点1之后：<br><img src="https://img-blog.csdnimg.cn/20200917110548177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>第三种情况 ：删除节点3，10</p><p>1、找到需要删除的节点targetNode</p><p>2、找到targetNode的父节点parent</p><p>3、从targetNode的右子树中找到最小的节点【或者左子树中找到最大节点】 。</p><p>4、用一个临时变量，将最小的节点的值保存到temp中。</p><p>5、删除右子树中最小的节点【或左子树中最大的节点】</p><p>6、targetNode.val &#x3D; temp;</p><p>删除节点3之后：</p><p><img src="https://img-blog.csdnimg.cn/20200917110610350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">public</span> Node leftNode;<br>    <span class="hljs-keyword">public</span> Node rightNode;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = i;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.leftNode != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.leftNode.infixOrder();<br>        &#125;<br><br>        System.out.print(<span class="hljs-built_in">this</span>.val + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.rightNode != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.rightNode.infixOrder();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//如果新添加节点小于当前节点</span><br>        <span class="hljs-keyword">if</span>(node.val &lt; <span class="hljs-built_in">this</span>.val)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.leftNode == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-built_in">this</span>.leftNode = node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.leftNode.add(node);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果新添加节点大于等于当前节点</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.rightNode == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-built_in">this</span>.rightNode = node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.rightNode.add(node);<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">//查找需要删除的节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">Search</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.val == val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.val &lt; val)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.rightNode == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rightNode.Search(val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.leftNode == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.leftNode.Search(val);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找需要删除节点的父节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">SearchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-built_in">this</span>.leftNode != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.leftNode.val == val) || (<span class="hljs-built_in">this</span>.rightNode != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.rightNode.val == val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span><br>            <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-built_in">this</span>.val &amp;&amp; <span class="hljs-built_in">this</span>.leftNode != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.leftNode.SearchParent(val);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt;= <span class="hljs-built_in">this</span>.val &amp;&amp; <span class="hljs-built_in">this</span>.rightNode != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rightNode.SearchParent(val);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tree</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.root.infixOrder();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;二叉排序树为空&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//二叉排序树添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            root = node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            root.add(node);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//查找需要删除的节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">Search</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> root.Search(val);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找父节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">SearchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> root.SearchParent(val);<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">//找到需要删除节点的右子树的最小值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delRightTreeMin</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-keyword">while</span>(target.leftNode != <span class="hljs-literal">null</span>)&#123;<br>            target = target.leftNode;<br>        &#125;<br><br>        delNode(target.val);<br><br>        <span class="hljs-keyword">return</span> target.val;<br>    &#125;<br><br><br>    <span class="hljs-comment">//删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//1、找到需要删除的节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">targetNode</span> <span class="hljs-operator">=</span> Search(val);<br>            <span class="hljs-keyword">if</span>(targetNode == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果当前二叉排序树只有一个节点</span><br>            <span class="hljs-keyword">if</span>(root.leftNode == <span class="hljs-literal">null</span> || root.rightNode == <span class="hljs-literal">null</span>)&#123;<br>                root = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//找到targetNode 的父节点,因为不是根节点，所以一定右父节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> SearchParent(val);<br><br>            <span class="hljs-comment">//如果要删除的节点是叶子节点</span><br>            <span class="hljs-keyword">if</span>(targetNode.leftNode == <span class="hljs-literal">null</span> &amp;&amp; targetNode.rightNode == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(parent.leftNode != <span class="hljs-literal">null</span> &amp;&amp; parent.leftNode.val == val)&#123;<br>                    parent.leftNode = <span class="hljs-literal">null</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parent.rightNode != <span class="hljs-literal">null</span> &amp;&amp; parent.rightNode.val == val)&#123;<br>                    parent.rightNode = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果删除的节点右两个子结点</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(targetNode.leftNode != <span class="hljs-literal">null</span> &amp;&amp; targetNode.rightNode != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">minVal</span> <span class="hljs-operator">=</span> delRightTreeMin(targetNode.rightNode);<br>                targetNode.val = minVal;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果删除的节点只有一个子结点</span><br>                <span class="hljs-comment">//子结点为左节点时</span><br>                <span class="hljs-keyword">if</span>(targetNode.leftNode != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(parent != <span class="hljs-literal">null</span>)&#123;<br>                        <span class="hljs-keyword">if</span>(parent.leftNode.val == val)&#123;<br>                            parent.leftNode = targetNode.leftNode;<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            parent.rightNode = targetNode.leftNode;<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        root = targetNode.leftNode;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//子结点为右节点时</span><br>                    <span class="hljs-keyword">if</span>(parent != <span class="hljs-literal">null</span>)&#123;<br>                        <span class="hljs-keyword">if</span>(parent.leftNode.val == val)&#123;<br>                            parent.leftNode = targetNode.rightNode;<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            parent.rightNode = targetNode.rightNode;<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        root = targetNode.rightNode;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">12</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">9</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>();<br><br>    tree.add(node1);<br>    tree.add(node2);<br>    tree.add(node3);<br>    tree.add(node4);<br>    tree.add(node5);<br>    tree.add(node6);<br>    tree.add(node7);<br>    tree.add(node8);<br><br>    tree.infixOrder();<br>    System.out.println();<br><br>    tree.delNode(<span class="hljs-number">1</span>);  <span class="hljs-comment">//2  3  5  7  9  10 12</span><br>    tree.delNode(<span class="hljs-number">12</span>);  <span class="hljs-comment">//2 3  5  7  9  10</span><br>    tree.delNode(<span class="hljs-number">10</span>);   <span class="hljs-comment">//2 3  5  7  9</span><br>    tree.infixOrder();  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线索二叉树和赫夫曼树</title>
    <link href="/2020/01/08/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2020/01/08/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>问题引入：在该树中，1，2，3结点的左右指针并没有全部被利用。我们希望充分利用各个结点的左右指针，让各个结点指向自己的前后结点。</p><p>解决方法：<strong>线索二叉树</strong></p><p><img src="https://img-blog.csdnimg.cn/20200910142141776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>介绍线索二叉树</p><p>n个结点的二叉链表含有n+1个空指针域。利用二叉链表中的空指针域，存放指向某种遍历次序下的前驱和后继结点的指针。</p><p>线索二叉树可分成前序线索二叉树，中序线索二叉树，后序线索二叉树。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200910142159389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>如何实现线索二叉树</p><p>我们中序遍历树；得到的结果是：3、1、0、4、2、5</p><p>3 的 左右结点都为空，那么我们将 3 的左右结点分别指向它的前趋和后继结点。因为3没有前趋结点，则左节点为空。3 的后继结点为1，那么右节点指向1</p><p>1 结点的右结点为空，那么右结点指向它的后继结点 0</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200910142216452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>同理：4 结点 左右指针为空，那么可以指向 0 和 2 ，5结点的左指针为空，那么可以指向2，但没有后继结点，那么右指针为空。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200910142226962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>我们可以看到：一个结点的左右指针既可以指向它的子结点，也可以指向某种遍历下的前趋和后继结点，我们如何取区分这两种情况？</p><p>我们为每个结点增加了两个线索标志域。比如 ltag和rtag；</p><p>if  （ ltag  &#x3D;&#x3D;  0） &#x2F;&#x2F;左指针指向的是左儿子</p><p>if  （ ltag  &#x3D;&#x3D;  1） &#x2F;&#x2F;左指针指向的是前趋结点</p><p>if  （ rtag  &#x3D;&#x3D;  0） &#x2F;&#x2F;右指针指向的是右儿子</p><p>if  （ rtag  &#x3D;&#x3D;  1） &#x2F;&#x2F;右指针指向的是后继结点</p></blockquote><h2 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h2><p>基本介绍：</p><p><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或子孙结点之间的通路，称为路径，通路中的分支数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</p><p><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p><p><strong>树的带权路径长度</strong>：树的带权路径长度规定为所有叶子结点的带权路径长度之和。记为WPL</p><p><strong>最优二叉树</strong>：给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度（wpl）达到最小。</p><p>如何构造一棵赫夫曼树：</p><p>这里有五个结点。构造一棵最优二叉树，根据规则，这些结点只能是叶子结点，且WPL必须最小。<br><img src="https://img-blog.csdnimg.cn/20200910142243591.png#pic_center" alt="在这里插入图片描述"></p><p>示例一：WPL &#x3D; 3 X (3+2+1+4) + 2 X 5 &#x3D; 40</p><p><img src="https://img-blog.csdnimg.cn/20200910142253909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>示例二：WPL &#x3D; 5 X 5 + 4 X 4 + 3 X 3 + 2 X 2 + 1 X 1 &#x3D; 55<br><img src="https://img-blog.csdnimg.cn/20200910142305278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>我们注意到：要想WPL越小，树的高度尽量小，<strong>并且权值大的结点应该越接近根结点</strong></p></blockquote><p>赫夫曼树创建思路：</p><blockquote><p>1、先将结点按权值大小排序，将每个结点都看成一棵二叉树，那么每个结点都看成是根结点。</p><p>2、取出权值最小的两个根结点，将他们组成一棵新的二叉树</p><p>3、这颗新的二叉树的权值是前面两颗二叉树的权值之和，</p><p>4、在将这颗新的二叉树，以根结点的权值再次排序。</p><p>5、重复234的步骤，直到最后的二叉树都被处理完。</p></blockquote><p>示例：将以下结点构成一棵赫夫曼树<br><img src="https://img-blog.csdnimg.cn/20200910142342499.png#pic_center" alt="在这里插入图片描述"></p><p>1、排序</p><p><img src="https://img-blog.csdnimg.cn/20200910142351797.png#pic_center" alt="在这里插入图片描述"></p><p>2、取出权值最小的结点构成二叉树，新二叉树的根结点的权值为4<br><img src="https://img-blog.csdnimg.cn/20200910142401723.png#pic_center" alt="在这里插入图片描述"></p><p>3、根结点再次排序</p><p><img src="https://img-blog.csdnimg.cn/20200910142412333.png#pic_center" alt="在这里插入图片描述"></p><p>4、取出权值最小的根结点<br><img src="https://img-blog.csdnimg.cn/20200910142421175.png#pic_center" alt="在这里插入图片描述"></p><p>5、根结点再次排序<br><img src="https://img-blog.csdnimg.cn/2020091014243467.png#pic_center" alt="在这里插入图片描述"></p><p>6、取出权值最小的根结点<br><img src="https://img-blog.csdnimg.cn/20200910142456296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>7、根结点再次排序<br><img src="https://img-blog.csdnimg.cn/20200910142507445.png#pic_center" alt="在这里插入图片描述"></p><p>8、取出权值最小的根结点<br><img src="https://img-blog.csdnimg.cn/20200910142518264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>9、根结点再次排序<br><img src="https://img-blog.csdnimg.cn/20200910142531158.png#pic_center" alt="在这里插入图片描述"></p><p>10、取出权值最小的根结点<br><img src="https://img-blog.csdnimg.cn/20200910142541346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>11、根结点再次排序</p><p><img src="https://img-blog.csdnimg.cn/20200910142553342.png#pic_center" alt="在这里插入图片描述"></p><p>12、取出权值最小的根结点</p><p><img src="https://img-blog.csdnimg.cn/20200910142603640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>这就是一棵最优二叉树</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先创建Node结点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Node&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> Node left;<br>    <span class="hljs-keyword">private</span> Node right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(Node left)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(Node right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perOrder</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.no  );<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.perOrder();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.perOrder();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.infixOrder();<br>        &#125;<br><br>        System.out.println(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.infixOrder();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.postOrder();<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.postOrder();<br>        &#125;<br><br>        System.out.println(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//用于比较</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Node o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.no - o.no;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuffmanTreeDemo</span> &#123;<br><br>    <span class="hljs-comment">//创建赫夫曼树的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">creatHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span> &#123;<br>        <span class="hljs-comment">//第一步，将每个arr中的元素构成一个Node</span><br>        <span class="hljs-comment">//并将Node放入ArrayList</span><br>        List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(arr[i]));<br>        &#125;<br><br><br>        <span class="hljs-comment">//开始循环</span><br>        <span class="hljs-keyword">while</span> (nodes.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//排序</span><br>            Collections.sort(nodes);<br>            <br>            <br>            <span class="hljs-comment">//得到权值最小的两个根结点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">leftnode</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">rightnode</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//创造父亲结点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(leftnode.getNo()+rightnode.getNo());<br>            parent.setLeft(leftnode);<br>            parent.setRight(rightnode);<br><br>            <span class="hljs-comment">//移除已合并的结点</span><br>            nodes.remove(leftnode);<br>            nodes.remove(rightnode);<br>            <br>            <span class="hljs-comment">//将父结点添加进序列中</span><br>            nodes.add(parent);<br><br>        &#125;<br><br>        <span class="hljs-comment">//最后只剩下一个结点，为最优二叉树的根结点</span><br>        <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">13</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">29</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> creatHuffmanTree(arr);<br><br>        node.perOrder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">67</span><br><span class="hljs-number">29</span><br><span class="hljs-number">38</span><br><span class="hljs-number">15</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">23</span><br><span class="hljs-number">10</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2020/01/08/%E9%80%92%E5%BD%92/"/>
    <url>/2020/01/08/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>​        递归（Recurrence）是计算机、数学、运筹等领域经常使用的最强大的解决问题的方法之一。他用一种简单的方式来解决那些用其他方法解起来可能很复杂的问题。</p><p>​递归的基本思想是把一个问题划分为一个或多个规模更小的子问题。，然后用相同的方法解规模更小的子问题。注意，这里的子问题应该与原问题保持相同类型。</p><p>递归算法的设计：</p><p>1、找到问题的初始条件(递归入口)，即当问题规模n小到某一个值时，该问题变得简单，能够直接求解。</p><p>2、设计一个策略，将一个问题划分为一个或多个一步步接近递归出口的相似的规模更小子问题。</p><p>3、将所解决的各个小问题的解结合起来，即可得到原问题的解。</p><h2 id="递归应用"><a href="#递归应用" class="headerlink" title="递归应用"></a>递归应用</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><blockquote><p>问题：</p><p>n &#x3D; 0 时，F(n) &#x3D; 0</p><p>n &#x3D; 1 时，F(n) &#x3D; 1</p><p>n &gt;&#x3D; 2 时 ，F(n) &#x3D; F(n-1) + F(n-2)</p></blockquote><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Fib(n-<span class="hljs-number">1</span>) + Fib(n - <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Fib(<span class="hljs-number">7</span>));    <span class="hljs-comment">//13 </span><br>        System.out.println(Fib(<span class="hljs-number">10</span>));   <span class="hljs-comment">//55</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><blockquote><p>问题：有三根柱子，A,B,C，其中一根柱子自底向上叠着3片圆盘，现在将三块圆盘按大小顺序重新摆放在另一根柱子上。柱子上圆盘的大的在下面，圆盘小的在上面，且一次只能移动一个圆盘。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200908131540955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如图：我们将A柱上的三个圆盘移动到C柱中，需要借助B柱。</p><p>移动步骤：</p><p>1、 A-&gt;C<br><img src="https://img-blog.csdnimg.cn/20200908131551734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2、 A-&gt;B<br><img src="https://img-blog.csdnimg.cn/20200908131608542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3、 C-&gt;B<br><img src="https://img-blog.csdnimg.cn/20200908131617612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4、 A-&gt;C<br><img src="https://img-blog.csdnimg.cn/20200908131626626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>5、 B-&gt;A<br><img src="https://img-blog.csdnimg.cn/20200908131639229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>6、B-&gt;C<br><img src="https://img-blog.csdnimg.cn/20200908131648576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>7、A-&gt;C<br><img src="https://img-blog.csdnimg.cn/20200908131700322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如果我们只移动两个圆盘：</p><p>移动步骤：</p><p>1、A-&gt;B</p><p>2、A-&gt;C</p><p>3、B-&gt;C</p><p><strong>根据递归的思想：把一个问题划分为一个或多个规模更小且类型相同的子问题；</strong></p><p>假设现在有n个圆盘，需要将n个圆盘从A柱移动到C柱，我们<strong>需要将上面n-1个圆盘看成一个整体</strong>，这样问题就成为了将2个圆盘从A柱移动到C柱。将n-1个圆盘移动到B柱。<br><img src="https://img-blog.csdnimg.cn/20200908131721521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如何将n-1个圆盘移动到B柱呢?</p><p>我们继续将n-1个圆盘划分，分成n-2和1。将n-2个圆盘移动到C柱。</p><p>…</p><p>直到最后只剩下两个圆盘，这样就可以轻松移动了。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HanoiTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Move</span><span class="hljs-params">(<span class="hljs-type">char</span> m,<span class="hljs-type">char</span> n)</span>&#123;<br>        step++;<br>        System.out.println(<span class="hljs-string">&quot;第&quot;</span> + step + <span class="hljs-string">&quot;次移动  &quot;</span> + m + <span class="hljs-string">&quot;-&gt;&quot;</span> + n);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> b,<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            Move(a,c);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            Hanoi(n-<span class="hljs-number">1</span>,a,c,b);<br>            Move(a,c);<br>            Hanoi(n-<span class="hljs-number">1</span>,b,a,c);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        Hanoi(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        第1次移动  A-&gt;C</span><br><span class="hljs-comment">第2次移动  A-&gt;B</span><br><span class="hljs-comment">第3次移动  C-&gt;B</span><br><span class="hljs-comment">第4次移动  A-&gt;C</span><br><span class="hljs-comment">第5次移动  B-&gt;A</span><br><span class="hljs-comment">第6次移动  B-&gt;C</span><br><span class="hljs-comment">第7次移动  A-&gt;C</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表的常见算法题</title>
    <link href="/2020/01/08/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2020/01/08/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="链表的常见算法题："><a href="#链表的常见算法题：" class="headerlink" title="链表的常见算法题："></a>链表的常见算法题：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">解决链表的算法题通常有两种方法：<br><br><span class="hljs-code">1、 借助容器(栈、数组、哈希表...)</span><br><span class="hljs-code"></span><br><span class="hljs-code">2、 快慢指针</span><br><span class="hljs-code"></span><br>在要求空间复杂度的情况下，我们会使用快慢指针<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mariadb">1、<br>- 输入链表头节点，奇数长度返回中点，偶数长度返回上终点<br>- 输入链表头节点，奇数长度返回中点，偶数长度返回下终点<br>- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上终点<br>- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下终点<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//输入链表头节点，奇数长度返回中点，偶数长度返回上终点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">Mid1</span><span class="hljs-params">(Node head)</span>&#123;<br><br>    <span class="hljs-comment">//当有0个节点时，返回null</span><br>    <span class="hljs-comment">//当有1 、 2 个节点时，返回头节点</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next.next;<br><br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>        fast = fast.next.next;<br>        show = show.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> show;<br><br><br>&#125;<br><br><span class="hljs-comment">//输入链表头节点，奇数长度返回中点，偶数长度返回下终点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">Mid2</span><span class="hljs-params">(Node head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(head.next.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> head.next;<br><br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>        fast = fast.next.next;<br>        show = show.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> show;<br>&#125;<br><br><span class="hljs-comment">//输入链表头节点，奇数长度返回中点前一个，偶数长度返回上终点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">Mid3</span><span class="hljs-params">(Node head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next.next;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> head;<br><br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>        fast = fast.next.next;<br>        show = show.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> show;<br>&#125;<br><br><br><span class="hljs-comment">//输入链表头节点，奇数长度返回中点前一个，偶数长度返回下终点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">Mid4</span><span class="hljs-params">(Node head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(head.next.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br><br><br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>        fast = fast.next.next;<br>        show = show.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> show;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2、将单链表按某值划分成左边小，中间相等，右边大的形式。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">sort</span><span class="hljs-params">(Node head,<span class="hljs-type">int</span> num)</span>&#123;<br><br>    <span class="hljs-comment">//将改变后的链表分成3段链表</span><br><br>    <span class="hljs-comment">//第一段是小于num的链表</span><br>    <span class="hljs-comment">//设置头节点和尾节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">sH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">sT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//第二段是等于num的链表</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">eH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">eT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//第三段是大于num的链表</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">mT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><br>    <span class="hljs-comment">//遍历链表</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(cur.vaule &lt; num)&#123;<br>            <span class="hljs-keyword">if</span>(sH == <span class="hljs-literal">null</span>)&#123;<br>                sH = cur;<br>                sT = cur;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sT.next = cur;<br>                sT = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.vaule == num)&#123;<br>            <span class="hljs-keyword">if</span>(eH == <span class="hljs-literal">null</span>)&#123;<br>                eH = cur;<br>                eT = cur;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                eT.next = cur;<br>                eT = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(mH == <span class="hljs-literal">null</span>)&#123;<br>                mH = cur;<br>                mT = cur;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mT.next = cur;<br>                mT = cur;<br>            &#125;<br>        &#125;<br><br>        cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-comment">//得到三段链表之后，就需要将三段链表连接起来</span><br>    <span class="hljs-comment">//小于区域的尾巴连接等于区域的头，等于区域的尾巴连上大于区域的头</span><br>    <span class="hljs-comment">//但需要考虑各段链表是否为空</span><br><br>    <span class="hljs-comment">//如果有小于num的数</span><br>    <span class="hljs-keyword">if</span>(sT != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//将小于num的链表的尾节点连接到等于num链表的头节点</span><br>        sT.next = eH;<br>        <span class="hljs-comment">// 如果，等于num的链表为空，</span><br>        <span class="hljs-comment">// 将sT赋给eT，，因为eT要去连接mH，不可能用一个null去连接</span><br>        eT = eT == <span class="hljs-literal">null</span> ? sT : eT;<br>    &#125;<br><br>    <span class="hljs-comment">//连接</span><br>    <span class="hljs-keyword">if</span>(eT != <span class="hljs-literal">null</span>)&#123;<br>        eT.next = mH;<br>    &#125;<br><br>    <span class="hljs-comment">//因为我们没有设置null,所以在最后要设置</span><br>    <span class="hljs-keyword">if</span>(mH != <span class="hljs-literal">null</span>) &#123;<br>        mT.next = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//选出头节点，返回</span><br>    <span class="hljs-keyword">return</span> sH != <span class="hljs-literal">null</span> ? sH : (eH != <span class="hljs-literal">null</span> ? eH : mH);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">3、给定一个单链表的头节点head，请判断该链表是否为回文结构<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ispalindrome</span><span class="hljs-params">(Node head)</span>&#123;<br>    <span class="hljs-comment">//奇数找到中点，偶数找到上中点</span><br>    <span class="hljs-comment">//上一题算法给出</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> Mid1(head);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> mid.next;<br><br>    mid.next = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//用于逆序的中间变量</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//逆序</span><br>    <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>)&#123;<br>        next = cur.next;<br>        cur.next = mid;<br><br>        mid = cur;<br>        cur = next;<br>    &#125;<br><br>    cur.next = mid;<br><br><br>    <span class="hljs-comment">//前后比较</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">head1</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">head2</span> <span class="hljs-operator">=</span> cur;<br><br>    <span class="hljs-keyword">while</span>(head1 != <span class="hljs-literal">null</span> &amp;&amp; head2 != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(head1.vaule != head2.vaule)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        head1 = head1.next;<br>        head2 = head2.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">4、一种特殊的单链表节点类描述如下<br>class Node1&#123;<br><span class="hljs-code">int Vaiue;</span><br><span class="hljs-code">Node1 Next;</span><br><span class="hljs-code">Node1 rand;</span><br><span class="hljs-code">Node(int Val)&#123;Value = val&#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null<br>给定一个由Node1节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点<br><br>【要求】 <br>时间复杂度O(N),额外空间复杂度O(1)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node1 <span class="hljs-title function_">copyListWithRand1</span><span class="hljs-params">(Node1 head)</span>&#123;<br><br>    <span class="hljs-comment">//用来对应复制的节点</span><br>    <span class="hljs-comment">//前面是原来的节点，后面是新复制的节点</span><br>    HashMap&lt;Node1, Node1&gt; node1Map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//循环，复制节点中的值</span><br>    <span class="hljs-type">Node1</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">Node1</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node1</span>(cur.vaule);<br>        <span class="hljs-comment">//新老节点对应</span><br>        node1Map.put(cur,node1);<br>        cur = cur.next;<br>    &#125;<br><br>    cur = head;<br>    <span class="hljs-comment">//新复制节点来设置next和rand</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">Node1</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> node1Map.get(cur);<br>        <span class="hljs-type">Node1</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node1Map.get(cur.next);<br>        <span class="hljs-type">Node1</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> node1Map.get(cur.rand);<br><br>        node.next = next;<br>        node.rand = rand;<br><br>        cur = cur.next;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> node1Map.get(head);<br>&#125;<br><br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node1 <span class="hljs-title function_">copyListWithRand2</span><span class="hljs-params">(Node1 head)</span>&#123;<br><br>    <span class="hljs-type">Node1</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><br>    <span class="hljs-comment">//将复制的节点连接到原来的节点的next上</span><br>    <span class="hljs-comment">//    原来的链表:   1 -&gt; 2 -&gt; 3 -&gt; null</span><br>    <span class="hljs-comment">// 复制之后的链表:   1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27; -&gt;null</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">Node1</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cur.next;<br><br>        <span class="hljs-type">Node1</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node1</span>(cur.vaule);<br><br>        cur.next = node1;<br>        node1.next = node;<br><br>        cur = cur.next.next;<br>    &#125;<br><br>    cur = head;<br>    <span class="hljs-comment">//新的链表</span><br>    <span class="hljs-type">Node1</span> <span class="hljs-variable">curCopy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node1</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//设置新链表的rand值</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        next = cur.next.next;<br>        curCopy = cur.next;<br>        curCopy.rand = cur.rand != <span class="hljs-literal">null</span> ? cur.rand.next : <span class="hljs-literal">null</span>;<br><br>        cur = next;<br>    &#125;<br><br>    <span class="hljs-type">Node1</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.next;<br><br>    cur = head;<br>    <br>    <span class="hljs-comment">//设置新链表的next</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        next = cur.next.next;<br>        curCopy = cur.next;<br>        cur.next = next;<br><br>        curCopy.next = next != <span class="hljs-literal">null</span> ? next.next : <span class="hljs-literal">null</span>;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">5、给定两个可能有环环可能无环的单链表，头节点head1和head2.<br>请实现一个函数，如果两个链表相交，请返回相交的第一个节点，如果不相交，返回null<br><br>【要求】<br>如果两个链表长度之和为N，时间复杂度请达到O(N) 额外空间复杂度请达到O(1)<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">分析：<br>这题需要两种情况<br>1、 两条链表都没有环<br>2、 两天链表都有环，两个有环的链表一定有公共环，同样需要分多种情况<br><span class="hljs-code">没有相交</span><br><span class="hljs-code">两个链表入环的节点是同一个</span><br><span class="hljs-code">两个链表入环的节点不是同一个</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getloopNode</span><span class="hljs-params">(Node head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> head.next.next;<br><br>    <span class="hljs-keyword">while</span>(node1 != node2)&#123;<br>        <span class="hljs-keyword">if</span>(node2.next == <span class="hljs-literal">null</span> || node2.next.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        node2 = node2.next.next;<br>        node1 = node1.next;<br>    &#125;<br><br>    node2 = head;<br><br>    <span class="hljs-keyword">while</span>(node1 != node2)&#123;<br>        node1 = node1.next;<br>        node2 = node2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node1;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">noLoop</span><span class="hljs-params">(Node head1,Node head2)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head1 == <span class="hljs-literal">null</span> || head2.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> head1;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur2</span> <span class="hljs-operator">=</span> head2;<br><br>    <span class="hljs-comment">//记录两条链表节点个数的差值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(cur1.next != <span class="hljs-literal">null</span>)&#123;<br>        n++;<br>        cur1 = cur1.next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(cur2.next != <span class="hljs-literal">null</span>)&#123;<br>        n--;<br>        cur2 = cur2.next;<br>    &#125;<br><br>    <span class="hljs-comment">//如果两个链表的最后一个节点不相同，那么他们一定不会相交</span><br>    <span class="hljs-keyword">if</span>(cur1 != cur2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//如果相交</span><br>    <span class="hljs-comment">// n 是两条链表的节点个数的差值，</span><br>    <span class="hljs-comment">// n 的正负值决定那一条链表更长</span><br>    <span class="hljs-comment">// 长的链表先走n 步，然后两条链表一起走。</span><br>    cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;<br>    cur2 = cur1 == head1 ? head2 :head1;<br><br>    n = Math.abs(n);<br><br>    <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>        n--;<br>        cur1 = cur1.next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(cur1 != cur2)&#123;<br>        cur1 = cur1.next;<br>        cur2 = cur2.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cur1;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">BothLoop</span><span class="hljs-params">(Node head1,Node loopNode1,Node head2,Node loopNode2)</span>&#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//是公共节点</span><br>    <span class="hljs-keyword">if</span>(loopNode1 == loopNode2)&#123;<br>        cur1 = head1;<br>        cur2 = head2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (cur1 != loopNode1)&#123;<br>            n++;<br>            cur1 = cur1.next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (cur2 != loopNode1)&#123;<br>            n--;<br>            cur2 = cur2.next;<br>        &#125;<br><br><br>        cur1 = n &gt; <span class="hljs-number">0</span> ? head1 :head2;<br>        cur2 = cur1 == head1 ? head2 : head1;<br>        n = Math.abs(n);<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n--;<br>            cur1 = cur1.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(cur1 != cur2)&#123;<br>            cur1 = cur1.next;<br>            cur2 = cur2.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cur1;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cur1 = loopNode1.next;<br>        <span class="hljs-keyword">while</span>(cur1 != loopNode1)&#123;<br>            <span class="hljs-keyword">if</span>(cur1 == loopNode2)&#123;<br>                <span class="hljs-keyword">return</span> loopNode1;<br>            &#125;<br>            cur1 = cur1.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2020/01/08/%E9%98%9F%E5%88%97/"/>
    <url>/2020/01/08/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1、队列的定义及基本概念"><a href="#1、队列的定义及基本概念" class="headerlink" title="1、队列的定义及基本概念"></a>1、队列的定义及基本概念</h1><p>“队列”（Queue）这个单词时英国人说的 “排”（line）（一种等待服务的方式），在生活中，队列在我们日常生活中经常碰到，例如，排队买东西。</p><p>在计算机科学中，队列是一种数据结构，是一种特殊的线性表。和栈类似。但相差很大。</p><blockquote><p>队的操作是在两端进行，其中一端只能进行插入，该端称为队列的队尾，而另一端只能进行删除，该端称为队列的队首。队列的运算规则时FIFO（First In First Out）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831161302149.png#pic_center" alt="在这里插入图片描述"></p><p>队列的基本运算：</p><ul><li><p>置空队：建立一个空队列</p></li><li><p>判断队空：队列是否为空</p></li><li><p>判断队满：队列是否满</p></li><li><p>入队：在队列非满时，从队尾插入元素</p></li><li><p>出队：在队列非空时，从队首删除元素</p></li><li><p>取队首元素：不删除元素，返回队首元素</p></li><li><p>遍历队列：打印出数组中的有效数据</p></li></ul><blockquote><p>队列的存储具有顺序存储和链式存储两种。顺序存储通过数组存储，链式存储通过链表存储。</p></blockquote><h1 id="2、单向队列"><a href="#2、单向队列" class="headerlink" title="2、单向队列"></a>2、单向队列</h1><p>我们通过数组来模拟单向队列。</p><p>由于队列的对头和队尾的位置是变化的，因而要设置两个指针front和rear来分别指示队头元素和队尾元素在空间中的位置。</p><p>在构造顺序队列时，两个指针初始化置为0，入队时将新元素插入rear所指的位置，然后将rear加1，出队时，删除front所指的元素，然后将front加1并返回被删元素。</p><p>在入队和出队时，我们需要判断队空和队满。</p><p>图解：</p><blockquote><p>初始化：创建一个maxSize的数组  。  front 和 rear 为-1 。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831161438711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="队列初始化"></p><blockquote><p>添加数据：先将rear加1，然后将rear指向的数组赋值</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831161521822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="添加数据"></p><blockquote><p>删除数据：先front加1，然后取出front指向的数据，因为front指向的是队列头的前一个位置。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831161544823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="删除数据"></p><blockquote><p>判断为满：可以看出。当rear 等于 maxSize-1时，队列满。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831161608447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="判断队列是否满"></p><blockquote><p>判断为空：当font和rear相等时，为空</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831161636705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="判断队列是否空"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span>&#123;<br>    <span class="hljs-comment">//表示数组的最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-comment">//队列头</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;<br>    <span class="hljs-comment">//队列尾</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;<br>    <span class="hljs-comment">//该数据用于存放数据，模拟队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr;<br><br>    <span class="hljs-comment">//队列构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> arrMaxSize)</span>&#123;<br>        maxSize = arrMaxSize;<br>        <span class="hljs-comment">//创建一个长度为maxSize的数据</span><br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];<br><br>        <span class="hljs-comment">//指向队列的头部，分析出front时指向队列头的前一个位置</span><br>        front = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//指向队列的尾部，指向队列尾部的数据</span><br>        rear = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断队列是否为满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> rear == maxSize - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断队列为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">iSEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> front == rear;<br>    &#125;<br><br>    <span class="hljs-comment">//添加数据到队列中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!isFull())&#123;<br>            rear++;<br>            arr[rear] = n;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列已满，无法添加数据&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//出队列，并返回数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(iSEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法返回数据&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，不能取数据&quot;</span>);<br>        &#125;<br><br>        front++;<br>        <span class="hljs-keyword">return</span> arr[front];<br>    &#125;<br><br>    <span class="hljs-comment">//遍历队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ShowQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(iSEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> front; i &lt; rear; i++) &#123;<br>            System.out.print(arr[i + <span class="hljs-number">1</span>] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">//显示头数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GethandQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(iSEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法返回数据&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，不能取数据&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arr[front + <span class="hljs-number">1</span>];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ArrayQueue</span> <span class="hljs-variable">arrayQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayQueue</span>(<span class="hljs-number">3</span>);<br>    System.out.println(arrayQueue.iSEmpty());<br><br>    arrayQueue.AddQueue(<span class="hljs-number">1</span>);<br>    arrayQueue.AddQueue(<span class="hljs-number">2</span>);<br>    arrayQueue.ShowQueue();<br><br>    arrayQueue.GetQueue();<br>    arrayQueue.ShowQueue();<br><br>    System.out.println(arrayQueue.GethandQueue());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>问题：<br>我们添加三次数据，然后删除3次数据。 显示为满，但实际上队列中没有数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ArrayQueue</span> <span class="hljs-variable">arrayQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayQueue</span>(<span class="hljs-number">3</span>);<br><br>    arrayQueue.AddQueue(<span class="hljs-number">1</span>);<br>    arrayQueue.AddQueue(<span class="hljs-number">2</span>);<br>    arrayQueue.AddQueue(<span class="hljs-number">3</span>);<br><br>    arrayQueue.GetQueue();<br>    arrayQueue.GetQueue();<br>    arrayQueue.GetQueue();<br><br>    System.out.println(arrayQueue.isFull());  <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时数组为空，但无法存储数据；<br><img src="https://img-blog.csdnimg.cn/20200831161903863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>为了解决这个问题，<strong>我们引入循环队列，消除假溢出；</strong></p><h1 id="3、循环队列"><a href="#3、循环队列" class="headerlink" title="3、循环队列"></a>3、循环队列</h1><p>我们通过取模来实现循环队列，将数组看成一个环形。也就是当队尾到最大值maxSize时，取模，使队尾等于0。<br>在循环队列中，判空的条件使rear &#x3D;&#x3D; front ，判满的条件也是rear &#x3D;&#x3D; front，为了避免二义性。所以人为的浪费一个空间，这样判满的条件为 front &#x3D;&#x3D; （rear + 1）% maxSize；</p><p>图解：</p><blockquote><p>初始化：front和rear都等于0。</p><p>此时的front和rear的含义与单向队列中的含义不同了；</p><p>front是指向队头</p><p>rear是指向队尾的下一个数据</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831162114438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>添加一个数据：先存入数据，然后：rear  &#x3D; (rear + 1）% maxSize</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831162139530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>删除一个数据： 因为front指向的是当前数据，只能用一个临时变量将当前的数据存上，然后 front &#x3D; （front + 1）% maxSize，最后返回临   时变量</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831162206994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>判空：rear &#x3D;&#x3D; front</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831162221965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>判满：front &#x3D;&#x3D; （rear + 1）% maxSize</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200831162241766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayCircularQueue</span>&#123;<br><br>    <span class="hljs-comment">//表示数组的最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br><br>    <span class="hljs-comment">//队列头  此处的front指向队列的第一个数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;<br><br>    <span class="hljs-comment">//队列尾   此处的rear最后一个数据的下一个数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;<br><br>    <span class="hljs-comment">//该数据用于存放数据，模拟队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr;<br><br>    <span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayCircularQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> Size)</span>&#123;<br>        maxSize = Size;<br><br>        front = <span class="hljs-number">0</span>;<br>        rear = <span class="hljs-number">0</span>;<br><br>        arr  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];<br>    &#125;<br><br>    <span class="hljs-comment">//判空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> rear == front;<br>    &#125;<br><br>    <span class="hljs-comment">//判满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> front == (rear + <span class="hljs-number">1</span>) % maxSize;<br>    &#125;<br><br>    <span class="hljs-comment">//添加数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span> (isFull())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列已满&quot;</span>);<br>        &#125;<br><br>        arr[rear] = n;<br>        rear = (rear + <span class="hljs-number">1</span>) % maxSize;<br><br>    &#125;<br><br>    <span class="hljs-comment">//出队列，返回队头数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法返回数据&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，不能取数据&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> arr[front];<br>        front = (front + <span class="hljs-number">1</span>) % maxSize;<br><br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">//遍历队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ShowQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> front;<br><br>        <span class="hljs-keyword">while</span>(i != rear)<br>        &#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>            i = (i + <span class="hljs-number">1</span>) % maxSize;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">//得到队列的有效数据个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> (rear - front + maxSize) % maxSize;<br>    &#125;<br><br>    <span class="hljs-comment">//得到队列的队首数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHandQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法返回数据&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，不能取数据&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arr[front];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//实际上只能存储2个数据</span><br>    <span class="hljs-type">ArrayCircularQueue</span> <span class="hljs-variable">arrayCircularQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayCircularQueue</span>(<span class="hljs-number">3</span>);<br><br>    System.out.println(arrayCircularQueue.isEmpty());<br><br>    arrayCircularQueue.AddQueue(<span class="hljs-number">1</span>);<br>    arrayCircularQueue.AddQueue(<span class="hljs-number">2</span>);<br><br>    arrayCircularQueue.ShowQueue();<br><br>    arrayCircularQueue.GetQueue();<br><br>    arrayCircularQueue.ShowQueue();<br><br>    System.out.println(arrayCircularQueue.getHandQueue());<br><br>    System.out.println(arrayCircularQueue.Size());<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就解决了假溢出问题，队列也可以重复使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayCircularQueue</span> <span class="hljs-variable">arrayCircularQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayCircularQueue</span>(<span class="hljs-number">3</span>);<br><br>arrayCircularQueue.AddQueue(<span class="hljs-number">1</span>);<br>arrayCircularQueue.AddQueue(<span class="hljs-number">2</span>);<br><br>arrayCircularQueue.GetQueue();<br>arrayCircularQueue.GetQueue();<br><br>System.out.println(arrayCircularQueue.isFull());   <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个队列实现栈</title>
    <link href="/2020/01/06/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2020/01/06/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h1><p>栈和队列相似，都是特殊的线性表。</p><p>但在数据的运算方法与队列不同，栈为先进后出。队列是先进先出。</p><p>算法思路：</p><p>先初始化栈：初始化两个循环队列。<br><img src="https://img-blog.csdnimg.cn/202009011438452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>先存入数据：按照存入队列的方式将数据存入栈中。<br><img src="https://img-blog.csdnimg.cn/20200901143924469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>现在取出一个数据：我们将Queue1的数据依次存入Queue2中，直到Queue1只剩一个数据，然后将最后一个数据出队列。<br><img src="https://img-blog.csdnimg.cn/20200901143956212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>再加入数据：在已有数据的队列中添加数据。<br><img src="https://img-blog.csdnimg.cn/20200901144018563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>取出数据：同样，将Queue2的数据依次存入Queue1中，直到Queue2还剩最后一个数据，然后将最后一个数据出队列。<br><img src="https://img-blog.csdnimg.cn/20200901144048514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>我们发现：<br>两个队列中至少有一个是空队列<br>在出栈时，将装有数据的队列循环到另一个空队列中，当数据只有一个时，这个数据就是需要出栈的，然后将这个数据出队列。<br>在进栈时，将数据添加进已有数据的队列中，如果两个都没有，默认存入Queue1。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackByQueue</span>&#123;<br>    <span class="hljs-comment">//先定义两个循环队列，引用我上一节的类</span><br>    ArrayCircularQueue Queue1;<br>    ArrayCircularQueue Queue2;<br><br>    <span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StackByQueue</span><span class="hljs-params">()</span>&#123;<br>        Queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayCircularQueue</span>(<span class="hljs-number">5</span>);<br>        Queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayCircularQueue</span>(<span class="hljs-number">5</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(Queue1.isEmpty() &amp;&amp; Queue1.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> Queue1.AddQueue(i);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!Queue1.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> Queue1.AddQueue(i);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Queue2.AddQueue(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//出栈</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(Queue2.isEmpty() &amp;&amp; Queue1.isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!Queue1.isEmpty() &amp;&amp; Queue2.isEmpty() )&#123;<br>            <span class="hljs-comment">//当只剩下一个数据时，结束循环</span><br>            <span class="hljs-keyword">while</span>(Queue1.Size() &gt; <span class="hljs-number">1</span>)&#123;<br>                Queue2.AddQueue(Queue1.GetQueue());<br>            &#125;<br>            <span class="hljs-keyword">return</span> Queue1.GetQueue();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!Queue2.isEmpty() &amp;&amp; Queue1.isEmpty() )&#123;<br>            <span class="hljs-keyword">while</span>(Queue2.Size() &gt; <span class="hljs-number">1</span>)&#123;<br>                Queue1.AddQueue(Queue2.GetQueue());<br>            &#125;<br>            <span class="hljs-keyword">return</span> Queue2.GetQueue();<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//遍历栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ShowStack</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(!Queue1.isEmpty())&#123;<br>            System.out.print(<span class="hljs-string">&quot;Queue1:  &quot;</span>);<br>            Queue1.ShowQueue();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.print(<span class="hljs-string">&quot;Queue2:  &quot;</span>);<br>            Queue2.ShowQueue();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//栈的有效数据个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Math.max(Queue1.Size(),Queue2.Size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StackByQueue</span> <span class="hljs-variable">stackByQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StackByQueue</span>();<br><br>        stackByQueue.push(<span class="hljs-number">1</span>);<br>        stackByQueue.push(<span class="hljs-number">2</span>);<br>        stackByQueue.push(<span class="hljs-number">3</span>);<br>        stackByQueue.push(<span class="hljs-number">4</span>);<br>    <br>    <br>        stackByQueue.ShowStack(); <span class="hljs-comment">//Queue1:  1234</span><br><br>        System.out.println(stackByQueue.pop()); <span class="hljs-comment">//4</span><br>    <br>        stackByQueue.ShowStack();  <span class="hljs-comment">//Queue2:  1 23</span><br><br>        System.out.println(stackByQueue.pop()); <span class="hljs-comment">//3</span><br><br>        System.out.println(stackByQueue.Queue1.isEmpty()); <span class="hljs-comment">//false</span><br><br>        System.out.println(stackByQueue.Queue2.isEmpty()); <span class="hljs-comment">//true</span><br><br>        stackByQueue.ShowStack();    <span class="hljs-comment">//Queue1:  12</span><br><br>        System.out.println(stackByQueue.Size());  <span class="hljs-comment">//2</span><br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈的实现</title>
    <link href="/2020/01/06/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/01/06/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h1><p>栈(Stack)又称堆栈，是一种基于后进先出(LOFO)策略的集合类型。是限制在表的一端进行插入删除运算的线性表。栈可以用来在函数调用时存储断点，做递归时要用到栈。</p><p>通常将能够进行插入和删除运算的这一端称为栈顶，另一端称为栈底。当表中没有元素时称为空栈。</p><p>栈的常用运算：</p><blockquote><p>Pop():弹出操作，每次删除操作。</p><p>Push():压入操作，将数据插进栈中。</p><p>isFull():判断当前栈是否是空栈。</p><p>isEmpty():判断当前栈是否已满。</p><p>Pick():得到栈顶元素的值，但不能出栈。</p><p>Size():得到当前栈中的元素个数。</p></blockquote><h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><p>我们通过数组来实现一个简单的栈。在顺序存储下，需要考虑堆栈的上溢。这是一种出错的状态，应该避免它。</p><blockquote><p>栈的初始化：初始化一个大小为maxSize的数组，因为在栈中我们只在一端进行运算，所以我们只定义一个栈顶。并将它初始化为-1；<img src="https://img-blog.csdnimg.cn/20200906142449676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>入栈：先将栈顶+1，然后将数据压入栈中。<img src="https://img-blog.csdnimg.cn/20200906142227381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>出栈：先定义一个中间变量，将栈顶指向的数据传入这个中间变量中，然后栈顶-1；<br><img src="https://img-blog.csdnimg.cn/20200906142236623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>判空：当栈顶指向-1时，是空栈<br><img src="https://img-blog.csdnimg.cn/20200906142246213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>判满：当栈顶指针指向maxSize-1时，栈满<br><img src="https://img-blog.csdnimg.cn/2020090614225724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>得到栈顶元素：直接返回栈顶指向的数据<br><img src="https://img-blog.csdnimg.cn/2020090614231041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>得到栈中元素的个数：栈顶指针减去-1；<br><img src="https://img-blog.csdnimg.cn/20200906142319356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>显示栈中的数据：栈是一个数组，直接访问数组下标0到栈顶的元素<br><img src="https://img-blog.csdnimg.cn/20200906142328547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStackString</span> &#123;<br><br>    <span class="hljs-comment">//存储数组</span><br>    <span class="hljs-keyword">private</span> String[] arr;<br><br>    <span class="hljs-comment">//数组最大的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br><br>    <span class="hljs-comment">//表示栈顶指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pop;<br><br>    <span class="hljs-comment">//初始化栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStackString</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        maxSize = num;<br>        pop = -<span class="hljs-number">1</span>;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[maxSize];<br>    &#125;<br><br>    <span class="hljs-comment">//判满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> pop == maxSize - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//判空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> pop == -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//入栈操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(String n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(isFull())&#123; <span class="hljs-comment">//先要判满，避免堆栈上溢</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;栈已满，无法存入数据&quot;</span>);<br>        &#125;<br>        arr[++pop] = n;<br>    &#125;<br><br>    <span class="hljs-comment">//出栈操纵</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123; <span class="hljs-comment">//判空，避免堆栈下溢</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;栈空，无法取出数据&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> arr[pop--];<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//栈中数据个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> pop - (-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//得到栈顶元素</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pick</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> arr[pop];<br>    &#125;<br>    <span class="hljs-comment">//打印栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ShowStack</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= pop ; i++) &#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        <br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">ArrayStackString</span> <span class="hljs-variable">arrayStackString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayStackString</span>(<span class="hljs-number">10</span>);<br><br>    arrayStackString.push(<span class="hljs-string">&quot;a&quot;</span>);<br>    arrayStackString.push(<span class="hljs-string">&quot;b&quot;</span>);<br>    arrayStackString.push(<span class="hljs-string">&quot;c&quot;</span>);<br>    arrayStackString.push(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    arrayStackString.ShowStack(); <span class="hljs-comment">// abcd</span><br><br>    arrayStackString.pop();<br>    System.out.println(arrayStackString.Size()); <span class="hljs-comment">//3</span><br>    System.out.println(arrayStackString.pick()); <span class="hljs-comment">//c</span><br><br>    arrayStackString.ShowStack(); <span class="hljs-comment">//abc</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈的使用</title>
    <link href="/2020/01/06/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/01/06/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><blockquote><p>问题：</p><p>给出一个字符串，里面有三类括号：“（，）”、 “[，]”、 ”{，}”</p><p>括号成队出现并且嵌套正确，返回true ；否则返回false；</p></blockquote><p>示例：</p><p>input：“({()})”</p><p>output: true</p><p>input:”{(]}”</p><p>output: false</p><blockquote><p>算法：</p><p>依次扫描字符串。</p><p>1、如果出现左括号【 ‘(’、‘[’ 、‘{’  】时。进栈。</p><p>2、如果出现右括号【 ‘)’、‘]’ 、‘}’  】时</p><p>​2.1、若栈空，表达式不匹配</p><p>​2.2、若栈非空，取出栈顶元素，如果匹配则栈顶元素出栈，如果不匹配，表达式不匹配，直接退出扫描。</p><p>3、最后还需要判断栈是否空，若空，则匹配成功</p></blockquote><p>示例：表达式  “  ([]{})  ”  是否匹配成功。</p><p>1、第一次扫描：’（ ‘  左括号进栈<br><img src="https://img-blog.csdnimg.cn/20200907112057616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2、第二次扫描： ‘ [  ‘左括号进栈<br><img src="https://img-blog.csdnimg.cn/20200907112109745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3、第三次扫描：’ ] ‘ 右括号，当前栈非空，取出栈顶元素， ‘ [  ‘   ,匹配成功 ，栈顶元素出栈。<br><img src="https://img-blog.csdnimg.cn/20200907112122339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4、第四次扫描：’ { ‘ 左括号进栈<br><img src="https://img-blog.csdnimg.cn/20200907112133175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>5、第五次扫描：’ } ‘ 右括号，当前栈非空，取出栈顶元素， ‘ {  ‘   ,匹配成功 ，栈顶元素出栈。<br><img src="https://img-blog.csdnimg.cn/20200907112144500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>6、第六次扫描：’ ) ‘ 右括号，当前栈非空，取出栈顶元素， ‘ )  ‘   ,匹配成功 ，栈顶元素出栈。<br><img src="https://img-blog.csdnimg.cn/20200907112153749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>7、栈为空，匹配成功。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> par  字符串表达式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>   是否匹配成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">parenthseis</span><span class="hljs-params">(String par)</span>&#123;<br>    <span class="hljs-comment">//先将字符串转换成字符数组</span><br>    <span class="hljs-type">char</span>[] chars = par.toCharArray();<br><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//定义一个字符栈</span><br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//开始扫描</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>        <span class="hljs-comment">//如果栈空且扫描到右括号</span><br>        <span class="hljs-keyword">if</span>(stack.isEmpty() &amp;&amp; (chars[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> || chars[i] == <span class="hljs-string">&#x27;]&#x27;</span> || chars[i] == <span class="hljs-string">&#x27;)&#x27;</span>))&#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果扫描到左括号</span><br>        <span class="hljs-keyword">if</span>((chars[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || chars[i] == <span class="hljs-string">&#x27;[&#x27;</span> || chars[i] == <span class="hljs-string">&#x27;(&#x27;</span>))&#123;<br>            stack.push(chars[i]);<br>        &#125;<br>        <span class="hljs-comment">//如果栈非空，且扫描到右括号</span><br>        <span class="hljs-keyword">if</span>(!stack.isEmpty() &amp;&amp; (chars[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> || chars[i] == <span class="hljs-string">&#x27;]&#x27;</span> || chars[i] == <span class="hljs-string">&#x27;)&#x27;</span>))&#123;<br>            <span class="hljs-comment">//取出栈顶元素，这里可以直接取出，如果不匹配，就直接退出循环了。不用担心数据丢失</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pop();<br><br>            <span class="hljs-keyword">if</span>(pop == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; chars[i] != <span class="hljs-string">&#x27;)&#x27;</span> )&#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(pop == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; chars[i] != <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(pop == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; chars[i] != <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//如果栈非空，表达式不匹配</span><br>    <span class="hljs-keyword">if</span>(stack.size() != <span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(parenthseis(<span class="hljs-string">&quot;(&#123;&#125;)&quot;</span>));   <span class="hljs-comment">//true</span><br>        System.out.println(parenthseis(<span class="hljs-string">&quot;(&#123;[&#125;)&quot;</span>));  <span class="hljs-comment">//false</span><br>        System.out.println(parenthseis(<span class="hljs-string">&quot;&quot;</span>));       <span class="hljs-comment">//true</span><br>        System.out.println(parenthseis(<span class="hljs-string">&quot;)(&#123;&#125;)&quot;</span>));  <span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><blockquote><p>问题：将十进制转换成二进制和十六进制</p></blockquote><p>示例：</p><p>二进制：</p><p>input ：8</p><p>output : 1000</p><p>十六进制：</p><p>input : 16</p><p>output : 10</p><blockquote><p>算法：</p><p>十进制转换成二进制：除以2取余，倒序排列。使用栈就是为了倒序排列</p><p>十进制转换成十六进制：除以16取余，当余数为10-15时，就用 a-f来表示，最后倒序排列</p></blockquote><p>示例：将42转换成二进制<br><img src="https://img-blog.csdnimg.cn/2020090711223976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>出栈：二进制为：101010</p><p>示例：将30转换成十六进制<br><img src="https://img-blog.csdnimg.cn/20200907112251858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>出栈：十六进制为 1e</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 十进制转换成二进制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> num  十进制数字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  二进制字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">Binary</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br><br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数字必须为正整数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//定义栈</span><br>    Stack&lt;Integer&gt; arrayStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br><br>    <span class="hljs-comment">//开始循环</span><br>    <span class="hljs-keyword">while</span>( num != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//将余数进栈</span><br>        arrayStack.push(num % <span class="hljs-number">2</span>);<br>        num = num / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//定义字符序列可变的字符串</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">while</span>(arrayStack.size() != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//出栈</span><br>        stringBuilder.append(arrayStack.pop());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> stringBuilder.toString();<br><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 十进制转十六进制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> num  十进制数字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>   十六进制字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">Hexadecimal</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数字必须为正整数&quot;</span>);<br>    &#125;<br><br>    Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>)&#123;<br><br>        <span class="hljs-keyword">switch</span> (num % <span class="hljs-number">16</span>)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: stack.push(<span class="hljs-string">&quot;a&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: stack.push(<span class="hljs-string">&quot;b&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: stack.push(<span class="hljs-string">&quot;c&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: stack.push(<span class="hljs-string">&quot;d&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: stack.push(<span class="hljs-string">&quot;e&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: stack.push(<span class="hljs-string">&quot;f&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">//如果余数是 0 - 9 ，将数字转换成字符串，压入栈</span><br>            <span class="hljs-keyword">default</span>:stack.push(Integer.toString(num % <span class="hljs-number">16</span>));<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        num /= <span class="hljs-number">16</span>;<br>    &#125;<br><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">while</span>(stack.size() != <span class="hljs-number">0</span>)&#123;<br>        stringBuilder.append(stack.pop());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> stringBuilder.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Binary(<span class="hljs-number">42</span>));    <span class="hljs-comment">//101010</span><br>    System.out.println(Hexadecimal(<span class="hljs-number">30</span>));  <span class="hljs-comment">//1e</span><br>    System.out.println(Binary(-<span class="hljs-number">1</span>));  <span class="hljs-comment">//java.lang.RuntimeException: 数字必须为正整数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单的四则运算"><a href="#简单的四则运算" class="headerlink" title="简单的四则运算"></a>简单的四则运算</h2><p><img src="https://img-blog.csdnimg.cn/2020090711312427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200907112433861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907112452297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907112521210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907112536845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200907112552608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200907112600764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMzczNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> expression1  字符串表达式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(String expression1)</span>&#123;<br>    <span class="hljs-type">char</span>[] expression = expression1.toCharArray();<br>    <span class="hljs-comment">//创建两个栈，一个存储数据，另一个存储运算符。</span><br>    Stack&lt;Integer&gt; numstack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    Stack&lt;Character&gt; operstack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br><br>    <span class="hljs-comment">//定义相关变量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//用于扫描字符数组的下标</span><br>    <span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-comment">//用于存储扫描结果</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//用于计算</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//用于计算</span><br>    <span class="hljs-type">char</span> oper;      <span class="hljs-comment">//符号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//计算结果</span><br><br><br>    <span class="hljs-comment">//多位数拼接</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">nums</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-comment">//开始while循环</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-comment">//扫描</span><br>        ch = expression[index];<br>        <span class="hljs-comment">//判断是否是运算符</span><br>        <span class="hljs-keyword">if</span>(isOper(ch))&#123;<br>            <span class="hljs-comment">//如果是运算符栈非空</span><br>            <span class="hljs-keyword">if</span>(!operstack.isEmpty())&#123;<br>                <span class="hljs-comment">//判断当前运算符和栈顶运算符的优先级</span><br>                <span class="hljs-comment">//如果，栈顶的优先级高，则</span><br>                <span class="hljs-comment">//      取出数据栈的两个元素，，，注意顺序！！！！！</span><br>                <span class="hljs-comment">//      取出符号栈的一个元素，，然后计算</span><br>                <span class="hljs-keyword">if</span>(priority(ch) &lt;= priority(operstack.peek()))&#123;<br>                    <span class="hljs-comment">//注意取出的顺序，涉及到运算</span><br>                    num1 = numstack.pop();<br>                    num2 = numstack.pop();<br><br>                    oper = operstack.pop();<br>                    <span class="hljs-comment">//一个运算函数，数字和符号传入，注意顺序</span><br>                    res = cal(num1,num2,oper);<br>                    <span class="hljs-comment">//然后将结构传入数据栈</span><br>                    numstack.push(res);<br>                    <span class="hljs-comment">//当当前扫描的符号传入符号栈</span><br>                    operstack.push(ch);<br>                &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//如果当前的运算符优先级大于栈顶运算符，当前运算符进栈</span><br>                    operstack.push(ch);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果运算符栈是空，这直接入栈</span><br>                operstack.push(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果扫描到数字</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//将ch拼接到nums中</span><br>            nums.append(ch);<br>            <span class="hljs-comment">//如果当前数字是最后一个，直接进栈</span><br>            <span class="hljs-keyword">if</span>(index == expression.length - <span class="hljs-number">1</span>)&#123;<br>                numstack.push(Integer.parseInt(nums.toString()));<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果数字不是最后一个</span><br>                <span class="hljs-comment">//且下一个扫描到的是运算符</span><br>                <span class="hljs-keyword">if</span>(isOper(expression[index+<span class="hljs-number">1</span>]))&#123;<br>                    <span class="hljs-comment">//直接进栈</span><br>                    numstack.push(Integer.parseInt(nums.toString()));<br>                    <span class="hljs-comment">//将nums清空！！</span><br>                    nums.delete(<span class="hljs-number">0</span>,nums.length());<br>                &#125;<br>                <span class="hljs-comment">//如果扫描到的下一个是数字，则在下一次循环中拼接到nums中，直到出现运算符</span><br>            &#125;<br><br>        &#125;<br><br>        index++;<br>        <span class="hljs-keyword">if</span>(index &gt;= expression.length)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//结束扫描后，如果符号栈为空，那么还需要运算，此时，符号栈中的符号不区分优先级了。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>(operstack.isEmpty())&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//数据栈弹出两个元素</span><br>        num1 = numstack.pop();<br>        num2 = numstack.pop();<br>        <span class="hljs-comment">//符号栈弹出元素</span><br>        oper = operstack.pop();<br>        <span class="hljs-comment">//计算</span><br>        res = cal(num1,num2,oper);<br>        <span class="hljs-comment">//将结果压入数据栈</span><br>        numstack.push(res);<br>    &#125;<br><br><br>    System.out.println(numstack.pop());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断是否是运算符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> val  扫描的字符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  是否是运算符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOper</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span>&#123;<br>    <span class="hljs-keyword">return</span> val == <span class="hljs-string">&#x27;+&#x27;</span> || val == <span class="hljs-string">&#x27;-&#x27;</span> || val == <span class="hljs-string">&#x27;*&#x27;</span> || val == <span class="hljs-string">&#x27;/&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> num1  数据1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> num2  数据2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> oper  符号</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>   返回计算结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2,<span class="hljs-type">int</span> oper)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">switch</span> (oper)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            res = num2 + num1;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            res = num2 - num1;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            res = num2 * num1;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            res = num2 / num1;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 得到运算符优先级</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> oper  字符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回运算符优先级</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> oper)</span>&#123;<br>    <span class="hljs-keyword">if</span>(oper == <span class="hljs-string">&#x27;*&#x27;</span> || oper == <span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper == <span class="hljs-string">&#x27;+&#x27;</span> || oper == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    calc(<span class="hljs-string">&quot;4*5+18/3&quot;</span>);  <span class="hljs-comment">//26</span><br>    calc(<span class="hljs-string">&quot;4+6*9-20&quot;</span>);  <span class="hljs-comment">//38</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的常见算法题1</title>
    <link href="/2020/01/06/%E6%A0%91%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%981/"/>
    <url>/2020/01/06/%E6%A0%91%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%981/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h4 id="求中序遍历后继节点"><a href="#求中序遍历后继节点" class="headerlink" title="求中序遍历后继节点"></a>求中序遍历后继节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NextNode</span>&#123;<br>    <span class="hljs-type">int</span> value;<br>    NextNode left;<br>    NextNode right;<br>    NextNode parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NextNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FindNextNode</span> &#123;<br><span class="hljs-comment">//中序遍历  将节点加到list中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findAllNextNode</span><span class="hljs-params">(NextNode node, List&lt;NextNode&gt; list)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>            findAllNextNode(node.left,list);<br>        &#125;<br><br>        list.add(node);<br><br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>            findAllNextNode(node.right,list);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NextNode <span class="hljs-title function_">findNextNodeTest2</span><span class="hljs-params">(NextNode node)</span>&#123;<br>        <span class="hljs-comment">//找到头节点</span><br>        <span class="hljs-type">NextNode</span> <span class="hljs-variable">par</span> <span class="hljs-operator">=</span> node;<br><br>        <span class="hljs-keyword">while</span>(par.parent != <span class="hljs-literal">null</span>)&#123;<br>            par = par.parent;<br>        &#125;<br><br><br>        List&lt;NextNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        findAllNextNode(par,list);<br>        System.out.println(list);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size() - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(list.get(i).equals(node))&#123;<br>                <span class="hljs-keyword">return</span> list.get(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FindNextNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NextNode <span class="hljs-title function_">findLeftNode</span><span class="hljs-params">(NextNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> findLeftNode(node.left);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NextNode <span class="hljs-title function_">findNextNodeTest</span><span class="hljs-params">(NextNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> findLeftNode(node.right);<br>        &#125;<br><br>        <span class="hljs-type">NextNode</span> <span class="hljs-variable">parentNode</span> <span class="hljs-operator">=</span> node.parent;<br><br>        <span class="hljs-keyword">while</span>(parentNode != <span class="hljs-literal">null</span> &amp;&amp; parentNode.right ==node)&#123;<br>            node = parentNode;<br>            parentNode = node.parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> parentNode;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ACLTest</span> &#123;<br><br>    <span class="hljs-comment">//每一次递归传递的信息</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MSG</span>&#123;<br>        <span class="hljs-type">int</span> height;<br>        <span class="hljs-type">boolean</span> isAVLTree;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MSG</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MSG</span><span class="hljs-params">(<span class="hljs-type">int</span> height, <span class="hljs-type">boolean</span> isAVLTree)</span> &#123;<br>            <span class="hljs-built_in">this</span>.height = height;<br>            <span class="hljs-built_in">this</span>.isAVLTree = isAVLTree;<br>        &#125;<br><br>        get()...<br>        set()...<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MSG <span class="hljs-title function_">isAVL</span><span class="hljs-params">(Node head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MSG</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>        &#125;<br><br>        <span class="hljs-type">MSG</span> <span class="hljs-variable">msgLeft</span> <span class="hljs-operator">=</span> isAVL(head.left);<br>        <span class="hljs-type">MSG</span> <span class="hljs-variable">msgRight</span> <span class="hljs-operator">=</span> isAVL(head.right);<br><br>        <span class="hljs-type">MSG</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MSG</span>();<br><br>        <span class="hljs-comment">//求出树的高度</span><br>        msg.height = Math.max(msgLeft.height,msgRight.height) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//判断是否是平衡二叉树</span><br>        msg.isAVLTree = msgLeft.isAVLTree &amp;&amp; msgRight.isAVLTree &amp;&amp; (Math.abs(msgLeft.height - msgRight.height) &lt;= <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAVLTest</span><span class="hljs-params">(Node head)</span>&#123;<br>        <span class="hljs-type">MSG</span> <span class="hljs-variable">avl</span> <span class="hljs-operator">=</span> isAVL(head);<br>        <span class="hljs-keyword">return</span> avl.isAVLTree;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 公司的人员结构可以看作是一颗标准的没有环的多叉树，树的肉头点是唯一的老板，</span><br><span class="hljs-comment"> * 除老板外每个员工的都有唯一的直接上级。</span><br><span class="hljs-comment"> * 叶节点是没有任何我下属的基层员工，</span><br><span class="hljs-comment"> * 除基层员工外，每个员工都有一个或多个直接下级</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 派对的最大快乐值，你可以决定哪些员工来，哪些员工不来，规则</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1.如果某个员工来了，那么这个员工的所有直接下级都不能来，</span><br><span class="hljs-comment"> * 2.派对的整体快乐值是所有到场员工快乐值的累加</span><br><span class="hljs-comment"> * 3.你的目标的是让派对的整体的快乐值尽量大</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 给定一颗多叉树的头节点boss 请返回派对的最大快乐值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br>    <span class="hljs-comment">//这个员工的快乐值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> happy;<br>    <span class="hljs-comment">//下属</span><br>    List&lt;Employee&gt; subordinates;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">int</span> happy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.happy = happy;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHappy</span>&#123;<br><br>    <span class="hljs-comment">//每一次递归返回的信息</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&#123;<br>        <span class="hljs-comment">//头节点来时最大快乐值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> withHead;<br>        <span class="hljs-comment">//头节点不来是最大快乐值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> withOutHead;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Employee e)</span>&#123;<br>        <span class="hljs-comment">//如果是基层员工</span><br>        <span class="hljs-comment">//返回一个Info  第一个参数，如果这个员工参加的快乐值，如果这个员工不参加的快乐值为0</span><br>        <span class="hljs-keyword">if</span>(e.subordinates == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(e.happy,<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//如果不是基层员工</span><br>        <span class="hljs-comment">//定义两个变量  。如果这个员工参加  或者这个员工不参加</span><br><br>        <span class="hljs-comment">//如果参加需要先加上这位员工的快乐值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">withHeadHappy</span> <span class="hljs-operator">=</span> e.happy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">withOutHeadHappy</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//对这位员工的直接下层进行循环访问</span><br>        <span class="hljs-keyword">for</span>(Employee next : e.subordinates)&#123;<br>            <span class="hljs-comment">//得到下属的信息</span><br>            <span class="hljs-type">Info</span> <span class="hljs-variable">nextInfo</span> <span class="hljs-operator">=</span> process(next);<br>            <span class="hljs-comment">//如果这位员工参加，那么它的直接下属不能参加，所以于下属的withOutHead相加</span><br>            withHeadHappy += nextInfo.withOutHead;<br>            <span class="hljs-comment">///如果这位员工不参加，那么它的直接下属可以参加，所以于下属的withHead相加</span><br>            withOutHeadHappy += Math.max(nextInfo.withHead,nextInfo.withOutHead);<br>        &#125;<br>        <span class="hljs-comment">//返回这个员工参加或不参加有的快乐值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(withHeadHappy,withOutHeadHappy);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">MaxHappyTest</span><span class="hljs-params">(Employee employee)</span>&#123;<br>        <span class="hljs-type">Info</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> process(employee);<br>        <span class="hljs-keyword">return</span> process.withOutHead &gt; process.withHead ? process.withOutHead : process.withHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回整颗二叉树的最大距离"><a href="#返回整颗二叉树的最大距离" class="headerlink" title="返回整颗二叉树的最大距离"></a>返回整颗二叉树的最大距离</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxDistance</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&#123;<br>        <span class="hljs-comment">//最大距离</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> MaxDistance;<br>        <span class="hljs-comment">//树的高度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">int</span> maxDistance, <span class="hljs-type">int</span> hight)</span> &#123;<br>            MaxDistance = maxDistance;<br>            <span class="hljs-built_in">this</span>.height = hight;<br>        &#125;<br>        <br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-type">Info</span> <span class="hljs-variable">leftInfo</span> <span class="hljs-operator">=</span> process(head.left);<br>        <span class="hljs-type">Info</span> <span class="hljs-variable">rightInfo</span> <span class="hljs-operator">=</span> process(head.right);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.max(leftInfo.height,rightInfo.height) + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDistance</span> <span class="hljs-operator">=</span> Math.max(Math.max(leftInfo.MaxDistance,rightInfo.MaxDistance)<br>                                ,rightInfo.height + leftInfo.height + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(maxDistance,height);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">MaxDistanceTest</span><span class="hljs-params">(Node head)</span>&#123;<br>        <span class="hljs-keyword">return</span> process(head).MaxDistance;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求两个节点最近的父节点"><a href="#求两个节点最近的父节点" class="headerlink" title="求两个节点最近的父节点"></a>求两个节点最近的父节点</h4><ul><li>方法一 HashMap + HashSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findAll</span><span class="hljs-params">(Node head, Map&lt;Node,Node&gt; map)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(head.left != <span class="hljs-literal">null</span>)&#123;<br>        map.put(head.left,head);<br>        findAll(head.left,map);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(head.right != <span class="hljs-literal">null</span>)&#123;<br>        map.put(head.right,head);<br>        findAll(head.right,map);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">RecentlyFatherTest</span><span class="hljs-params">(Node head,Node node1,Node node2)</span>&#123;<br>    HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(head,<span class="hljs-literal">null</span>);<br>    findAll(head,map);<br><br>    HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    set.add(node1);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span> (map.get(node1) == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        set.add(map.get(node1));<br>        node1 = map.get(node1);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>( set.contains(node2) )&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        node2 = map.get(node2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> node2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法二  递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每一次递归返回的信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&#123;<br>    <span class="hljs-keyword">public</span> Node ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> findNode1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> findNode2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(Node ans, <span class="hljs-type">boolean</span> findNode1, <span class="hljs-type">boolean</span> findNode2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ans = ans;<br>        <span class="hljs-built_in">this</span>.findNode1 = findNode1;<br>        <span class="hljs-built_in">this</span>.findNode2 = findNode2;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">RF</span><span class="hljs-params">(Node head,Node node1,Node node2)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-type">Info</span> <span class="hljs-variable">leftInfo</span> <span class="hljs-operator">=</span> RF(head.left,node1,node2);<br>    <span class="hljs-type">Info</span> <span class="hljs-variable">rightInfo</span> <span class="hljs-operator">=</span> RF(head.right,node1,node2);<br><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">findNode1</span> <span class="hljs-operator">=</span> head == node1 || leftInfo.findNode1 || rightInfo.findNode1;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">findNode2</span> <span class="hljs-operator">=</span> head == node2 || leftInfo.findNode2 || rightInfo.findNode2;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(leftInfo.ans != <span class="hljs-literal">null</span>)&#123;<br>        ans = leftInfo.ans;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rightInfo.ans != <span class="hljs-literal">null</span>)&#123;<br>        ans = rightInfo.ans;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(findNode1 &amp;&amp; findNode2)&#123;<br>            ans = head;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(ans,findNode1,findNode2);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">RecentlyFatherTest2</span><span class="hljs-params">(Node head,Node node1,Node node2)</span>&#123;<br>    <span class="hljs-type">Info</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> RF(head, node1, node2);<br><br>    System.out.println(info.ans);<br>    <span class="hljs-keyword">return</span> info.ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="/2020/01/06/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/01/06/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>浅拷贝会创建一个新对象，如果这个对象的属性是基本类型，那么拷贝的就是基本数据类型的值。如果这个对象的属性是引用数据类型，那么拷贝的就是对象的引用地址。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现Cloneable接口  重写clone()方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thcher</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Thcher <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (Thcher) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//拷贝Thcher对象，拷贝引用地址。</span><br>    Thcher thcher;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Thcher <span class="hljs-title function_">getThcher</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> thcher;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThcher</span><span class="hljs-params">(Thcher thcher)</span> &#123;<br>        <span class="hljs-built_in">this</span>.thcher = thcher;<br>    &#125;<br><br>    <span class="hljs-comment">//浅拷贝，直接调用父类方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Student <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br><br>        <span class="hljs-keyword">return</span> (Student) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br><br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        student.age = <span class="hljs-number">1</span>;<br>        student.thcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thcher</span>();<br>        student.thcher.name = <span class="hljs-string">&quot;xiaowang&quot;</span>;<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> student.clone();<br><span class="hljs-comment">//拷贝会创建一个新对象</span><br>        System.out.println(stu2 == student);<br><span class="hljs-comment">//对象中的引用数据类型的地址不变</span><br>        System.out.println(stu2.thcher == student.thcher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210420091158.png" alt="image-20210420091158573"></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>深拷贝会将对象的所有属性都浅拷贝一份。比如：对于引用变量来说，他会创建一个新的引用，拷贝的对象指向这个新的引用。</p><p>深拷贝相比于浅拷贝速度较慢并且花销较大</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现Cloneable接口  重写clone()方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thcher</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Thcher <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (Thcher) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-type">int</span> age;<br>    Thcher thcher;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Thcher <span class="hljs-title function_">getThcher</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> thcher;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThcher</span><span class="hljs-params">(Thcher thcher)</span> &#123;<br>        <span class="hljs-built_in">this</span>.thcher = thcher;<br>    &#125;<br><br>    <span class="hljs-comment">//深拷贝，重写clone方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Student <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.thcher = <span class="hljs-built_in">this</span>.thcher.clone();<br>        student.age = <span class="hljs-built_in">this</span>.age;<br>        <span class="hljs-keyword">return</span> student;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br><br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        student.age = <span class="hljs-number">1</span>;<br>        student.thcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thcher</span>();<br>        student.thcher.name = <span class="hljs-string">&quot;xiaowang&quot;</span>;<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> student.clone();<br><span class="hljs-comment">//深拷贝，创建一个新对象</span><br>        System.out.println(stu2 == student);<br><span class="hljs-comment">//深拷贝，对象中的引用数据类型的地址不同</span><br>        System.out.println(stu2.thcher == student.thcher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Akihij/PicGo/raw/master/img/20210420091033.png" alt="image-20210420091026009"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的Java程序</title>
    <link href="/2020/01/03/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Java%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/01/03/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Java%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>这是一个简单的Java程序，所有的Java程序都有这样的结构，我们逐一对其分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstDame</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//控制台打印</span><br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>public</strong> 是Java语言的&#x3D;&#x3D;访问修饰符&#x3D;&#x3D;，用于控制程序的其他部分对当前所修饰代码的访问级别。</p><p><strong>class</strong>   可以暂时将它想象成一个盒子，里面包含的变量以及方法，Java程序的全部内容都必须放置在类中，以后有足够多的时间去从新理解它。</p><p>关键字class后面紧跟类名。类名有标准的命名规范：名字以字母开头，后面是字母和数字的任意组合，长度不限，但一定不能使用关键字。<br>公共类名和源代码的文件名必须相同。比如上面一段代码的文件名为FirstDame.java 。(.java)是文件扩展名。</p><p><strong>main</strong> Java虚拟机是从制定类中的main方法开始执行的。因此每一个Java源文件中都必须包含一个main方法，并且只有一个。我们定义的各种方法、类都可以在main中调用，但是要考虑访问修饰符。<br><strong>main</strong> 方法必须声明为public 这是Java语言的规范。</p><p>需要注意代码中的  { }  在Java语言中，并没用像Python一样严格的规定程序的书写格式。<br>在Java中 大括号 就代表程序的一部分。通常我们定义一个类时，将类的内容包含起来。在for循环时，大括号里的内容就是循环体。函数定义时，大括号里的内容就是函数体。</p><p><strong>static</strong>  我们通常将 main 都用static修饰。我们将域分成静态域和实例域。如果将域定义成静态static，那每一个类中只有一个这样的域。而类可以声明无数的对象，每一个对象对于所有的实例域都有自己的一份数据。<br>对于static目前可以简单的了解，以后会详细讲解。</p><p><strong>注释</strong>  Java的注释不会出现在可执行程序中。因此可以在源程序中根据需要添加注释。<br>添加注释通常有三种</p><ol><li><p>单行注释<br> <code>System.out.println(&quot;Hello World&quot;);//控制台打印</code></p></li><li><p>长篇注释<br> 不可以嵌套使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      控制台打印</span><br><span class="hljs-comment">      Hello World</span><br><span class="hljs-comment">       */</span><br>      System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>文档注释<br> 自动地生成文档。这种注释以 &#x2F;** 开始， 以 *&#x2F; 结束，可以与任何注释类型嵌套使用</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *This is the first sample program in Core Java Chapter 3</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *©author J</span><br><span class="hljs-comment"> */</span><br>System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>编译</strong><br>如果已经正确地命名了这个文件，并且源代码中没有任何错误，在编译这段源代码之后就会自动得到一个FirstDame.class文件，并且与源代码存储在同一目录下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
